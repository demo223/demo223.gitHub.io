<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>MySQL相关面试题 | 周岐的个人博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="logo.jpg">
    <meta name="description" content="个人技术博客">
    
    <link rel="preload" href="/assets/css/0.styles.8c53e149.css" as="style"><link rel="preload" href="/assets/js/app.a19eb3cb.js" as="script"><link rel="preload" href="/assets/js/2.34fff606.js" as="script"><link rel="preload" href="/assets/js/1.16393a26.js" as="script"><link rel="preload" href="/assets/js/55.0fcb916b.js" as="script"><link rel="prefetch" href="/assets/js/10.717bd423.js"><link rel="prefetch" href="/assets/js/100.c5cd47b0.js"><link rel="prefetch" href="/assets/js/101.7151b423.js"><link rel="prefetch" href="/assets/js/102.6b36385a.js"><link rel="prefetch" href="/assets/js/103.d3861779.js"><link rel="prefetch" href="/assets/js/104.9578b311.js"><link rel="prefetch" href="/assets/js/105.aae477dc.js"><link rel="prefetch" href="/assets/js/106.1d5215a7.js"><link rel="prefetch" href="/assets/js/107.3c330c2f.js"><link rel="prefetch" href="/assets/js/108.cefc2802.js"><link rel="prefetch" href="/assets/js/109.541aa22e.js"><link rel="prefetch" href="/assets/js/11.e0bfb9a4.js"><link rel="prefetch" href="/assets/js/110.60e0b929.js"><link rel="prefetch" href="/assets/js/111.45058523.js"><link rel="prefetch" href="/assets/js/112.d10d50d0.js"><link rel="prefetch" href="/assets/js/113.4a3deb35.js"><link rel="prefetch" href="/assets/js/114.b917d1a1.js"><link rel="prefetch" href="/assets/js/115.50e3fa0f.js"><link rel="prefetch" href="/assets/js/116.78f04bf7.js"><link rel="prefetch" href="/assets/js/117.b5372645.js"><link rel="prefetch" href="/assets/js/118.f990eb5b.js"><link rel="prefetch" href="/assets/js/119.f178eabd.js"><link rel="prefetch" href="/assets/js/12.bdf46c02.js"><link rel="prefetch" href="/assets/js/120.d98a3aa8.js"><link rel="prefetch" href="/assets/js/121.abcdf60f.js"><link rel="prefetch" href="/assets/js/122.ed3550a9.js"><link rel="prefetch" href="/assets/js/123.8ef421f8.js"><link rel="prefetch" href="/assets/js/124.1adba2c7.js"><link rel="prefetch" href="/assets/js/125.6706c196.js"><link rel="prefetch" href="/assets/js/126.1e50c7b4.js"><link rel="prefetch" href="/assets/js/127.be9df6e0.js"><link rel="prefetch" href="/assets/js/128.9e68fe60.js"><link rel="prefetch" href="/assets/js/129.f9313e6a.js"><link rel="prefetch" href="/assets/js/13.05b00624.js"><link rel="prefetch" href="/assets/js/130.87d4d918.js"><link rel="prefetch" href="/assets/js/131.b7ab0bc3.js"><link rel="prefetch" href="/assets/js/132.4bf1103a.js"><link rel="prefetch" href="/assets/js/133.2bda9aa2.js"><link rel="prefetch" href="/assets/js/134.e6631028.js"><link rel="prefetch" href="/assets/js/135.5b78aed3.js"><link rel="prefetch" href="/assets/js/136.377fd687.js"><link rel="prefetch" href="/assets/js/137.623e1a9d.js"><link rel="prefetch" href="/assets/js/138.c2e1c9a1.js"><link rel="prefetch" href="/assets/js/139.6263f657.js"><link rel="prefetch" href="/assets/js/14.092a5584.js"><link rel="prefetch" href="/assets/js/140.a54c064d.js"><link rel="prefetch" href="/assets/js/141.0de2ed45.js"><link rel="prefetch" href="/assets/js/142.61ea0663.js"><link rel="prefetch" href="/assets/js/143.24d35022.js"><link rel="prefetch" href="/assets/js/144.196d7653.js"><link rel="prefetch" href="/assets/js/145.223f0fcf.js"><link rel="prefetch" href="/assets/js/146.a09f8d1b.js"><link rel="prefetch" href="/assets/js/147.62d69c7c.js"><link rel="prefetch" href="/assets/js/148.d46a05d0.js"><link rel="prefetch" href="/assets/js/149.467faf3d.js"><link rel="prefetch" href="/assets/js/15.758ee11b.js"><link rel="prefetch" href="/assets/js/150.0443932e.js"><link rel="prefetch" href="/assets/js/151.0879c074.js"><link rel="prefetch" href="/assets/js/152.4d08f8a9.js"><link rel="prefetch" href="/assets/js/153.ce46c4fa.js"><link rel="prefetch" href="/assets/js/154.fd65dd72.js"><link rel="prefetch" href="/assets/js/155.b975728f.js"><link rel="prefetch" href="/assets/js/156.61194924.js"><link rel="prefetch" href="/assets/js/157.97e4f54e.js"><link rel="prefetch" href="/assets/js/158.5290a2f0.js"><link rel="prefetch" href="/assets/js/159.3613e64b.js"><link rel="prefetch" href="/assets/js/16.2569be64.js"><link rel="prefetch" href="/assets/js/160.87d90e6b.js"><link rel="prefetch" href="/assets/js/161.a2a67f25.js"><link rel="prefetch" href="/assets/js/162.b51ccce1.js"><link rel="prefetch" href="/assets/js/163.85d33d23.js"><link rel="prefetch" href="/assets/js/164.5504b77f.js"><link rel="prefetch" href="/assets/js/165.be283131.js"><link rel="prefetch" href="/assets/js/166.8d0352c5.js"><link rel="prefetch" href="/assets/js/167.89c23a71.js"><link rel="prefetch" href="/assets/js/168.aa736b2c.js"><link rel="prefetch" href="/assets/js/169.296ccc1d.js"><link rel="prefetch" href="/assets/js/17.5b873df7.js"><link rel="prefetch" href="/assets/js/170.c706da49.js"><link rel="prefetch" href="/assets/js/171.6f79aeb1.js"><link rel="prefetch" href="/assets/js/172.ddcae302.js"><link rel="prefetch" href="/assets/js/173.f308eb43.js"><link rel="prefetch" href="/assets/js/174.b5ece966.js"><link rel="prefetch" href="/assets/js/175.538e3125.js"><link rel="prefetch" href="/assets/js/176.d54091dd.js"><link rel="prefetch" href="/assets/js/177.2ee0aa3d.js"><link rel="prefetch" href="/assets/js/178.667b3c59.js"><link rel="prefetch" href="/assets/js/179.07595c3e.js"><link rel="prefetch" href="/assets/js/18.4c170722.js"><link rel="prefetch" href="/assets/js/180.300e0b70.js"><link rel="prefetch" href="/assets/js/181.89473dcd.js"><link rel="prefetch" href="/assets/js/182.ea6036d1.js"><link rel="prefetch" href="/assets/js/183.647f8d55.js"><link rel="prefetch" href="/assets/js/184.2e79dd55.js"><link rel="prefetch" href="/assets/js/185.bf4d6269.js"><link rel="prefetch" href="/assets/js/186.7a7ceaa7.js"><link rel="prefetch" href="/assets/js/187.09bb0f21.js"><link rel="prefetch" href="/assets/js/188.3604ce73.js"><link rel="prefetch" href="/assets/js/189.49b47b33.js"><link rel="prefetch" href="/assets/js/19.a45744ea.js"><link rel="prefetch" href="/assets/js/190.88e59ff4.js"><link rel="prefetch" href="/assets/js/191.a4b3e5c7.js"><link rel="prefetch" href="/assets/js/192.7527e6ed.js"><link rel="prefetch" href="/assets/js/193.c44a652d.js"><link rel="prefetch" href="/assets/js/194.6aaca2ce.js"><link rel="prefetch" href="/assets/js/195.64837df2.js"><link rel="prefetch" href="/assets/js/196.e1bd3d69.js"><link rel="prefetch" href="/assets/js/197.2b01de81.js"><link rel="prefetch" href="/assets/js/198.d1496fd2.js"><link rel="prefetch" href="/assets/js/199.27ab1442.js"><link rel="prefetch" href="/assets/js/20.4cb27e25.js"><link rel="prefetch" href="/assets/js/200.996d49f4.js"><link rel="prefetch" href="/assets/js/201.b71a4422.js"><link rel="prefetch" href="/assets/js/202.0ea49eaa.js"><link rel="prefetch" href="/assets/js/203.8ebb1f77.js"><link rel="prefetch" href="/assets/js/204.c8d10533.js"><link rel="prefetch" href="/assets/js/205.0b8c4d0d.js"><link rel="prefetch" href="/assets/js/206.cce9bcce.js"><link rel="prefetch" href="/assets/js/207.8130e9ba.js"><link rel="prefetch" href="/assets/js/208.871753be.js"><link rel="prefetch" href="/assets/js/209.757eda19.js"><link rel="prefetch" href="/assets/js/21.445690e6.js"><link rel="prefetch" href="/assets/js/210.983cae1d.js"><link rel="prefetch" href="/assets/js/211.8e4ddaf8.js"><link rel="prefetch" href="/assets/js/212.6412fc61.js"><link rel="prefetch" href="/assets/js/213.656a6a73.js"><link rel="prefetch" href="/assets/js/214.befcd199.js"><link rel="prefetch" href="/assets/js/215.2c292e81.js"><link rel="prefetch" href="/assets/js/216.78cc7e8b.js"><link rel="prefetch" href="/assets/js/217.4fa8b1da.js"><link rel="prefetch" href="/assets/js/218.4c8cce7c.js"><link rel="prefetch" href="/assets/js/219.d041d013.js"><link rel="prefetch" href="/assets/js/22.bc7c4cdb.js"><link rel="prefetch" href="/assets/js/220.10a9ed88.js"><link rel="prefetch" href="/assets/js/221.bc25f391.js"><link rel="prefetch" href="/assets/js/222.dfdd15b7.js"><link rel="prefetch" href="/assets/js/223.1afa90d8.js"><link rel="prefetch" href="/assets/js/224.69bb037f.js"><link rel="prefetch" href="/assets/js/225.94590311.js"><link rel="prefetch" href="/assets/js/226.d1818961.js"><link rel="prefetch" href="/assets/js/227.2a969459.js"><link rel="prefetch" href="/assets/js/228.e3f5706b.js"><link rel="prefetch" href="/assets/js/229.0e6df830.js"><link rel="prefetch" href="/assets/js/23.b7994ecf.js"><link rel="prefetch" href="/assets/js/230.6bc93aa6.js"><link rel="prefetch" href="/assets/js/231.9b7cc0ec.js"><link rel="prefetch" href="/assets/js/232.80b7488d.js"><link rel="prefetch" href="/assets/js/233.302790de.js"><link rel="prefetch" href="/assets/js/234.68b70723.js"><link rel="prefetch" href="/assets/js/235.1b3c3110.js"><link rel="prefetch" href="/assets/js/236.e536b7bb.js"><link rel="prefetch" href="/assets/js/237.cca351a3.js"><link rel="prefetch" href="/assets/js/238.f4d0edb0.js"><link rel="prefetch" href="/assets/js/239.4f57e73d.js"><link rel="prefetch" href="/assets/js/24.26e26a07.js"><link rel="prefetch" href="/assets/js/240.1e76f670.js"><link rel="prefetch" href="/assets/js/241.8795d427.js"><link rel="prefetch" href="/assets/js/242.c72205cb.js"><link rel="prefetch" href="/assets/js/243.d7105431.js"><link rel="prefetch" href="/assets/js/244.361b2ea5.js"><link rel="prefetch" href="/assets/js/245.055fa0a3.js"><link rel="prefetch" href="/assets/js/246.0dee7b05.js"><link rel="prefetch" href="/assets/js/247.c13fc7d7.js"><link rel="prefetch" href="/assets/js/248.4e481dba.js"><link rel="prefetch" href="/assets/js/25.626c2c33.js"><link rel="prefetch" href="/assets/js/26.c4aa6beb.js"><link rel="prefetch" href="/assets/js/27.b1a828b7.js"><link rel="prefetch" href="/assets/js/28.f9133ade.js"><link rel="prefetch" href="/assets/js/29.54e09df1.js"><link rel="prefetch" href="/assets/js/3.4db2e19a.js"><link rel="prefetch" href="/assets/js/30.d2654359.js"><link rel="prefetch" href="/assets/js/31.c57cf20e.js"><link rel="prefetch" href="/assets/js/32.ed5593a9.js"><link rel="prefetch" href="/assets/js/33.05f050d1.js"><link rel="prefetch" href="/assets/js/34.6d7f5b2f.js"><link rel="prefetch" href="/assets/js/35.67cc577c.js"><link rel="prefetch" href="/assets/js/36.0bbc204a.js"><link rel="prefetch" href="/assets/js/37.8ac35368.js"><link rel="prefetch" href="/assets/js/38.50bd8dba.js"><link rel="prefetch" href="/assets/js/39.38b783ce.js"><link rel="prefetch" href="/assets/js/4.66c035fd.js"><link rel="prefetch" href="/assets/js/40.cd3ee2ff.js"><link rel="prefetch" href="/assets/js/41.f4bec9a4.js"><link rel="prefetch" href="/assets/js/42.27fa7fec.js"><link rel="prefetch" href="/assets/js/43.2af4a015.js"><link rel="prefetch" href="/assets/js/44.8e48aaf4.js"><link rel="prefetch" href="/assets/js/45.d41c0319.js"><link rel="prefetch" href="/assets/js/46.de5cb880.js"><link rel="prefetch" href="/assets/js/47.cc7c8048.js"><link rel="prefetch" href="/assets/js/48.22c69558.js"><link rel="prefetch" href="/assets/js/49.cdd62276.js"><link rel="prefetch" href="/assets/js/5.632744e8.js"><link rel="prefetch" href="/assets/js/50.a7eebe42.js"><link rel="prefetch" href="/assets/js/51.a447aa90.js"><link rel="prefetch" href="/assets/js/52.c0f076a5.js"><link rel="prefetch" href="/assets/js/53.3564c5b0.js"><link rel="prefetch" href="/assets/js/54.c5c6e6be.js"><link rel="prefetch" href="/assets/js/56.2812bd7d.js"><link rel="prefetch" href="/assets/js/57.4f95d22a.js"><link rel="prefetch" href="/assets/js/58.d9baba05.js"><link rel="prefetch" href="/assets/js/59.371bd0d7.js"><link rel="prefetch" href="/assets/js/6.85f26be6.js"><link rel="prefetch" href="/assets/js/60.a715876a.js"><link rel="prefetch" href="/assets/js/61.6b1a782b.js"><link rel="prefetch" href="/assets/js/62.11484b5e.js"><link rel="prefetch" href="/assets/js/63.7b92573e.js"><link rel="prefetch" href="/assets/js/64.98aee69e.js"><link rel="prefetch" href="/assets/js/65.aa40eacd.js"><link rel="prefetch" href="/assets/js/66.67703170.js"><link rel="prefetch" href="/assets/js/67.392b86af.js"><link rel="prefetch" href="/assets/js/68.9610b8e9.js"><link rel="prefetch" href="/assets/js/69.6277fc7a.js"><link rel="prefetch" href="/assets/js/7.b775b056.js"><link rel="prefetch" href="/assets/js/70.b47adb04.js"><link rel="prefetch" href="/assets/js/71.0051199b.js"><link rel="prefetch" href="/assets/js/72.fa131834.js"><link rel="prefetch" href="/assets/js/73.fd8d275f.js"><link rel="prefetch" href="/assets/js/74.82095aed.js"><link rel="prefetch" href="/assets/js/75.41fad4ea.js"><link rel="prefetch" href="/assets/js/76.36bb1714.js"><link rel="prefetch" href="/assets/js/77.83c409c1.js"><link rel="prefetch" href="/assets/js/78.ca197ebf.js"><link rel="prefetch" href="/assets/js/79.9f0de524.js"><link rel="prefetch" href="/assets/js/80.7dd0f8a1.js"><link rel="prefetch" href="/assets/js/81.a5d44424.js"><link rel="prefetch" href="/assets/js/82.03d59f96.js"><link rel="prefetch" href="/assets/js/83.43da9399.js"><link rel="prefetch" href="/assets/js/84.e9ab171d.js"><link rel="prefetch" href="/assets/js/85.523fe07f.js"><link rel="prefetch" href="/assets/js/86.90aac9c6.js"><link rel="prefetch" href="/assets/js/87.1af6082d.js"><link rel="prefetch" href="/assets/js/88.3d7d10f0.js"><link rel="prefetch" href="/assets/js/89.69f4fbaf.js"><link rel="prefetch" href="/assets/js/90.30407e67.js"><link rel="prefetch" href="/assets/js/91.94355f67.js"><link rel="prefetch" href="/assets/js/92.8247a2fb.js"><link rel="prefetch" href="/assets/js/93.245ee436.js"><link rel="prefetch" href="/assets/js/94.a212b15e.js"><link rel="prefetch" href="/assets/js/95.dec85448.js"><link rel="prefetch" href="/assets/js/96.77ebb7ae.js"><link rel="prefetch" href="/assets/js/97.0a615ee3.js"><link rel="prefetch" href="/assets/js/98.9d539c75.js"><link rel="prefetch" href="/assets/js/99.270c2389.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.b7a3ab4f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8c53e149.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">周岐的个人博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/java SE/guide.html" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/项目总结/Mybatis使用/Mybatis分页实现.html" class="nav-link">
  项目总结
</a></div><div class="nav-item"><a href="/Java面试题/Java基础面试题/==和equals的区别.html" class="nav-link">
  Java面试题
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="了解更多" class="dropdown-title"><span class="title">了解更多</span> <span class="arrow down"></span></button> <button type="button" aria-label="了解更多" class="mobile-dropdown-title"><span class="title">了解更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/demo223" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://www.yuque.com/zhouqi-5zipq" target="_blank" rel="noopener noreferrer" class="nav-link external">
  语雀
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/java SE/guide.html" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/项目总结/Mybatis使用/Mybatis分页实现.html" class="nav-link">
  项目总结
</a></div><div class="nav-item"><a href="/Java面试题/Java基础面试题/==和equals的区别.html" class="nav-link">
  Java面试题
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="了解更多" class="dropdown-title"><span class="title">了解更多</span> <span class="arrow down"></span></button> <button type="button" aria-label="了解更多" class="mobile-dropdown-title"><span class="title">了解更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/demo223" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://www.yuque.com/zhouqi-5zipq" target="_blank" rel="noopener noreferrer" class="nav-link external">
  语雀
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/java SE/guide" class="sidebar-heading clickable"><span>java SE</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>java web</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>SpringBoot</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>微服务</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Linux</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Docker</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Mybatis-Plus</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>常用工具类</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Java面试题</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Java面试题/Java基础面试题/==和equals的区别" class="sidebar-heading clickable"><span>Java基础面试题</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Java面试题/多线程面试题/多线程面试题" class="sidebar-heading clickable"><span>多线程面试题</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Java面试题/集合面试题/Java集合相关面试题" class="sidebar-heading clickable"><span>集合面试题</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Java面试题/Mybatis面试题/Mybatis面试题" class="sidebar-heading clickable"><span>Mybatis面试题</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Java面试题/SpringBoot面试题/SpringBoot面试题" class="sidebar-heading clickable"><span>SpringBoot面试题</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Java面试题/MySQL面试题/MySQL面试题" class="sidebar-heading clickable open active"><span>MySQL面试题</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/Java面试题/MySQL面试题/MySQL面试题.html" class="active sidebar-link">MySQL面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Java面试题/MySQL面试题/MySQL面试题.html#_1-sql规范" class="sidebar-link">1 SQL规范</a></li><li class="sidebar-sub-header"><a href="/Java面试题/MySQL面试题/MySQL面试题.html#_2-事务" class="sidebar-link">2 事务</a></li><li class="sidebar-sub-header"><a href="/Java面试题/MySQL面试题/MySQL面试题.html#_3-索引" class="sidebar-link">3 索引</a></li><li class="sidebar-sub-header"><a href="/Java面试题/MySQL面试题/MySQL面试题.html#_4-调优" class="sidebar-link">4 调优</a></li><li class="sidebar-sub-header"><a href="/Java面试题/MySQL面试题/MySQL面试题.html#_5-分库分表" class="sidebar-link">5 分库分表</a></li><li class="sidebar-sub-header"><a href="/Java面试题/MySQL面试题/MySQL面试题.html#_6-mysql锁相关" class="sidebar-link">6.MySQL锁相关</a></li><li class="sidebar-sub-header"><a href="/Java面试题/MySQL面试题/MySQL面试题.html#_7-面试现场" class="sidebar-link">7 面试现场</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Java面试题/Redis面试题/Redis面试题" class="sidebar-heading clickable"><span>Redis面试题</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Java面试题/微服务面试题/微服务面试题" class="sidebar-heading clickable"><span>微服务面试题</span> <span class="arrow right"></span></a> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>项目总结</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/SpringBoot文档/01-Spring-IOC" class="sidebar-heading clickable"><span>SpringBoot文档</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/微服务文档/SpringCloud介绍" class="sidebar-heading clickable"><span>微服务文档</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="mysql相关面试题"><a href="#mysql相关面试题" class="header-anchor">#</a> MySQL相关面试题</h1> <h2 id="_1-sql规范"><a href="#_1-sql规范" class="header-anchor">#</a> 1 SQL规范</h2> <h3 id="_1-1-mysql查询语句的执行顺序"><a href="#_1-1-mysql查询语句的执行顺序" class="header-anchor">#</a> 1.1 Mysql查询语句的执行顺序？</h3> <blockquote><p>难易程度：☆☆</p> <p>出现频率：☆☆☆</p></blockquote> <p>sql的编写顺序</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">select</span>           字段列表
<span class="token keyword">from</span>             表名列表
<span class="token keyword">join</span> <span class="token keyword">on</span>          表关联
<span class="token keyword">where</span>            条件列表
<span class="token keyword">group</span> <span class="token keyword">by</span>         分组字段列表
<span class="token keyword">having</span>           分组后的条件列表
<span class="token keyword">order</span> <span class="token keyword">by</span>         排序字段列表
<span class="token keyword">limit</span>            分页参数
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>sql的执行顺序</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">from</span>             表名列表
<span class="token keyword">join</span> <span class="token keyword">on</span>          表关联
<span class="token keyword">where</span>            条件列表
<span class="token keyword">group</span> <span class="token keyword">by</span>         分组字段列表
<span class="token keyword">having</span>           分组后的条件列表
<span class="token keyword">select</span>           字段列表
<span class="token keyword">order</span> <span class="token keyword">by</span>         排序字段列表
<span class="token keyword">limit</span>            分页参数
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><blockquote><p>举例:</p> <p>sql1：select name ,age from tb_user where name = '张三'  order by age limit 10;</p> <p>给表起别名</p> <p>sql2：select <strong>u.name</strong> ,<strong>u.age</strong> from tb_user <strong>u</strong> where name = '张三'  order by <strong>u.age</strong> limit 10;</p> <p>可以正常执行，如果from后不先执行，则select和order by无法引用</p> <p>给sql的字段起别名</p> <p>sql3：select u.name <strong>uname</strong> ,u.age <strong>uage</strong> from tb_user u where <strong>uname</strong>= '张三'  order by u.age limit 10;</p> <p>在where之后使用别名，执行报错，因为where在select 之前执行</p> <p>sql4：select u.name <strong>uname</strong> ,u.age <strong>uage</strong> from tb_user u where u.name= '张三'  order by <strong>uage</strong> limit 10;</p> <p>在order by后面使用别名，可以正常执行，因为select执行完成后才会执行order by</p></blockquote> <h3 id="_1-2-mysql-如何实现多表查询"><a href="#_1-2-mysql-如何实现多表查询" class="header-anchor">#</a> 1.2 Mysql 如何实现多表查询？</h3> <blockquote><p>难易程度：☆☆</p> <p>出现频率：☆☆☆</p></blockquote> <p>多表关系</p> <ul><li>一对多：在多的一方设置外键，关联一的一方的主键</li> <li>一对一：用于表结构拆分，在其中任何一方设置外键（给唯一约束UNIQUE）,关联另一方的主键</li> <li>对多对：需要建立中间表，中间表包含两个外键，关联两张表的主键</li></ul> <p>多表查询</p> <ul><li>内连接
<ul><li>隐式：<code>select ...from 表A,表B where 条件...</code></li> <li>显式：<code>select ... from 表A inner join 表B on 条件...</code></li></ul></li> <li>外连接
<ul><li>左外连接：<code>select ...from 表A left join 表B on 条件...</code></li> <li>右外连接：<code>select ...from 表A right join 表B on 条件...</code></li></ul></li> <li>自连接：<code>select ...from 表A 别名1,表A 别名2 where 条件...</code></li> <li>子查询：列子查询、行子查询、表子查询</li></ul> <h3 id="_1-3-mysql内连接和外连接的区别"><a href="#_1-3-mysql内连接和外连接的区别" class="header-anchor">#</a> 1.3 MYSQL内连接和外连接的区别 ?</h3> <blockquote><p>难易程度：☆☆</p> <p>出现频率：☆☆☆</p></blockquote> <ul><li><p>内连接会取出连接表中匹配到的数据，匹配不到的不保留；</p></li> <li><p>外连接会取出连接表中匹配到的数据，匹配不到的也会保留，其值为NULL。</p> <ul><li>左外连接，以左边的表为主表</li> <li>右外连接，以右边的表为主表</li></ul> <p>以某一个表为主表后，进行关联查询，不管能不能关联的上，主表的数据都会保留，关联不上的以NULL显示</p></li></ul> <h3 id="_1-4-char和varchar的区别"><a href="#_1-4-char和varchar的区别" class="header-anchor">#</a> 1.4 CHAR和VARCHAR的区别？</h3> <blockquote><p>难易程度：☆☆</p> <p>出现频率：☆☆☆☆</p></blockquote> <p>区别主要有以下几个方面</p> <p>1、最大长度：char最大长度是255字符，varchar最大长度是65535个字节。</p> <p>2、定长：char是定长的，不足的部分用隐藏空格填充，varchar是不定长的。</p> <p>3、空间使用：char会浪费空间，varchar会更加节省空间。</p> <p>4、查找效率：char查找效率会很高，varchar查找效率会更低。</p> <p>​	   varchar需要计算内容占用的长度，而char不会，所以char的效率稍高一些</p> <p>在项目中的使用，这两种方式都会用到，比如像一些枚举值可以选择使用char，像一些描述信息或名字类可以选择使用varchar</p> <h2 id="_2-事务"><a href="#_2-事务" class="header-anchor">#</a> 2 事务</h2> <h3 id="_2-1-什么是事务"><a href="#_2-1-什么是事务" class="header-anchor">#</a> 2.1 什么是事务？</h3> <blockquote><p>难易程度：☆☆</p> <p>出现频率：☆☆☆</p></blockquote> <p>概述：由多个操作组成的一个逻辑单元，组成这个逻辑单元的多个操作要么都成功，要么都失败。</p> <blockquote><p>举例：转账</p> <p>A向B转账500，转账成功，A扣除500元，B增加500元</p> <p>A向B转账500，转账未成功，A已经扣除的500元要恢复，B不变</p></blockquote> <h3 id="_2-2-acid是什么-可以详细说一下吗"><a href="#_2-2-acid是什么-可以详细说一下吗" class="header-anchor">#</a> 2.2 ACID是什么？可以详细说一下吗？</h3> <blockquote><p>难易程度：☆☆☆</p> <p>出现频率：☆☆☆☆☆</p></blockquote> <p>A=Atomicity原子性：就是上面说的,要么全部成功,要么全部失败，不可能只执行一部分操作。</p> <p>C=Consistency一致性：系统(数据库)总是从一个一致性的状态转移到另一个一致性的状态,不会存在中间状态。</p> <p>I=Isolation隔离性: <strong>通常</strong>来说:一个事务在完全提交之前,对其他事务是不可见的.注意前面的通常来说加了红色,意味着有例外情况。</p> <p>D=Durability持久性：一旦事务提交,那么就永远是这样子了,哪怕系统崩溃也不会影响到这个事务的结果。</p> <blockquote><p>举例：转账</p> <p>A向B转账500，转账成功，A扣除500元，B增加500元，原子操作体现在要么都成功，要么都失败</p> <p>在转账的过程中，数据要一致，A扣除了500，B必须增加500</p> <p>在转账的过程中，隔离性体现在A像B转账，不能受其他事务干扰</p> <p>在转账的过程中，持久性体现在事务提交后，要把数据持久化（可以说是落盘操作）</p></blockquote> <h3 id="_2-3-并发事务带来哪些问题"><a href="#_2-3-并发事务带来哪些问题" class="header-anchor">#</a> 2.3 并发事务带来哪些问题？</h3> <blockquote><p>难易程度：☆☆☆☆</p> <p>出现频率：☆☆☆☆</p></blockquote> <p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p> <p><strong>脏读（Dirty read）</strong>: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</p> <p><strong>丢失修改（Lost to modify）</strong>：指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</p> <p><strong>不可重复读（Unrepeatableread）</strong>：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p> <p><strong>幻读（Phantom read）</strong>：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p> <h3 id="_2-4-怎么解决这些问题呢-mysql的默认隔离级别是"><a href="#_2-4-怎么解决这些问题呢-mysql的默认隔离级别是" class="header-anchor">#</a> 2.4 怎么解决这些问题呢？MySQL的默认隔离级别是？</h3> <blockquote><p>难易程度：☆☆☆☆</p> <p>出现频率：☆☆☆☆</p></blockquote> <p>解决方案：对事务进行隔离</p> <p>MySQL的四种隔离级别如下:</p> <p><strong>未提交读(READ UNCOMMITTED)</strong>：这个隔离级别下,其他事务可以看到本事务没有提交的部分修改。因此会造成脏读的问题(读取到了其他事务未提交的部分,而之后该事务进行了回滚)。这个级别的性能没有足够大的优势,但是又有很多的问题,因此很少使用.</p> <p>sql演示：</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token comment"># 插入数据</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> goods_innodb<span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token string">'华为'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> goods_innodb<span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token string">'小米'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment"># 会话一</span>
<span class="token keyword">set</span> <span class="token keyword">session</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation</span> <span class="token keyword">level</span> <span class="token keyword">read</span> <span class="token keyword">uncommitted</span> <span class="token punctuation">;</span>		<span class="token comment"># 设置事务的隔离级别为read uncommitted</span>
<span class="token keyword">start</span> <span class="token keyword">transaction</span> <span class="token punctuation">;</span>												<span class="token comment"># 开启事务</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> goods_innodb <span class="token punctuation">;</span>									<span class="token comment"># 查询数据</span>

<span class="token comment"># 会话二</span>
<span class="token keyword">set</span> <span class="token keyword">session</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation</span> <span class="token keyword">level</span> <span class="token keyword">read</span> <span class="token keyword">uncommitted</span> <span class="token punctuation">;</span>		<span class="token comment"># 设置事务的隔离级别为read uncommitted</span>
<span class="token keyword">start</span> <span class="token keyword">transaction</span> <span class="token punctuation">;</span>												<span class="token comment"># 开启事务</span>
<span class="token keyword">update</span> goods_innodb <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token string">'中兴'</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">10</span> <span class="token punctuation">;</span>			   <span class="token comment"># 修改数据</span>

<span class="token comment"># 会话一</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> goods_innodb <span class="token punctuation">;</span>									<span class="token comment"># 查询数据</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p><strong>已提交读(READ COMMITTED)</strong>：其他事务只能读取到本事务已经提交的部分。这个隔离级别有不可重复读的问题，在同一个事务内的两次读取,拿到的结果竟然不一样,因为另外一个事务对数据进行了修改。</p> <p>sql演示：</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token comment"># 会话一</span>
<span class="token keyword">set</span> <span class="token keyword">session</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation</span> <span class="token keyword">level</span> <span class="token keyword">read</span> <span class="token keyword">committed</span> <span class="token punctuation">;</span>		<span class="token comment"># 设置事务的隔离级别为read committed</span>
<span class="token keyword">start</span> <span class="token keyword">transaction</span> <span class="token punctuation">;</span>												<span class="token comment"># 开启事务</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> goods_innodb <span class="token punctuation">;</span>									<span class="token comment"># 查询数据</span>

<span class="token comment"># 会话二</span>
<span class="token keyword">set</span> <span class="token keyword">session</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation</span> <span class="token keyword">level</span> <span class="token keyword">read</span> <span class="token keyword">committed</span> <span class="token punctuation">;</span>		<span class="token comment"># 设置事务的隔离级别为read committed</span>
<span class="token keyword">start</span> <span class="token keyword">transaction</span> <span class="token punctuation">;</span>												<span class="token comment"># 开启事务</span>
<span class="token keyword">update</span> goods_innodb <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token string">'中兴'</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span>			   <span class="token comment"># 修改数据</span>

<span class="token comment"># 会话一</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> goods_innodb <span class="token punctuation">;</span>									<span class="token comment"># 查询数据</span>

<span class="token comment"># 会话二</span>
<span class="token keyword">commit</span><span class="token punctuation">;</span>															<span class="token comment"># 提交事务</span>

<span class="token comment"># 会话一</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> goods_innodb <span class="token punctuation">;</span>									<span class="token comment"># 查询数据</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p><strong>REPEATABLE READ(可重复读)</strong>：可重复读隔离级别解决了上面不可重复读的问题(看名字也知道)，但是不能完全解决幻读。MySql默认的事务隔离级别就是：<strong>REPEATABLE READ</strong></p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">select</span> @<span class="token variable">@tx_isolation</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220208091344590.png" alt="image-20220208091344590"></p> <p>sql演示(解决不可重复读)：</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token comment"># 会话一</span>
<span class="token keyword">start</span> <span class="token keyword">transaction</span> <span class="token punctuation">;</span>												<span class="token comment"># 开启事务</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> goods_innodb <span class="token punctuation">;</span>									<span class="token comment"># 查询数据</span>

<span class="token comment"># 会话二</span>
<span class="token keyword">start</span> <span class="token keyword">transaction</span> <span class="token punctuation">;</span>												<span class="token comment"># 开启事务</span>
<span class="token keyword">update</span> goods_innodb <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token string">'荣耀'</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span>			   <span class="token comment"># 修改数据</span>

<span class="token comment"># 会话一</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> goods_innodb <span class="token punctuation">;</span>									<span class="token comment"># 查询数据</span>

<span class="token comment"># 会话二</span>
<span class="token keyword">commit</span><span class="token punctuation">;</span>															<span class="token comment"># 提交事务</span>

<span class="token comment"># 会话一</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> goods_innodb <span class="token punctuation">;</span>									<span class="token comment"># 查询数据</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>sql演示(测试不会出现幻读的情况)：</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token comment"># 会话一</span>
<span class="token keyword">start</span> <span class="token keyword">transaction</span> <span class="token punctuation">;</span>												<span class="token comment"># 开启事务</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> goods_innodb <span class="token punctuation">;</span>									<span class="token comment"># 查询数据</span>

<span class="token comment"># 会话二</span>
<span class="token keyword">start</span> <span class="token keyword">transaction</span> <span class="token punctuation">;</span>												<span class="token comment"># 开启事务</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> goods_innodb<span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token string">'小米'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			   	   <span class="token comment"># 插入数据</span>
<span class="token keyword">commit</span><span class="token punctuation">;</span>															<span class="token comment"># 提交事务</span>

<span class="token comment"># 会话一</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> goods_innodb <span class="token punctuation">;</span>									<span class="token comment"># 查询数据</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>sql演示(测试出现幻读的情况)：</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token comment"># 表结构进行修改</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> goods_innodb <span class="token keyword">ADD</span> version <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token boolean">NULL</span> <span class="token punctuation">;</span>

<span class="token comment"># 会话一</span>
<span class="token keyword">start</span> <span class="token keyword">transaction</span> <span class="token punctuation">;</span>												<span class="token comment"># 开启事务</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> goods_innodb <span class="token keyword">where</span> version <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>					<span class="token comment"># 查询一条不满足条件的数据</span>

<span class="token comment"># 会话二</span>
<span class="token keyword">start</span> <span class="token keyword">transaction</span> <span class="token punctuation">;</span>												<span class="token comment"># 开启事务</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> goods_innodb<span class="token punctuation">(</span>name<span class="token punctuation">,</span> version<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token string">'vivo'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	    <span class="token comment"># 插入一条满足条件的数据 </span>
<span class="token keyword">commit</span><span class="token punctuation">;</span>															<span class="token comment"># 提交事务</span>

<span class="token comment"># 会话一</span>
<span class="token keyword">update</span> goods_innodb <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token string">'金立'</span> <span class="token keyword">where</span> version <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> 		   <span class="token comment"># 将version为1的数据更改为'金立'</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> goods_innodb <span class="token keyword">where</span> version <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>					<span class="token comment"># 查询一条不满足条件的数据</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p><strong>SERIALIZABLE(可串行化)</strong>：这是最高的隔离级别,可以解决上面提到的所有问题,因为他强制将所以的操作串行执行,这会导致并发性能极速下降,因此也不是很常用。</p> <h2 id="_3-索引"><a href="#_3-索引" class="header-anchor">#</a> 3 索引</h2> <h3 id="_3-1-mysql支持的存储引擎有哪些-有什么区别"><a href="#_3-1-mysql支持的存储引擎有哪些-有什么区别" class="header-anchor">#</a> 3.1 MYSQL支持的存储引擎有哪些, 有什么区别 ?</h3> <blockquote><p>难易程度：☆☆☆</p> <p>出现频率：☆☆☆☆</p></blockquote> <ul><li>常用的存储引擎
<ul><li>MyISAM存储引擎
<ul><li>访问快,不支持事务和外键。表结构保存在.frm文件中，表数据保存在.MYD文件中，索引保存在.MYI文件中。</li></ul></li> <li>InnoDB存储引擎(MySQL5.5版本后默认的存储引擎)
<ul><li>支持事务 ,占用磁盘空间大 ,支持并发控制。表结构保存在.frm文件中，如果是共享表空间，数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path定义的表空间中，可以是多个文件。如果是多表空间存储，每个表的数据和索引单独保存在 .ibd 中。</li></ul></li> <li>MEMORY存储引擎
<ul><li>内存存储 , 速度快 ,不安全 ,适合小量快速访问的数据。表结构保存在.frm中。</li></ul></li></ul></li> <li>特性对比</li></ul> <table><thead><tr><th>特性</th> <th>MyISAM</th> <th>InnoDB</th> <th>MEMORY</th></tr></thead> <tbody><tr><td><strong>事务安全</strong></td> <td><strong>不支持</strong></td> <td><strong>支持</strong></td> <td><strong>不支持</strong></td></tr> <tr><td><strong>锁机制</strong></td> <td><strong>表锁</strong></td> <td><strong>表锁/行锁</strong></td> <td><strong>表锁</strong></td></tr> <tr><td><strong>外键</strong></td> <td><strong>不支持</strong></td> <td><strong>支持</strong></td> <td><strong>不支持</strong></td></tr></tbody></table> <h3 id="_3-2-了解过mysql的索引嘛"><a href="#_3-2-了解过mysql的索引嘛" class="header-anchor">#</a> 3.2 了解过Mysql的索引嘛 ?</h3> <blockquote><p>难易程度：☆☆</p> <p>出现频率：☆☆☆</p></blockquote> <p>索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构（B+树），这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p> <h3 id="_3-3-索引的底层数据结构了解过嘛"><a href="#_3-3-索引的底层数据结构了解过嘛" class="header-anchor">#</a> 3.3 索引的底层数据结构了解过嘛 ?</h3> <blockquote><p>难易程度：☆☆☆☆</p> <p>出现频率：☆☆☆☆☆</p></blockquote> <p>MySQL默认使用的索引底层数据结构是B+树。再聊B+树之前，我们先聊聊二叉树和B树</p> <h4 id="_2-3-1-二叉树"><a href="#_2-3-1-二叉树" class="header-anchor">#</a> 2.3.1 二叉树</h4> <p>假如说MySQL的索引结构采用二叉树的数据结构，比较理想的结构如下：</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220911183152014.png" alt="image-20220911183152014"></p> <p>如果主键是顺序插入的，则会形成一个单向链表，结构如下：</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220911183211048.png" alt="image-20220911183211048"></p> <p>所以，如果选择二叉树作为索引结构，会存在以下缺点：</p> <ul><li><p>顺序插入时，会形成一个链表，查询性能大大降低。</p></li> <li><p>大数据量情况下，层级较深，检索速度慢。</p></li></ul> <p>此时大家可能会想到，我们可以选择红黑树，红黑树是一颗自平衡二叉树，那这样即使是顺序插入数据，最终形成的数据结构也是一颗平衡的二叉树,结构如下:</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220911183128328.png" alt="image-20220911183128328"></p> <p>但是，即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点：</p> <ul><li>大数据量情况下，层级较深，检索速度慢。</li></ul> <p>所以，在MySQL的索引结构中，并没有选择二叉树或者红黑树，而选择的是B+Tree，那么什么是B+Tree呢？在详解B+Tree之前，先来介绍一个B-Tree。</p> <h4 id="_2-3-2-b-tree"><a href="#_2-3-2-b-tree" class="header-anchor">#</a> 2.3.2 B-Tree</h4> <p>B-Tree，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。</p> <p>以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5个指针：</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220120230814729.png" alt="image-20220120230814729"></p> <blockquote><p>知识小贴士: 树的度数指的是一个节点的子节点个数。</p></blockquote> <p>我们可以通过一个数据结构可视化的网站来简单演示一下。 https://www.cs.usfca.edu/~galles/visualization/BTree.html</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220120231104019.png" alt="image-20220120231104019"></p> <p>插入一组数据： 100 65 169 368 900 556 780 35 215 1200 234 888 158 90 1000 88 120 268 250 。然后观察一些数据插入过程中，节点的变化情况。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220120231135819.png" alt="image-20220120231135819"></p> <p>特点：</p> <ul><li>5阶的B树，每一个节点最多存储4个key，对应5个指针。</li> <li>一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。</li> <li>在B树中，非叶子节点和叶子节点都会存放数据。</li></ul> <h4 id="_2-2-3-b-tree"><a href="#_2-2-3-b-tree" class="header-anchor">#</a> 2.2.3 B+Tree</h4> <p>B+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例，来看一下其结构示意图：</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220120233158924-1662891127168.png" alt="image-20220120233158924"></p> <p>我们可以看到，两部分：</p> <ul><li>绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。</li> <li>红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。</li></ul> <p>我们可以通过一个数据结构可视化的网站来简单演示一下。 https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220120233447695-1662891127168.png" alt="image-20220120233447695"></p> <p>插入一组数据： 100 65 169 368 900 556 780 35 215 1200 234 888 158 90 1000 88 120 268 250 。然后观察一些数据插入过程中，节点的变化情况。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220911183055238.png" alt="image-20220911183055238"></p> <p>最终我们看到，B+Tree 与 B-Tree相比，主要有以下三点区别：</p> <ul><li>所有的数据都会出现在叶子节点。</li> <li>叶子节点形成一个单向链表。</li> <li>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</li></ul> <p>上述我们所看到的结构是标准的B+Tree的数据结构，接下来，我们再来看看MySQL中优化之后的B+Tree。</p> <p>MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220120235829054-1662891127168.png" alt="image-20220120235829054"></p> <h3 id="_3-4-什么是聚簇索引什么是非聚簇索引"><a href="#_3-4-什么是聚簇索引什么是非聚簇索引" class="header-anchor">#</a> 3.4 什么是聚簇索引什么是非聚簇索引 ?</h3> <blockquote><p>难易程度：☆☆☆</p> <p>出现频率：☆☆☆</p></blockquote> <p>而在在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</p> <table><thead><tr><th>分类</th> <th>含义</th> <th>特点</th></tr></thead> <tbody><tr><td>聚集索引(Clustered  Index)</td> <td>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td> <td>必须有,而且只有一个</td></tr> <tr><td>二级索引(Secondary  Index)</td> <td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td> <td>可以存在多个</td></tr></tbody></table> <p>聚集索引选取规则:</p> <ul><li><p>如果存在主键，主键索引就是聚集索引。</p></li> <li><p>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</p></li> <li><p>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</p></li></ul> <p>聚集索引和二级索引的具体结构如下：</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220911183033682.png" alt="image-20220911183033682"></p> <ul><li>聚集索引的叶子节点下挂的是这一行的数据 。</li> <li>二级索引的叶子节点下挂的是该字段值对应的主键值。</li></ul> <h3 id="_3-5-知道什么是回表查询嘛"><a href="#_3-5-知道什么是回表查询嘛" class="header-anchor">#</a> 3.5  知道什么是回表查询嘛 ?</h3> <blockquote><p>难易程度：☆☆☆</p> <p>出现频率：☆☆☆</p></blockquote> <p>介绍回表之前，我们先看一个例子</p> <p>比如执行了一条sql语句<code>select * from user where name = 'Arm'</code>，其中name字段已经创建了索引</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220911183010564.png" alt="image-20220911183010564"></p> <p>具体过程如下:</p> <p>①. 由于是根据name字段进行查询，所以先根据name='Arm'到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。</p> <p>②. 由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到10对应的行row。</p> <p>③. 最终拿到这一行的数据，直接返回即可。</p> <blockquote><p>回表查询： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。</p></blockquote> <h3 id="_3-6-索引创建原则有哪些"><a href="#_3-6-索引创建原则有哪些" class="header-anchor">#</a> 3.6  索引创建原则有哪些？</h3> <blockquote><p>难易程度：☆☆☆</p> <p>出现频率：☆☆☆☆</p></blockquote> <p>1). 针对于数据量较大，且查询比较频繁的表建立索引。</p> <p>2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</p> <p>3). 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p> <p>4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</p> <p>5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</p> <p>6). 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</p> <p>7). 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</p> <h3 id="_3-7-知道什么是左前缀原则嘛"><a href="#_3-7-知道什么是左前缀原则嘛" class="header-anchor">#</a> 3.7 知道什么是左前缀原则嘛 ?</h3> <blockquote><p>难易程度：☆☆</p> <p>出现频率：☆☆☆☆</p></blockquote> <p>如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。</p> <p>以 tb_user 表为例，我们先来查看一下之前 tb_user 表所创建的索引。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220121230021077.png" alt="image-20220121230021077"></p> <p>在 tb_user 表中，有一个联合索引，这个联合索引涉及到三个字段，顺序分别为：profession，age，status。</p> <p>对于最左前缀法则指的是，查询时，最左变的列，也就是profession必须存在，否则索引全部失效。 而且中间不能跳过某一列，否则该列后面的字段索引将失效</p> <h3 id="_3-8-知道什么叫覆盖索引嘛"><a href="#_3-8-知道什么叫覆盖索引嘛" class="header-anchor">#</a> 3.8 知道什么叫覆盖索引嘛 ?</h3> <blockquote><p>难易程度：☆☆</p> <p>出现频率：☆☆☆</p></blockquote> <p>覆盖索引是指 查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。</p> <p>例：</p> <p>执行SQL : <code>select * from tb_user where id = 2</code>;</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220911182940268.png" alt="image-20220911182940268"></p> <p>根据id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。</p> <h3 id="_3-9-索引是越多越好嘛-什么样的字段需要建索引-什么样的字段不需要"><a href="#_3-9-索引是越多越好嘛-什么样的字段需要建索引-什么样的字段不需要" class="header-anchor">#</a> 3.9 索引是越多越好嘛? 什么样的字段需要建索引, 什么样的字段不需要 ?</h3> <blockquote><p>难易程度：☆☆☆</p> <p>出现频率：☆☆☆☆</p></blockquote> <p>索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</p> <ul><li><p>针对于数据量较大，且查询比较频繁的表建立索引。</p> <p>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</p></li> <li><p>不适合常见索引的字段</p> <ul><li>更新频繁字段不适合创建索引</li> <li>若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</li> <li>对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。
<ul><li>比如省会，城市、月份</li></ul></li> <li>对于定义为text、image和bit的数据类型的列不要建立索引。</li></ul></li></ul> <h2 id="_4-调优"><a href="#_4-调优" class="header-anchor">#</a> 4 调优</h2> <h3 id="_4-1-如何定位慢查询"><a href="#_4-1-如何定位慢查询" class="header-anchor">#</a> 4.1 如何定位慢查询 ?</h3> <blockquote><p>难易程度：☆☆☆</p> <p>出现频率：☆☆☆☆☆</p></blockquote> <p>可以开启mysql的慢查询日志</p> <p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。</p> <p>如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：</p> <div class="language-properties line-numbers-mode"><pre class="language-properties"><code><span class="token comment"># 开启MySQL慢日志查询开关</span>
<span class="token key attr-name">slow_query_log</span><span class="token punctuation">=</span><span class="token value attr-value">1</span>
<span class="token comment"># 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span>
<span class="token key attr-name">long_query_time</span><span class="token punctuation">=</span><span class="token value attr-value">2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息 /var/lib/mysql/localhost-slow.log。</p> <p>如果这个时候有一条sql执行的时间超过2秒，则会记录到慢日志文件中</p> <h3 id="_4-2-一个sql语句执行很慢-如何分析"><a href="#_4-2-一个sql语句执行很慢-如何分析" class="header-anchor">#</a> 4.2 一个SQL语句执行很慢, 如何分析 ?</h3> <blockquote><p>难易程度：☆☆☆☆</p> <p>出现频率：☆☆☆☆☆</p></blockquote> <p>可以采用EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p> <p>语法:</p> <div class="language-SQL line-numbers-mode"><pre class="language-sql"><code><span class="token comment">-- 直接在select语句之前加上关键字 explain / desc</span>
<span class="token keyword">EXPLAIN</span>   <span class="token keyword">SELECT</span>   字段列表   <span class="token keyword">FROM</span>   表名   <span class="token keyword">WHERE</span>  条件 <span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220121151322661.png" alt="image-20220121151322661"></p> <p>Explain 执行计划中各个字段的含义:</p> <table><thead><tr><th>字段</th> <th>含义</th></tr></thead> <tbody><tr><td>id</td> <td>select查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下；id不同，值越大，越先执行)。</td></tr> <tr><td>select_type</td> <td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、<br>UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等</td></tr> <tr><td>type</td> <td>表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、 index、all 。</td></tr> <tr><td>possible_key</td> <td>显示可能应用在这张表上的索引，一个或多个。</td></tr> <tr><td>key</td> <td>实际使用的索引，如果为NULL，则没有使用索引。</td></tr> <tr><td>key_len</td> <td>表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。</td></tr> <tr><td>rows</td> <td>MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。</td></tr> <tr><td>filtered</td> <td>表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。</td></tr> <tr><td>Extra</td> <td>额外的建议</td></tr></tbody></table> <p>主要可以根据以下字段，判断sql是否需要优化，特别是是否能命中索引或命中索引的情况</p> <ul><li>type 通过sql的连接的类型进行优化</li> <li>possible_key  通过它查看是否可能会命中索引</li> <li>key 当前sql实际命中的索引</li> <li>key_len 索引占用的大小</li> <li>Extra 额外的优化建议</li></ul> <h3 id="_4-3-什么情况下索引会失效"><a href="#_4-3-什么情况下索引会失效" class="header-anchor">#</a> 4.3 什么情况下索引会失效 ?</h3> <blockquote><p>难易程度：☆☆☆</p> <p>出现频率：☆☆☆☆☆</p></blockquote> <p>1). 最左前缀法则
如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。
匹配最左前缀法则，走索引：</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220402015342903.png" alt="image-20220402015342903"></p> <p>违法最左前缀法则 ， 索引失效：</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220402015405424.png" alt="image-20220402015405424"></p> <p>如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效：</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220402015425744.png" alt="image-20220402015425744"></p> <p>2). 范围查询右边的列，不能使用索引 。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220402015442589.png" alt="image-20220402015442589"></p> <p>根据前面的两个字段 name ， status 查询是走索引的， 但是最后一个条件address 没有用到索引。</p> <p>3). 不要在索引列上进行运算操作， 索引将失效。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220402015507834.png" alt="image-20220402015507834"></p> <p>4). 字符串不加单引号，造成索引失效。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220402015524822.png" alt="image-20220402015524822"></p> <p>由于，在查询是，没有对字符串加单引号， MySQL的查询优化器，会自动的进行类型转换，造成索引失效。</p> <p>5). 尽量使用覆盖索引，避免select *
尽量使用覆盖索引（只访问索引的查询（索引列完全包含查询列）），减少select * 。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220402015553678.png" alt="image-20220402015553678"></p> <p>如果查询列，超出索引列，也会降低性能。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220402015610221.png" alt="image-20220402015610221"></p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code>TIP :
 <span class="token keyword">using</span> <span class="token keyword">index</span> ：使用覆盖索引的时候就会出现
 <span class="token keyword">using</span> <span class="token keyword">where</span>：在查找使用索引的情况下，需要回表去查询所需的数据
 <span class="token keyword">using</span> <span class="token keyword">index</span> condition：查找使用了索引，但是需要回表查询数据
 <span class="token keyword">using</span> <span class="token keyword">index</span> <span class="token punctuation">;</span> <span class="token keyword">using</span> <span class="token keyword">where</span>：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表
查询数据
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>6). 用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。
示例，name字段是索引列 ， 而createtime不是索引列，中间是or进行连接是不走索引的 ：</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">explain</span>  <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_seller <span class="token keyword">where</span> name<span class="token operator">=</span><span class="token string">'黑马程序员'</span> <span class="token operator">or</span> createtime <span class="token operator">=</span> <span class="token string">'2088-01-01 12:00:00'</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220402015711415.png" alt="image-20220402015711415"></p> <p>7). 以%开头的Like模糊查询，索引失效。
如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220402015729911.png" alt="image-20220402015729911"></p> <p>解决方案 ：
通过覆盖索引来解决</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220402015748294.png" alt="image-20220402015748294"></p> <p>8). 如果MySQL评估使用索引比全表更慢，则不使用索引。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220402015838310.png" alt="image-20220402015838310"></p> <p>9). is NULL ， is NOT NULL 有时索引失效。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220402015859587.png" alt="image-20220402015859587"></p> <p>10). in 走索引， not in 索引失效。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220402015915816.png" alt="image-20220402015915816"></p> <h3 id="_4-4-mysql超大分页怎么处理"><a href="#_4-4-mysql超大分页怎么处理" class="header-anchor">#</a> 4.4 MYSQL超大分页怎么处理 ?</h3> <blockquote><p>难易程度：☆☆☆☆</p> <p>出现频率：☆☆☆</p></blockquote> <p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。</p> <p>我们一起来看看执行limit分页查询耗时对比：</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220123132838745.png" alt="image-20220123132838745"></p> <p>通过测试我们会看到，越往后，分页查询效率越低，这就是分页查询的问题所在。</p> <p>因为，当在进行分页查询时，如果执行 limit 2000000,10 ，此时需要MySQL排序前2000010 记录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。</p> <p>优化思路: 一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">explain</span>   <span class="token keyword">select</span>  <span class="token operator">*</span>  <span class="token keyword">from</span>  tb_sku  t  <span class="token punctuation">,</span>  <span class="token punctuation">(</span><span class="token keyword">select</span>  id  <span class="token keyword">from</span>  tb_sku  <span class="token keyword">order</span>  <span class="token keyword">by</span>  id  <span class="token keyword">limit</span>  <span class="token number">2000000</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span>  a  <span class="token keyword">where</span> t<span class="token punctuation">.</span>id  <span class="token operator">=</span>  a<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="_4-5-谈谈你对sql的优化的经验"><a href="#_4-5-谈谈你对sql的优化的经验" class="header-anchor">#</a> 4.5 谈谈你对sql的优化的经验</h3> <blockquote><p>难易程度：☆☆☆☆</p> <p>出现频率：☆☆☆☆☆</p></blockquote> <h4 id="_4-5-1-表的设计优化"><a href="#_4-5-1-表的设计优化" class="header-anchor">#</a> 4.5.1 表的设计优化</h4> <p>①选择表合适存储引擎：</p> <ul><li>myisam: 应用时以读和插入操作为主，只有少量的更新和删除，并且对事务的完整性，并发性要求不是很高的。</li> <li>Innodb： 事务处理，以及并发条件下要求数据的一致性。除了插入和查询外，包括很多的更新和删除。尽量 设计 所有字段都得有默认值,尽量避免null。</li></ul> <p>②选择合适的数据类型</p> <p>数据库表设计时候更小的占磁盘空间尽可能使用更小的整数类型，一般来说，数据库中的表越小，在它上面执行的查询也就会越快。</p> <p>比如设置合适的数值（tinyint   int   bigint），要根据实际情况选择</p> <p>比如设置合适的字符串类型（char和varchar）char定长效率高，varchar可变长度，效率稍低</p> <h4 id="_4-5-2-索引优化"><a href="#_4-5-2-索引优化" class="header-anchor">#</a> 4.5.2 索引优化</h4> <ul><li>表的主键、外键必须有索引；</li> <li>数据量大的表应该有索引；</li> <li>经常与其他表进行连接的表，在连接字段上应该建立索引；</li> <li>经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；</li> <li>索引应该建在选择性高的字段上； （sex 性别这种就不适合）</li> <li>索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；</li> <li>频繁进行数据操作的表，不要建立太多的索引；</li> <li>删除无用的索引，避免对执行计划造成负面影响；</li></ul> <h4 id="_4-5-3-sql语句优化"><a href="#_4-5-3-sql语句优化" class="header-anchor">#</a> 4.5.3 sql语句优化</h4> <ul><li>SELECT语句务必指明字段名称（避免直接使用select * ）</li> <li>SQL语句要避免造成索引失效的写法</li> <li>SQL语句中IN包含的值不应过多</li> <li>当只需要一条数据的时候，使用limit 1</li> <li>如果排序字段没有用到索引，就尽量少排序</li> <li>如果限制条件中其他字段没有索引，尽量少用or</li> <li>尽量用union all代替union</li> <li>避免在where子句中对字段进行null值判断</li> <li>不建议使用%前缀模糊查询</li> <li>避免在where子句中对字段进行表达式操作</li> <li>Join优化 能用innerjoin 就不用left join right join，如必须使用 一定要已小表为驱动</li></ul> <h4 id="_4-5-4-主从复制、读写分离"><a href="#_4-5-4-主从复制、读写分离" class="header-anchor">#</a> 4.5.4 主从复制、读写分离</h4> <p>如果数据库的使用场景读的操作比较的时候，为了避免写的操作所造成的性能影响 可以采用读写分离的架构，读写分离，解决的是，数据库的写入，影响了查询的效率。读写分离的基本原理是让主数据库处理事务性增、改、删操作（INSERT、UPDATE、DELETE），而从数据库处理SELECT查询操作。 数据库复制被用来把事务性操作导致的变更同步到集群中的从数据库。</p> <h4 id="_4-5-5-mysql的分库分表"><a href="#_4-5-5-mysql的分库分表" class="header-anchor">#</a> 4.5.5 mysql的分库分表</h4> <p>见下文</p> <h2 id="_5-分库分表"><a href="#_5-分库分表" class="header-anchor">#</a> 5 分库分表</h2> <h3 id="_5-1主从同步原理"><a href="#_5-1主从同步原理" class="header-anchor">#</a> 5.1主从同步原理</h3> <blockquote><p>难易程度：☆☆☆</p> <p>出现频率：☆☆☆</p></blockquote> <p>MySQL主从复制的核心就是二进制日志，</p> <blockquote><p>二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但不包括数据查询（SELECT、SHOW）语句。</p></blockquote> <p>具体的主从同步过程如下：</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220911213148696.png" alt="image-20220911213148696"></p> <p>从上图来看，复制分成三步：</p> <ol><li>Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</li> <li>从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</li> <li>slave重做中继日志中的事件，将改变反映它自己的数据。</li></ol> <h3 id="_5-2-读写分离的时候主从同步延时怎么解决"><a href="#_5-2-读写分离的时候主从同步延时怎么解决" class="header-anchor">#</a> 5.2 读写分离的时候主从同步延时怎么解决？</h3> <blockquote><p>难易程度：☆☆☆☆</p> <p>出现频率：☆☆☆</p></blockquote> <h4 id="_5-2-1-为什么会延时"><a href="#_5-2-1-为什么会延时" class="header-anchor">#</a> 5.2.1 为什么会延时</h4> <p><strong>随机重放</strong></p> <p>MySQL的主从复制都是单线程的操作，主库对所有DDL和DML产生的日志写进binlog，由于binlog是顺序写，所以效率很高。Slave的SQL Thread线程将主库的DDL和DML操作事件在slave中重放。DML和DDL的IO操作是随机的，不是顺序的，成本高很多。所以SQL Thread线程的速度赶不上主库写binlog的速度，就会产生主从延迟</p> <p><strong>锁等待</strong></p> <p>另一方面，由于SQL Thread也是单线程的，当主库的并发较高时，产生的DML数量超过slave的SQL Thread所能处理的速度，或者当slave中有大型query语句产生了锁等待那么延时就产生了。</p> <h4 id="_5-2-2-解决方案"><a href="#_5-2-2-解决方案" class="header-anchor">#</a> 5.2.2 解决方案</h4> <p><strong>强制读主库</strong>
如果你做的是类似支付这种对实时性要求非常高的业务，那么最直接的方法就是直接读主库，当然这种方法相当于从库做一个备份的功能了。</p> <p><strong>延迟读</strong>
就是在写入之后，等一段时间再读，Eg：写入后同步的时间是0.5s，读取的时候可以设置1s后再读，但是这个方案主要存在的问题就是，不知道主从同步完成所需要的时间。</p> <p><strong>降低并发</strong>
如果你理解了随机重放这个导致主从延迟的原因，那么就比较好理解了，控制主库写入的速度，主从延迟发生的概率自然就小了。{原因：因为主库中sql可能并发执行，可以控制并发速度}。</p> <p><strong>并行复制(推荐)</strong>
MySQL 5.6 版本后，提供了一种并行复制的方式，通过将 SQL 线程转换为多个 work 线程来进行重放，这样就解决了主从延迟的问题。</p> <h3 id="_5-3-mysql为什么要分库分表-分库分表的策略有哪些"><a href="#_5-3-mysql为什么要分库分表-分库分表的策略有哪些" class="header-anchor">#</a> 5.3 Mysql为什么要分库分表？分库分表的策略有哪些？</h3> <blockquote><p>难易程度：☆☆☆☆</p> <p>出现频率：☆☆☆</p></blockquote> <h4 id="_5-3-1-为什么要分库分表"><a href="#_5-3-1-为什么要分库分表" class="header-anchor">#</a> 5.3.1 为什么要分库分表</h4> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220911220816527.png" alt="image-20220911220816527"></p> <p>随着互联网及移动互联网的发展，应用系统的数据量也是成指数式增长，若采用单数据库进行数据存储，存在以下性能瓶颈：</p> <ol><li><p>IO瓶颈：热点数据太多，数据库缓存不足，产生大量磁盘IO，效率较低。 请求数据太多，带宽不够，网络IO瓶颈。</p></li> <li><p>CPU瓶颈：排序、分组、连接查询、聚合统计等SQL会耗费大量的CPU资源，请求数太多，CPU出现瓶颈。</p></li></ol> <p>为了解决上述问题，我们需要对数据库进行分库分表处理。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220911220759014.png" alt="image-20220911220759014"></p> <p>分库分表的中心思想都是将数据分散存储，使得单一数据库/表的数据量变小来缓解单一数据库的性能问题，从而达到提升数据库性能的目的。</p> <h4 id="_5-3-2-拆分策略"><a href="#_5-3-2-拆分策略" class="header-anchor">#</a> 5.3.2 拆分策略</h4> <p>分库分表的形式，主要是两种：垂直拆分和水平拆分。而拆分的粒度，一般又分为分库和分表，所以组成的拆分策略最终如下：</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220911220948216.png" alt="image-20220911220948216"></p> <h4 id="_5-3-3-垂直拆分"><a href="#_5-3-3-垂直拆分" class="header-anchor">#</a> 5.3.3 垂直拆分</h4> <ol><li>垂直分库</li></ol> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220911221003953.png" alt="image-20220911221003953"></p> <p>垂直分库：以表为依据，根据业务将不同表拆分到不同库中。</p> <p>特点：</p> <ul><li><p>每个库的表结构都不一样。</p></li> <li><p>每个库的数据也不一样。</p></li> <li><p>所有库的并集是全量数据。</p></li></ul> <ol start="2"><li>垂直分表</li></ol> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220911221024489.png" alt="image-20220911221024489"></p> <p>垂直分表：以字段为依据，根据字段属性将不同字段拆分到不同表中。</p> <p>特点：</p> <ul><li><p>每个表的结构都不一样。</p></li> <li><p>每个表的数据也不一样，一般通过一列（主键/外键）关联。</p></li> <li><p>所有表的并集是全量数据。</p></li></ul> <h4 id="_5-3-4-水平拆分"><a href="#_5-3-4-水平拆分" class="header-anchor">#</a> 5.3.4  水平拆分</h4> <ol><li>水平分库</li></ol> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220911221042512.png" alt="image-20220911221042512"></p> <p>水平分库：以字段为依据，按照一定策略，将一个库的数据拆分到多个库中。</p> <p>特点：</p> <ul><li><p>每个库的表结构都一样。</p></li> <li><p>每个库的数据都不一样。</p></li> <li><p>所有库的并集是全量数据。</p></li></ul> <ol start="2"><li>水平分表</li></ol> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220911221100744.png" alt="image-20220911221100744"></p> <p>水平分表：以字段为依据，按照一定策略，将一个表的数据拆分到多个表中。</p> <p>特点：</p> <ul><li><p>每个表的表结构都一样。</p></li> <li><p>每个表的数据都不一样。</p></li> <li><p>所有表的并集是全量数据。</p></li></ul> <blockquote><p>在业务系统中，为了缓解磁盘IO及CPU的性能瓶颈，到底是垂直拆分，还是水平拆分；具体是分库，还是分表，都需要根据具体的业务需求具体分析。</p></blockquote> <h4 id="_5-3-5-实现技术"><a href="#_5-3-5-实现技术" class="header-anchor">#</a> 5.3.5 实现技术</h4> <ul><li><p>shardingJDBC：基于AOP原理，在应用程序中对本地执行的SQL进行拦截，解析、改写、路由处理。需要自行编码配置实现，只支持java语言，性能较高。</p></li> <li><p>MyCat：数据库分库分表中间件，不用调整代码即可实现分库分表，支持多种语言，性能不及前者。</p></li></ul> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220911221413349.png" alt="image-20220911221413349"></p> <h3 id="_5-4-分库分表后id主键如何处理"><a href="#_5-4-分库分表后id主键如何处理" class="header-anchor">#</a> 5.4 分库分表后id主键如何处理？</h3> <blockquote><p>难易程度：☆☆☆</p> <p>出现频率：☆☆</p></blockquote> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220911221100744.png" alt="image-20220911221100744"></p> <ul><li><p><strong>主键自增</strong>：数据库中间件可以设置主键的自增</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220911221829775.png" alt="image-20220911221829775"></p></li> <li><p><strong>UUID</strong></p> <p>好处就是本地生成，不要基于数据库来了；不好之处就是，UUID 太长了、占用空间大，<strong>作为主键性能太差</strong> 了；更重要的是，UUID 不具有有序性，会导致 B+ 树索引在写的时候有过多的随机写操作，不能产生有顺序的 append 操作，而需要进行 insert操作，将会读取整个 B+ 树节点到内存，在插入这条记录后会将整个节点写回磁盘，这种操作在记录占用空间比较 大的情况下，性能下降明显</p></li> <li><p><strong>snowflake</strong> <strong>算法</strong></p></li></ul> <h2 id="_6-mysql锁相关"><a href="#_6-mysql锁相关" class="header-anchor">#</a> 6.MySQL锁相关</h2> <h3 id="_6-1-mysql中有哪几种锁"><a href="#_6-1-mysql中有哪几种锁" class="header-anchor">#</a> 6.1 Mysql中有哪几种锁？</h3> <p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p> <ul><li><p>全局锁：锁定数据库中的所有表。</p></li> <li><p>表级锁：每次操作锁住整张表。</p></li> <li><p>行级锁：每次操作锁住对应的行数据。</p></li></ul> <h3 id="_6-3-表级锁和行级锁了解吗-有什么区别"><a href="#_6-3-表级锁和行级锁了解吗-有什么区别" class="header-anchor">#</a> 6.3 表级锁和行级锁了解吗？有什么区别？</h3> <p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。</p> <p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。</p> <h3 id="_6-4-意向锁有什么作用"><a href="#_6-4-意向锁有什么作用" class="header-anchor">#</a> 6.4 意向锁有什么作用？</h3> <p>1). 介绍</p> <p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p> <p>假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢，来通过示意图简单分析一下：</p> <p>首先客户端一，开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220918204320511.png" alt="image-20220918204320511"></p> <p>当客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，如果没有，则添加表锁，此时就会从第一行数据，检查到最后一行数据，效率较低。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220918204337685.png" alt="image-20220918204337685"></p> <p>有了意向锁之后 :</p> <p>客户端一，在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220918204355492.png" alt="image-20220918204355492"></p> <p>而其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220918204413960.png" alt="image-20220918204413960"></p> <h3 id="_6-5-共享锁和排他锁呢"><a href="#_6-5-共享锁和排他锁呢" class="header-anchor">#</a> 6.5 共享锁和排他锁呢？</h3> <p>InnoDB实现了以下两种类型的行锁：</p> <ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li> <li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</li></ul> <p>常见的SQL语句，在执行时，所加的行锁如下：</p> <table><thead><tr><th>SQL</th> <th>行锁类型</th> <th>说明</th></tr></thead> <tbody><tr><td>INSERT ...</td> <td>排他锁</td> <td>自动加锁</td></tr> <tr><td>UPDATE ...</td> <td>排他锁</td> <td>自动加锁</td></tr> <tr><td>DELETE ...</td> <td>排他锁</td> <td>自动加锁</td></tr> <tr><td>SELECT（正常）</td> <td>不加任何锁</td> <td></td></tr> <tr><td>SELECT ...  LOCK IN SHARE   MODE</td> <td>共享锁</td> <td>需要手动在SELECT之后加LOCK IN   SHARE MODE</td></tr> <tr><td>SELECT ...  FOR UPDATE</td> <td>排他锁</td> <td>需要手动在SELECT之后加FOR UPDATE</td></tr></tbody></table> <h3 id="_6-6-解释一下mvcc"><a href="#_6-6-解释一下mvcc" class="header-anchor">#</a> 6.6 解释一下MVCC</h3> <p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p> <h4 id="_6-6-1-隐藏字段"><a href="#_6-6-1-隐藏字段" class="header-anchor">#</a> 6.6.1 隐藏字段</h4> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220125155559099.png" alt="image-20220125155559099"></p> <p>当我们创建了上面的这张表，我们在查看表结构的时候，就可以显式的看到这三个字段。 实际上除了这三个字段以外，InnoDB还会自动的给我们添加三个隐藏字段及其含义分别是：</p> <table><thead><tr><th>隐藏字段</th> <th>含义</th></tr></thead> <tbody><tr><td>DB_TRX_ID</td> <td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。</td></tr> <tr><td>DB_ROLL_PTR</td> <td>回滚指针，指向这条记录的上一个版本，用于配合undo  log，指向上一个版本。</td></tr> <tr><td>DB_ROW_ID</td> <td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。</td></tr></tbody></table> <p>而上述的前两个字段是肯定会添加的， 是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键，如果有主键，则不会添加该隐藏字段。</p> <h4 id="_6-6-2-undolog"><a href="#_6-6-2-undolog" class="header-anchor">#</a> 6.6.2 undolog</h4> <p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</p> <p>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</p> <p>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</p> <h4 id="_6-6-3-版本链"><a href="#_6-6-3-版本链" class="header-anchor">#</a> 6.6.3 版本链</h4> <p>有一张表原始数据为：</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220125162711914.png" alt="image-20220125162711914"></p> <blockquote><p>DB_TRX_ID : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是自增的。</p> <p>DB_ROLL_PTR ： 由于这条数据是才插入的，没有被更新过，所以该字段值为null。</p></blockquote> <p>然后，有四个并发事务同时在访问这张表。</p> <p>A. 第一步</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220125162202010.png" alt="image-20220125162202010"></p> <p>当事务2执行第一条修改语句时，会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220918214543062.png" alt="image-20220918214543062"></p> <p>B.第二步</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220918214529046.png" alt="image-20220918214529046"></p> <p>当事务3执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220918214513175.png" alt="image-20220918214513175"></p> <p>C. 第三步</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220125163929573.png" alt="image-20220125163929573"></p> <p>当事务4执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220918214457963.png" alt="image-20220918214457963"></p> <blockquote><p>最终我们发现，不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p></blockquote> <h4 id="_6-6-4-readview"><a href="#_6-6-4-readview" class="header-anchor">#</a> 6.6.4 readview</h4> <p>ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。</p> <p>ReadView中包含了四个核心字段：</p> <table><thead><tr><th>字段</th> <th>含义</th></tr></thead> <tbody><tr><td>m_ids</td> <td>当前活跃的事务ID集合</td></tr> <tr><td>min_trx_id</td> <td>最小活跃事务ID</td></tr> <tr><td>max_trx_id</td> <td>预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）</td></tr> <tr><td>creator_trx_id</td> <td>ReadView创建者的事务ID</td></tr></tbody></table> <p>而在readview中就规定了版本链数据的访问规则：</p> <p>trx_id 代表当前undolog版本链对应事务ID。</p> <table><thead><tr><th>条件</th> <th>是否可以访问</th> <th>说明</th></tr></thead> <tbody><tr><td>trx_id == creator_trx_id</td> <td>可以访问该版本</td> <td>成立，说明数据是当前这个事务更改的。</td></tr> <tr><td>trx_id &lt; min_trx_id</td> <td>可以访问该版本</td> <td>成立，说明数据已经提交了。</td></tr> <tr><td>trx_id &gt; max_trx_id</td> <td>不可以访问该版本</td> <td>成立，说明该事务是在ReadView生成后才开启。</td></tr> <tr><td>min_trx_id &lt;= trx_id &lt;= max_trx_id</td> <td>如果trx_id不在m_ids中，是可以访问该版本的</td> <td>成立，说明数据已经提交。</td></tr></tbody></table> <p>不同的隔离级别，生成ReadView的时机不同：</p> <ul><li><p>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。</p></li> <li><p>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</p></li></ul> <h4 id="_6-6-5-原理分析"><a href="#_6-6-5-原理分析" class="header-anchor">#</a> 6.6.5 原理分析</h4> <h5 id="_6-6-5-1-rc隔离级别"><a href="#_6-6-5-1-rc隔离级别" class="header-anchor">#</a> 6.6.5.1 RC隔离级别</h5> <p>RC隔离级别下，在事务中每一次执行快照读时生成ReadView。</p> <p>我们就来分析事务5中，两次快照读读取数据，是如何获取数据的?</p> <p>在事务5中，查询了两次id为30的记录，由于隔离级别为Read Committed，所以每一次进行快照读都会生成一个ReadView，那么两次生成的ReadView如下。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220125225124616.png" alt="image-20220125225124616"></p> <p>那么这两次快照读在获取数据时，就需要根据所生成的ReadView以及ReadView的版本链访问规则，到undolog版本链中匹配数据，最终决定此次快照读返回的数据。</p> <p>A. 先来看第一次快照读具体的读取过程：</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220125225104133.png" alt="image-20220125225104133"></p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220125221055898.png" alt="image-20220125221055898"></p> <p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p> <ul><li><p>先匹配<img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220125221318271.png" alt="image-20220125221318271"> 这条记录，这条记录对应的trx_id为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ，都不满足，则继续匹配undo log版本链的下一条。</p></li> <li><p>再匹配第二条 <img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220125221613700.png" alt="image-20220125221613700"> ，这条记录对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②不满足 ③不满足 ④也不满足 ，都不满足，则继续匹配undo log版本链的下一条。</p></li> <li><p>再匹配第三条 <img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220125222501959.png" alt="image-20220125222501959"> ，这条记录对应的trx_id为2，也就是将2带入右侧的匹配规则中。①不满足 ②满足 终止匹配，此次快照读，返回的数据就是版本链中记录的这条数据。</p></li></ul> <p>B. 再来看第二次快照读具体的读取过程:</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220125225338333.png" alt="image-20220125225338333"></p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220125225403552.png" alt="image-20220125225403552"></p> <p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p> <ul><li>先匹配<img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220125221318271.png" alt="image-20220125221318271"> 这条记录，这条记录对应的trx_id为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ，都不满足，则继续匹配undo log版本链的下一条。</li> <li>再匹配第二条 <img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220125221613700.png" alt="image-20220125221613700"> ，这条记录对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②满足 。终止匹配，此次快照读，返回的数据就是版本链中记录的这条数据。</li></ul> <h5 id="_6-6-5-2-rr隔离级别"><a href="#_6-6-5-2-rr隔离级别" class="header-anchor">#</a> 6.6.5.2 RR隔离级别</h5> <p>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 而RR 是可重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。</p> <p>那MySQL是如何做到可重复读的呢? 我们简单分析一下就知道了</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220125225724902.png" alt="image-20220125225724902"></p> <p>我们看到，在RR隔离级别下，只是在事务中第一次快照读时生成ReadView，后续都是复用该ReadView，那么既然ReadView都一样， ReadView的版本链匹配规则也一样， 那么最终快照读返回的结果也是一样的。</p> <p>所以呢，MVCC的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。 而MVCC + 锁，则实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220125230214424.png" alt="image-20220125230214424"></p> <h2 id="_7-面试现场"><a href="#_7-面试现场" class="header-anchor">#</a> 7 面试现场</h2> <h3 id="_7-1-sql规范"><a href="#_7-1-sql规范" class="header-anchor">#</a> 7.1 SQL规范</h3> <blockquote><p><strong>面试官</strong>：Mysql查询语句的执行顺序？</p> <p><strong>候选人</strong>：</p> <p>嗯~~</p> <p>我们一般编写sql的顺序是</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">select</span>           字段列表
<span class="token keyword">from</span>             表名列表
<span class="token keyword">join</span> <span class="token keyword">on</span>          表关联
<span class="token keyword">where</span>            条件列表
<span class="token keyword">group</span> <span class="token keyword">by</span>         分组字段列表
<span class="token keyword">having</span>           分组后的条件列表
<span class="token keyword">order</span> <span class="token keyword">by</span>         排序字段列表
<span class="token keyword">limit</span>            分页参数
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>其实sql的执行顺序是：</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">from</span>             表名列表
<span class="token keyword">join</span> <span class="token keyword">on</span>          表关联
<span class="token keyword">where</span>            条件列表
<span class="token keyword">group</span> <span class="token keyword">by</span>         分组字段列表
<span class="token keyword">having</span>           分组后的条件列表
<span class="token keyword">select</span>           字段列表
<span class="token keyword">order</span> <span class="token keyword">by</span>         排序字段列表
<span class="token keyword">limit</span>            分页参数
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>面试官</strong>：Mysql 如何实现多表查询？</p> <p><strong>候选人</strong>：</p> <p>嗯，这个也分了好多种，分为内连接和外连接，还能自连接和子查询，这些都是多表查询</p> <ul><li><p>内连接又有两种</p></li> <li><p>隐式：<code>select ...from 表A,表B where 条件...</code></p></li> <li><p>显式：<code>select ... from 表A inner join 表B on 条件...</code></p></li> <li><p>外连接也是两种</p></li> <li><p>左外连接：<code>select ...from 表A left join 表B on 条件...</code></p></li> <li><p>右外连接：<code>select ...from 表A right join 表B on 条件...</code></p></li> <li><p>自连接，比如<code>select ...from 表A 别名1,表A 别名2 where 条件...</code></p></li> <li><p>子查询又包含了列子查询、行子查询、表子查询</p></li></ul> <p><strong>面试官</strong>：MYSQL内连接和外连接的区别 ?</p> <p><strong>候选人</strong>：</p> <p>嗯~~是这样</p> <p>内连接会取出连接表中匹配到的数据，匹配不到的不保留；</p> <p>而外连接会取出连接表中匹配到的数据，匹配不到的也会保留，其值为NULL。</p> <ul><li>左外连接，以左边的表为主表</li> <li>右外连接，以右边的表为主表</li></ul> <p>以某一个表为主表后，进行关联查询，不管能不能关联的上，主表的数据都会保留，关联不上的以NULL显示</p> <p><strong>面试官</strong>：CHAR和VARCHAR的区别？</p> <p><strong>候选人</strong>：</p> <p>嗯~~是这样的</p> <p>区别主要有几个</p> <p>第一，char最大长度是255字符，varchar最大长度是65535个字节。</p> <p>第二，char是定长的，不足的部分用隐藏空格填充，varchar是不定长的。</p> <p>第三，char会浪费空间，varchar会更加节省空间。</p> <p>第四，查找效率：char查找效率会很高，varchar查找效率会更低。</p> <p>​	   varchar需要计算内容占用的长度，而char不会，所以char的效率稍高一些</p> <p>在项目中的使用，这两种方式都会用到，比如像一些枚举值可以选择使用char，像一些描述信息或名字类可以选择使用varchar</p></blockquote> <h3 id="_7-2-事务"><a href="#_7-2-事务" class="header-anchor">#</a> 7.2 事务</h3> <blockquote><p><strong>面试官</strong>：什么是事务？</p> <p><strong>候选人</strong>：</p> <p>简单说就是由多个操作组成的一个逻辑单元，组成这个逻辑单元的多个操作要么都成功，要么都失败。</p> <p><strong>面试官</strong>：ACID是什么？可以详细说一下吗？</p> <p><strong>候选人</strong>：</p> <p>嗯~好的</p> <p>A的意思是Atomicity原子性：就是上面说的,要么全部成功,要么全部失败，不可能只执行一部分操作。</p> <p>C的意思是Consistency一致性：系统(数据库)总是从一个一致性的状态转移到另一个一致性的状态,不会存在中间状态。</p> <p>I的意思是Isolation隔离性: <strong>通常</strong>来说:一个事务在完全提交之前,对其他事务是不可见的.注意前面的通常来说加了红色,意味着有例外情况。</p> <p>D的意思是Durability持久性：一旦事务提交,那么就永远是这样子了,哪怕系统崩溃也不会影响到这个事务的结果。</p> <p>举例：转账</p> <p>A向B转账500，转账成功，A扣除500元，B增加500元，原子操作体现在要么都成功，要么都失败</p> <p>在转账的过程中，数据要一致，A扣除了500，B必须增加500</p> <p>在转账的过程中，隔离性体现在A像B转账，不能受其他事务干扰</p> <p>在转账的过程中，持久性体现在事务提交后，要把数据持久化（可以说是落盘操作）</p> <p><strong>面试官</strong>：并发事务带来哪些问题？</p> <p><strong>候选人</strong>：</p> <p>我们在项目开发中，多个事务并发进行是经常发生的，并发也是必然的，有可能导致一些问题</p> <p>第一是脏读（Dirty read）， 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</p> <p>第二是丢失修改（Lost to modify）：指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</p> <p>第三是不可重复读（Unrepeatableread）：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p> <p>第四是幻读（Phantom read）：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p> <p><strong>面试官</strong>：怎么解决这些问题呢？MySQL的默认隔离级别是？</p> <p><strong>候选人</strong>：</p> <p>解决方案是对事务进行隔离</p> <p>MySQL支持四种隔离级别:</p> <p><strong>未提交读(READ UNCOMMITTED)</strong>：这个隔离级别下,其他事务可以看到本事务没有提交的部分修改。因此会造成脏读的问题(读取到了其他事务未提交的部分,而之后该事务进行了回滚)。这个级别的性能没有足够大的优势,但是又有很多的问题,因此很少使用.</p> <p><strong>已提交读(READ COMMITTED)</strong>：其他事务只能读取到本事务已经提交的部分。这个隔离级别有不可重复读的问题，在同一个事务内的两次读取,拿到的结果竟然不一样,因为另外一个事务对数据进行了修改。</p> <p><strong>REPEATABLE READ(可重复读)</strong>：可重复读隔离级别解决了上面不可重复读的问题(看名字也知道)，但是不能完全解决幻读。MySql默认的事务隔离级别就是：<strong>REPEATABLE READ</strong></p> <p><strong>SERIALIZABLE(可串行化)</strong>：这是最高的隔离级别,可以解决上面提到的所有问题,因为他强制将所以的操作串行执行,这会导致并发性能极速下降,因此也不是很常用。</p></blockquote> <h3 id="_7-3-索引"><a href="#_7-3-索引" class="header-anchor">#</a> 7.3 索引</h3> <blockquote><p><strong>面试官</strong>：MYSQL支持的存储引擎有哪些, 有什么区别 ?</p> <p><strong>候选人</strong>：</p> <p>常见的存储有两个，InnoDB和MyISAM，当然mysql还支持其他的存储引擎，只是用的不多。</p> <p>InnoDB和MyISAM主要的区别是：</p> <ul><li><p>InnoDB支持事务，而MyISAM不支持事务</p></li> <li><p>InnoDB支持表锁和行锁，MyISAM只支持表锁</p></li> <li><p>InnoDB支持外键，MyISAM不支持外键</p></li></ul> <p>我们通常在创建表的时候都是使用的InnoDB作为存储引擎，而mysql5.5以后默认的引擎也是InnoDB</p> <p><strong>面试官</strong>：了解过Mysql的索引嘛 ?</p> <p><strong>候选人</strong>：</p> <p>嗯，清楚的，这个是比较常用的</p> <p>索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构（B+树），这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p> <p><strong>面试官</strong>：索引的底层数据结构了解过嘛 ?</p> <p><strong>候选人</strong>：</p> <p>嗯，了解过~~~</p> <p>MySQL默认使用的索引底层数据结构是B+树</p> <p>B+树不同于二叉树，一种多叉路衡查找树，每个节点可以有多个分支</p> <p>比如一棵5阶的B树，每一个节点最多存储4个key，对应5个指针。一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。所有的数据都会出现在叶子节点，叶子节点形成一个双向链表，利于范围查询。非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</p> <p><strong>面试官</strong>：什么是聚簇索引什么是非聚簇索引 ?</p> <p><strong>候选人</strong>：</p> <p>嗯~~</p> <p>在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</p> <p>聚集索引(Clustered  Index)，将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据，必须有,而且只有一个，通常情况下一个表的主键就是聚集索引，如果表不存在则会使用唯一索引作为聚集索引，如果也没有唯一索引，InnoDB会自动生成一个rowid作为隐藏的聚集索引</p> <p>二级索引(Secondary  Index)，也可以成为非聚簇索引，将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键，可以存在多个。一般我们自己创建的复合索引这些都是二级索引</p> <p><strong>面试官</strong>：知道什么是回表查询嘛 ?</p> <p><strong>候选人</strong>：</p> <p>嗯，知道的~</p> <p>回表查询是使用二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式</p> <p>举个例子：</p> <p>有一个user表，给user表中的name创建了索引，那这个name的索引其实就是二级索引</p> <p>当我们select * from user where name = xx 的时候，条件name是可以走索引，但是要查询表中所有的字段，这个时候name的这个索引是没有的，但是能查询出来name这一行的id值，然后这个id值其实就是我们刚才说的聚集索引，然后根据这个id再去到索引去查一次，就相当于回表查询了</p> <p><strong>面试官</strong>：索引创建原则有哪些？</p> <p><strong>候选人</strong>：</p> <p>嗯，这个限制很多，我想一下~~~~</p> <p>有这么几种情况吧</p> <p>1). 针对于数据量较大，且查询比较频繁的表建立索引。</p> <p>2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</p> <p>3). 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p> <p>4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</p> <p>5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</p> <p>6). 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</p> <p>7). 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</p> <p><strong>面试官</strong>：知道什么是左前缀原则嘛 ?</p> <p><strong>候选人</strong>：</p> <p>嗯！！，这个是比较常见的</p> <p>就是说如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。</p> <p>比如有一个user表，给里面的字段创建了一个复合索引，顺序是name,age,email</p> <p>当查询索引不包含name的时候会失效的，当然查询name和age则不会失效，查询name和email跳过了age，则只有name会命中索引</p> <p><strong>面试官</strong>：知道什么叫覆盖索引嘛 ?</p> <p><strong>候选人</strong>：</p> <p>嗯~~</p> <p>覆盖索引是指 查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。</p> <p>比如有一个user表，给里面的字段创建了一个复合索引，顺序是name,age,email</p> <p>当查询索引只select后面只包含name,age,email的时候就算是覆盖索引了</p> <p><strong>面试官</strong>：索引是越多越好嘛? 什么样的字段需要建索引, 什么样的字段不需要 ?</p> <p><strong>候选人</strong>：</p> <p>索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</p> <p>有些字段是不适合创建索引的，比如</p> <ul><li><p>更新频繁字段不适合创建索引</p></li> <li><p>若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</p></li> <li><p>对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</p></li> <li><p>比如省会，城市、月份</p></li> <li><p>对于定义为text、image和bit的数据类型的列不要建立索引。</p></li></ul> <p>我们通常创建索引都是选择，比如</p> <ul><li>数据量较大，且查询比较频繁的表建立索引。</li></ul> <p>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</p></blockquote> <h3 id="_7-4-调优"><a href="#_7-4-调优" class="header-anchor">#</a> 7.4 调优</h3> <blockquote><p><strong>面试官</strong>：如何定位慢查询 ?</p> <p><strong>候选人</strong>：</p> <p>可以开启mysql的慢查询日志</p> <p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。</p> <p>如果要开启慢查询日志，需要在MySQL的配置文件中开启就行了，配置完毕之后，一旦产生了慢查询可以查看慢日志文件中记录的信息 /var/lib/mysql/localhost-slow.log，然后在进行分析就行了</p> <p>我们一般设置的一条sql执行的时间超过2秒，就会记录到慢日志文件中</p> <p><strong>面试官</strong>：一个SQL语句执行很慢, 如何分析 ?</p> <p><strong>候选人</strong>：</p> <p>可以采用EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p> <p>主要可以根据几个字段，判断sql是否需要优化，特别是是否能命中索引或命中索引的情况</p> <ul><li>type 通过sql的连接的类型进行优化</li> <li>possible_key  通过它查看是否可能会命中索引</li> <li>key 当前sql实际命中的索引</li> <li>key_len 索引占用的大小</li> <li>Extra 额外的优化建议</li></ul> <p><strong>面试官</strong>：什么情况下索引会失效 ?</p> <p><strong>候选人</strong>：</p> <p>嗯，这个情况有很多，比如：</p> <p>1). 违反了最左前缀法则</p> <p>2). 范围查询右边的列，不能使用索引 。</p> <p>3). 在索引列上进行运算操作， 索引将失效。</p> <p>4). 字符串不加单引号，造成索引失效。</p> <p>5). 尽量使用覆盖索引，避免select *
尽量使用覆盖索引（只访问索引的查询（索引列完全包含查询列）），减少select * 。</p> <p>如果查询列，超出索引列，也会降低性能。</p> <p>6). 用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p> <p>7). 以%开头的Like模糊查询，索引失效。通过覆盖索引来解决</p> <p>8). 如果MySQL评估使用索引比全表更慢，则不使用索引。</p> <p>9). is NULL ， is NOT NULL 有时索引失效。</p> <p>10). in 走索引， not in 索引失效。</p> <p><strong>面试官</strong>：MYSQL超大分页怎么处理 ?</p> <p><strong>候选人</strong>：</p> <p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。</p> <p>一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，然后通过覆盖索引加子查询形式进行优化。</p> <p><strong>面试官</strong>：谈谈你对sql的优化的经验</p> <p><strong>候选人</strong>：</p> <p>嗯，这个是方面的，我谈下我们的做法：</p> <p>①选择表合适存储引擎：</p> <ul><li>myisam: 应用时以读和插入操作为主，只有少量的更新和删除，并且对事务的完整性，并发性要求不是很高的。</li> <li>Innodb： 事务处理，以及并发条件下要求数据的一致性。除了插入和查询外，包括很多的更新和删除。尽量 设计 所有字段都得有默认值,尽量避免null。</li></ul> <p>②选择合适的数据类型</p> <p>数据库表设计时候更小的占磁盘空间尽可能使用更小的整数类型，一般来说，数据库中的表越小，在它上面执行的查询也就会越快。</p> <p>比如设置合适的数值（tinyint   int   bigint），要根据实际情况选择</p> <p>比如设置合适的字符串类型（char和varchar）char定长效率高，varchar可变长度，效率稍低</p> <p>③索引优化</p> <ul><li>表的主键、外键必须有索引；</li> <li>数据量大的表应该有索引；</li> <li>经常与其他表进行连接的表，在连接字段上应该建立索引；</li> <li>经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；</li> <li>索引应该建在选择性高的字段上； （sex 性别这种就不适合）</li> <li>索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；</li> <li>频繁进行数据操作的表，不要建立太多的索引；</li> <li>删除无用的索引，避免对执行计划造成负面影响；</li></ul> <p>④sql语句优化</p> <ul><li>SELECT语句务必指明字段名称（避免直接使用select * ）</li> <li>SQL语句要避免造成索引失效的写法</li> <li>SQL语句中IN包含的值不应过多</li> <li>当只需要一条数据的时候，使用limit 1</li> <li>如果排序字段没有用到索引，就尽量少排序</li> <li>如果限制条件中其他字段没有索引，尽量少用or</li> <li>尽量用union all代替union</li> <li>避免在where子句中对字段进行null值判断</li> <li>不建议使用%前缀模糊查询</li> <li>避免在where子句中对字段进行表达式操作</li> <li>Join优化 能用innerjoin 就不用left join right join，如必须使用 一定要已小表为驱动</li></ul> <p>⑤主从复制、读写分离</p> <p>如果数据库的使用场景读的操作比较的时候，为了避免写的操作所造成的性能影响 可以采用读写分离的架构，读写分离，解决的是，数据库的写入，影响了查询的效率。读写分离的基本原理是让主数据库处理事务性增、改、删操作（INSERT、UPDATE、DELETE），而从数据库处理SELECT查询操作。 数据库复制被用来把事务性操作导致的变更同步到集群中的从数据库。</p> <p>⑥mysql的分库分表</p> <p>当单表的数据量太大或单库的数据量太大的话，性能会降的比较厉害，这个时候就要考虑选择合适的拆分策略，比如垂直分库和水平分库</p></blockquote> <h3 id="_7-5-分库分表"><a href="#_7-5-分库分表" class="header-anchor">#</a> 7.5 分库分表</h3> <blockquote><p><strong>面试官</strong>：说一下主从同步的原理？</p> <p><strong>候选人</strong>：</p> <p>嗯，好的。</p> <p>MySQL主从复制的核心就是二进制日志，二进制日志记录了所有的 DDL语句和 DML语句</p> <p>具体的主从同步过程大概的流程是这样的：</p> <ol><li>Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</li> <li>从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</li> <li>slave重做中继日志中的事件，将改变反映它自己的数据。</li></ol> <p><strong>面试官</strong>：好的，如果读写分离的时候主从同步延时怎么解决？</p> <p><strong>候选人</strong>：</p> <p>嗯，我想一下~~~</p> <p>其实在实际应用中如果数据量超大的话，可能会出现延迟，MySQL的主从复制都是单线程的操作，主库对所有DDL和DML产生的日志写进binlog，由于binlog是顺序写，所以效率很高。Slave的SQL Thread线程将主库的DDL和DML操作事件在slave中重放。DML和DDL的IO操作是随机的，不是顺序的，成本高很多。所以SQL Thread线程的速度赶不上主库写binlog的速度，就会产生主从延迟</p> <p>第二个出现延迟的情况是由于SQL Thread也是单线程的，当主库的并发较高时，产生的DML数量超过slave的SQL Thread所能处理的速度，或者当slave中有大型query语句产生了锁等待那么延时就产生了。</p> <p>那解决方案的可以设置并行复制
MySQL 5.6 版本后，提供了一种并行复制的方式，通过将 SQL 线程转换为多个 work 线程来进行重放，这样就解决了主从延迟的问题。</p> <p><strong>面试官</strong>：Mysql为什么要分库分表？分库分表的策略有哪些？</p> <p><strong>候选人</strong>：</p> <p>我们当时项目业务量其实一直都在增长，有的单表就接近了2千万的数据，如果不分库分表的话，性能会直线下降。</p> <p>那关于数据库拆分的策略有很多，比如：垂直分库，垂直分表、水平分库，水平分表。</p> <p>因为我们现在微服务项目的开发，每个微服务都是管理的自己的业务库，在一定意义上其实已经进行了垂直分库，不过如果单库的数据量太大的话，也是装不下，所以，我们后来又进行了水平分库</p> <p>水平分库：以字段为依据，按照一定策略，将一个库的数据拆分到多个库中。当然为了让我们的微服务刚方便的去调用多个库中的数据，我们当时采用的mycat作为我们的分库分表的中间件来使用的。</p> <p><strong>面试官</strong>：分库分表后id主键如何处理？</p> <p><strong>候选人</strong>：</p> <p>嗯，这个也有很多种方案</p> <p>第一如果选择的主键还是自增的话，可以使用数据库中间件去解决，比如mycat，就能在配置中设置一个表是自增，由mycat帮助我们去设置自增</p> <p>第二，如果不是自增的，可以选择UUID或雪花算法来生成id，尽可能不要使用UUID，因为UUID 太长了、占用空间大，作为主键的性能不高，也不能排序</p></blockquote> <h3 id="_7-6-mysql锁相关"><a href="#_7-6-mysql锁相关" class="header-anchor">#</a> 7.6 MySQL锁相关</h3> <blockquote><p><strong>面试官</strong>：Mysql中有哪几种锁？</p> <p><strong>候选人</strong>：</p> <p>嗯~~~</p> <p>MySQL中按照锁的粒度分有三类，分别是</p> <ul><li><p>全局锁：锁定数据库中的所有表。</p></li> <li><p>表级锁：每次操作锁住整张表。</p></li> <li><p>行级锁：每次操作锁住对应的行数据。</p></li></ul> <p><strong>面试官</strong>：表级锁和行级锁了解吗？有什么区别？</p> <p><strong>候选人</strong>：</p> <p>嗯~是这样的</p> <p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB等存储引擎中。</p> <p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。</p> <p><strong>面试官</strong>：意向锁有什么作用？</p> <p><strong>候选人</strong>：</p> <p>嗯，是这样的</p> <p>我们在DML操作的时候有可能会产生行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p> <p><strong>面试官</strong>：共享锁和排他锁呢？</p> <p><strong>候选人</strong>：</p> <p>InnoDB实现了两种类型的行锁，第一个就是共享锁，第二个是拍他锁</p> <ul><li>共享锁是指允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li> <li>排他锁是指允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</li></ul> <p>在我们平时的sql语句中，insert、update、delete都会自动添加排他锁，而select不会加锁</p> <p>当然，如果select想要加锁也是可以的，如果是共享锁的话则可以在select之后加LOCK IN   SHARE MODE  ，如果是排他锁需要手动在SELECT之后加FOR UPDATE</p> <p><strong>面试官</strong>：解释一下MVCC</p> <p><strong>候选人</strong>：</p> <p>嗯~~</p> <p>MVCC多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p> <ul><li><p>三个隐藏字段分别是隐藏主键，事务ID，回滚指针。</p></li> <li><p>undo log是各个事务修改同一条记录的时候生成的历史记录，方便回滚，同时会生成一条版本链。</p></li> <li><p>ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。</p></li> <li><p>ReadView中包含了四个核心字段：</p> <ul><li>m_ids：当前活跃的事务ID集合</li> <li>min_trx_id：最小活跃事务ID</li> <li>max_trx_id：预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）</li> <li>creator_trx_id：ReadView创建者的事务ID</li></ul></li> <li><p>而在readview中就规定了版本链数据的访问规则：</p> <p>trx_id 代表当前undolog版本链对应事务ID。</p> <ul><li>trx_id == creator_trx_id 可以访问该版本，成立，说明数据是当前这个事务更改的。</li> <li>trx_id &lt; min_trx_id 可以访问该版本，成立，说明数据已经提交了。</li> <li>trx_id &gt; max_trx_id 不可以访问该版本，成立，说明该事务是在ReadView生成后才开启。</li> <li>min_trx_id &lt;= trx_id &lt;= max_trx_id，如果trx_id不在m_ids中，是可以访问该版本的，成立，说明数据已经提交。</li></ul></li></ul> <p>不同的隔离级别，生成ReadView的时机不同：</p> <ul><li><p>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。</p></li> <li><p>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</p></li></ul></blockquote></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新时间:</span> <span class="time">2023/10/29</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Java面试题/SpringBoot面试题/SSM相关面试题.html" class="prev">
        SSM相关面试题
      </a></span> <span class="next"><a href="/Java面试题/Redis面试题/Redis面试题.html">
        Redis面试题
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a19eb3cb.js" defer></script><script src="/assets/js/2.34fff606.js" defer></script><script src="/assets/js/1.16393a26.js" defer></script><script src="/assets/js/55.0fcb916b.js" defer></script>
  </body>
</html>
