<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>SpringBoot面试题 | 周岐的个人博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="logo.jpg">
    <meta name="description" content="个人技术博客">
    
    <link rel="preload" href="/assets/css/0.styles.8c53e149.css" as="style"><link rel="preload" href="/assets/js/app.a19eb3cb.js" as="script"><link rel="preload" href="/assets/js/2.34fff606.js" as="script"><link rel="preload" href="/assets/js/1.16393a26.js" as="script"><link rel="preload" href="/assets/js/62.11484b5e.js" as="script"><link rel="prefetch" href="/assets/js/10.717bd423.js"><link rel="prefetch" href="/assets/js/100.c5cd47b0.js"><link rel="prefetch" href="/assets/js/101.7151b423.js"><link rel="prefetch" href="/assets/js/102.6b36385a.js"><link rel="prefetch" href="/assets/js/103.d3861779.js"><link rel="prefetch" href="/assets/js/104.9578b311.js"><link rel="prefetch" href="/assets/js/105.aae477dc.js"><link rel="prefetch" href="/assets/js/106.1d5215a7.js"><link rel="prefetch" href="/assets/js/107.3c330c2f.js"><link rel="prefetch" href="/assets/js/108.cefc2802.js"><link rel="prefetch" href="/assets/js/109.541aa22e.js"><link rel="prefetch" href="/assets/js/11.e0bfb9a4.js"><link rel="prefetch" href="/assets/js/110.60e0b929.js"><link rel="prefetch" href="/assets/js/111.45058523.js"><link rel="prefetch" href="/assets/js/112.d10d50d0.js"><link rel="prefetch" href="/assets/js/113.4a3deb35.js"><link rel="prefetch" href="/assets/js/114.b917d1a1.js"><link rel="prefetch" href="/assets/js/115.50e3fa0f.js"><link rel="prefetch" href="/assets/js/116.78f04bf7.js"><link rel="prefetch" href="/assets/js/117.b5372645.js"><link rel="prefetch" href="/assets/js/118.f990eb5b.js"><link rel="prefetch" href="/assets/js/119.f178eabd.js"><link rel="prefetch" href="/assets/js/12.bdf46c02.js"><link rel="prefetch" href="/assets/js/120.d98a3aa8.js"><link rel="prefetch" href="/assets/js/121.abcdf60f.js"><link rel="prefetch" href="/assets/js/122.ed3550a9.js"><link rel="prefetch" href="/assets/js/123.8ef421f8.js"><link rel="prefetch" href="/assets/js/124.1adba2c7.js"><link rel="prefetch" href="/assets/js/125.6706c196.js"><link rel="prefetch" href="/assets/js/126.1e50c7b4.js"><link rel="prefetch" href="/assets/js/127.be9df6e0.js"><link rel="prefetch" href="/assets/js/128.9e68fe60.js"><link rel="prefetch" href="/assets/js/129.f9313e6a.js"><link rel="prefetch" href="/assets/js/13.05b00624.js"><link rel="prefetch" href="/assets/js/130.87d4d918.js"><link rel="prefetch" href="/assets/js/131.b7ab0bc3.js"><link rel="prefetch" href="/assets/js/132.4bf1103a.js"><link rel="prefetch" href="/assets/js/133.2bda9aa2.js"><link rel="prefetch" href="/assets/js/134.e6631028.js"><link rel="prefetch" href="/assets/js/135.5b78aed3.js"><link rel="prefetch" href="/assets/js/136.377fd687.js"><link rel="prefetch" href="/assets/js/137.623e1a9d.js"><link rel="prefetch" href="/assets/js/138.c2e1c9a1.js"><link rel="prefetch" href="/assets/js/139.6263f657.js"><link rel="prefetch" href="/assets/js/14.092a5584.js"><link rel="prefetch" href="/assets/js/140.a54c064d.js"><link rel="prefetch" href="/assets/js/141.0de2ed45.js"><link rel="prefetch" href="/assets/js/142.61ea0663.js"><link rel="prefetch" href="/assets/js/143.24d35022.js"><link rel="prefetch" href="/assets/js/144.196d7653.js"><link rel="prefetch" href="/assets/js/145.223f0fcf.js"><link rel="prefetch" href="/assets/js/146.a09f8d1b.js"><link rel="prefetch" href="/assets/js/147.62d69c7c.js"><link rel="prefetch" href="/assets/js/148.d46a05d0.js"><link rel="prefetch" href="/assets/js/149.467faf3d.js"><link rel="prefetch" href="/assets/js/15.758ee11b.js"><link rel="prefetch" href="/assets/js/150.0443932e.js"><link rel="prefetch" href="/assets/js/151.0879c074.js"><link rel="prefetch" href="/assets/js/152.4d08f8a9.js"><link rel="prefetch" href="/assets/js/153.ce46c4fa.js"><link rel="prefetch" href="/assets/js/154.fd65dd72.js"><link rel="prefetch" href="/assets/js/155.b975728f.js"><link rel="prefetch" href="/assets/js/156.61194924.js"><link rel="prefetch" href="/assets/js/157.97e4f54e.js"><link rel="prefetch" href="/assets/js/158.5290a2f0.js"><link rel="prefetch" href="/assets/js/159.3613e64b.js"><link rel="prefetch" href="/assets/js/16.2569be64.js"><link rel="prefetch" href="/assets/js/160.87d90e6b.js"><link rel="prefetch" href="/assets/js/161.a2a67f25.js"><link rel="prefetch" href="/assets/js/162.b51ccce1.js"><link rel="prefetch" href="/assets/js/163.85d33d23.js"><link rel="prefetch" href="/assets/js/164.5504b77f.js"><link rel="prefetch" href="/assets/js/165.be283131.js"><link rel="prefetch" href="/assets/js/166.8d0352c5.js"><link rel="prefetch" href="/assets/js/167.89c23a71.js"><link rel="prefetch" href="/assets/js/168.aa736b2c.js"><link rel="prefetch" href="/assets/js/169.296ccc1d.js"><link rel="prefetch" href="/assets/js/17.5b873df7.js"><link rel="prefetch" href="/assets/js/170.c706da49.js"><link rel="prefetch" href="/assets/js/171.6f79aeb1.js"><link rel="prefetch" href="/assets/js/172.ddcae302.js"><link rel="prefetch" href="/assets/js/173.f308eb43.js"><link rel="prefetch" href="/assets/js/174.b5ece966.js"><link rel="prefetch" href="/assets/js/175.538e3125.js"><link rel="prefetch" href="/assets/js/176.d54091dd.js"><link rel="prefetch" href="/assets/js/177.2ee0aa3d.js"><link rel="prefetch" href="/assets/js/178.667b3c59.js"><link rel="prefetch" href="/assets/js/179.07595c3e.js"><link rel="prefetch" href="/assets/js/18.4c170722.js"><link rel="prefetch" href="/assets/js/180.300e0b70.js"><link rel="prefetch" href="/assets/js/181.89473dcd.js"><link rel="prefetch" href="/assets/js/182.ea6036d1.js"><link rel="prefetch" href="/assets/js/183.647f8d55.js"><link rel="prefetch" href="/assets/js/184.2e79dd55.js"><link rel="prefetch" href="/assets/js/185.bf4d6269.js"><link rel="prefetch" href="/assets/js/186.7a7ceaa7.js"><link rel="prefetch" href="/assets/js/187.09bb0f21.js"><link rel="prefetch" href="/assets/js/188.3604ce73.js"><link rel="prefetch" href="/assets/js/189.49b47b33.js"><link rel="prefetch" href="/assets/js/19.a45744ea.js"><link rel="prefetch" href="/assets/js/190.88e59ff4.js"><link rel="prefetch" href="/assets/js/191.a4b3e5c7.js"><link rel="prefetch" href="/assets/js/192.7527e6ed.js"><link rel="prefetch" href="/assets/js/193.c44a652d.js"><link rel="prefetch" href="/assets/js/194.6aaca2ce.js"><link rel="prefetch" href="/assets/js/195.64837df2.js"><link rel="prefetch" href="/assets/js/196.e1bd3d69.js"><link rel="prefetch" href="/assets/js/197.2b01de81.js"><link rel="prefetch" href="/assets/js/198.d1496fd2.js"><link rel="prefetch" href="/assets/js/199.27ab1442.js"><link rel="prefetch" href="/assets/js/20.4cb27e25.js"><link rel="prefetch" href="/assets/js/200.996d49f4.js"><link rel="prefetch" href="/assets/js/201.b71a4422.js"><link rel="prefetch" href="/assets/js/202.0ea49eaa.js"><link rel="prefetch" href="/assets/js/203.8ebb1f77.js"><link rel="prefetch" href="/assets/js/204.c8d10533.js"><link rel="prefetch" href="/assets/js/205.0b8c4d0d.js"><link rel="prefetch" href="/assets/js/206.cce9bcce.js"><link rel="prefetch" href="/assets/js/207.8130e9ba.js"><link rel="prefetch" href="/assets/js/208.871753be.js"><link rel="prefetch" href="/assets/js/209.757eda19.js"><link rel="prefetch" href="/assets/js/21.445690e6.js"><link rel="prefetch" href="/assets/js/210.983cae1d.js"><link rel="prefetch" href="/assets/js/211.8e4ddaf8.js"><link rel="prefetch" href="/assets/js/212.6412fc61.js"><link rel="prefetch" href="/assets/js/213.656a6a73.js"><link rel="prefetch" href="/assets/js/214.befcd199.js"><link rel="prefetch" href="/assets/js/215.2c292e81.js"><link rel="prefetch" href="/assets/js/216.78cc7e8b.js"><link rel="prefetch" href="/assets/js/217.4fa8b1da.js"><link rel="prefetch" href="/assets/js/218.4c8cce7c.js"><link rel="prefetch" href="/assets/js/219.d041d013.js"><link rel="prefetch" href="/assets/js/22.bc7c4cdb.js"><link rel="prefetch" href="/assets/js/220.10a9ed88.js"><link rel="prefetch" href="/assets/js/221.bc25f391.js"><link rel="prefetch" href="/assets/js/222.dfdd15b7.js"><link rel="prefetch" href="/assets/js/223.1afa90d8.js"><link rel="prefetch" href="/assets/js/224.69bb037f.js"><link rel="prefetch" href="/assets/js/225.94590311.js"><link rel="prefetch" href="/assets/js/226.d1818961.js"><link rel="prefetch" href="/assets/js/227.2a969459.js"><link rel="prefetch" href="/assets/js/228.e3f5706b.js"><link rel="prefetch" href="/assets/js/229.0e6df830.js"><link rel="prefetch" href="/assets/js/23.b7994ecf.js"><link rel="prefetch" href="/assets/js/230.6bc93aa6.js"><link rel="prefetch" href="/assets/js/231.9b7cc0ec.js"><link rel="prefetch" href="/assets/js/232.80b7488d.js"><link rel="prefetch" href="/assets/js/233.302790de.js"><link rel="prefetch" href="/assets/js/234.68b70723.js"><link rel="prefetch" href="/assets/js/235.1b3c3110.js"><link rel="prefetch" href="/assets/js/236.e536b7bb.js"><link rel="prefetch" href="/assets/js/237.cca351a3.js"><link rel="prefetch" href="/assets/js/238.f4d0edb0.js"><link rel="prefetch" href="/assets/js/239.4f57e73d.js"><link rel="prefetch" href="/assets/js/24.26e26a07.js"><link rel="prefetch" href="/assets/js/240.1e76f670.js"><link rel="prefetch" href="/assets/js/241.8795d427.js"><link rel="prefetch" href="/assets/js/242.c72205cb.js"><link rel="prefetch" href="/assets/js/243.d7105431.js"><link rel="prefetch" href="/assets/js/244.361b2ea5.js"><link rel="prefetch" href="/assets/js/245.055fa0a3.js"><link rel="prefetch" href="/assets/js/246.0dee7b05.js"><link rel="prefetch" href="/assets/js/247.c13fc7d7.js"><link rel="prefetch" href="/assets/js/248.4e481dba.js"><link rel="prefetch" href="/assets/js/25.626c2c33.js"><link rel="prefetch" href="/assets/js/26.c4aa6beb.js"><link rel="prefetch" href="/assets/js/27.b1a828b7.js"><link rel="prefetch" href="/assets/js/28.f9133ade.js"><link rel="prefetch" href="/assets/js/29.54e09df1.js"><link rel="prefetch" href="/assets/js/3.4db2e19a.js"><link rel="prefetch" href="/assets/js/30.d2654359.js"><link rel="prefetch" href="/assets/js/31.c57cf20e.js"><link rel="prefetch" href="/assets/js/32.ed5593a9.js"><link rel="prefetch" href="/assets/js/33.05f050d1.js"><link rel="prefetch" href="/assets/js/34.6d7f5b2f.js"><link rel="prefetch" href="/assets/js/35.67cc577c.js"><link rel="prefetch" href="/assets/js/36.0bbc204a.js"><link rel="prefetch" href="/assets/js/37.8ac35368.js"><link rel="prefetch" href="/assets/js/38.50bd8dba.js"><link rel="prefetch" href="/assets/js/39.38b783ce.js"><link rel="prefetch" href="/assets/js/4.66c035fd.js"><link rel="prefetch" href="/assets/js/40.cd3ee2ff.js"><link rel="prefetch" href="/assets/js/41.f4bec9a4.js"><link rel="prefetch" href="/assets/js/42.27fa7fec.js"><link rel="prefetch" href="/assets/js/43.2af4a015.js"><link rel="prefetch" href="/assets/js/44.8e48aaf4.js"><link rel="prefetch" href="/assets/js/45.d41c0319.js"><link rel="prefetch" href="/assets/js/46.de5cb880.js"><link rel="prefetch" href="/assets/js/47.cc7c8048.js"><link rel="prefetch" href="/assets/js/48.22c69558.js"><link rel="prefetch" href="/assets/js/49.cdd62276.js"><link rel="prefetch" href="/assets/js/5.632744e8.js"><link rel="prefetch" href="/assets/js/50.a7eebe42.js"><link rel="prefetch" href="/assets/js/51.a447aa90.js"><link rel="prefetch" href="/assets/js/52.c0f076a5.js"><link rel="prefetch" href="/assets/js/53.3564c5b0.js"><link rel="prefetch" href="/assets/js/54.c5c6e6be.js"><link rel="prefetch" href="/assets/js/55.0fcb916b.js"><link rel="prefetch" href="/assets/js/56.2812bd7d.js"><link rel="prefetch" href="/assets/js/57.4f95d22a.js"><link rel="prefetch" href="/assets/js/58.d9baba05.js"><link rel="prefetch" href="/assets/js/59.371bd0d7.js"><link rel="prefetch" href="/assets/js/6.85f26be6.js"><link rel="prefetch" href="/assets/js/60.a715876a.js"><link rel="prefetch" href="/assets/js/61.6b1a782b.js"><link rel="prefetch" href="/assets/js/63.7b92573e.js"><link rel="prefetch" href="/assets/js/64.98aee69e.js"><link rel="prefetch" href="/assets/js/65.aa40eacd.js"><link rel="prefetch" href="/assets/js/66.67703170.js"><link rel="prefetch" href="/assets/js/67.392b86af.js"><link rel="prefetch" href="/assets/js/68.9610b8e9.js"><link rel="prefetch" href="/assets/js/69.6277fc7a.js"><link rel="prefetch" href="/assets/js/7.b775b056.js"><link rel="prefetch" href="/assets/js/70.b47adb04.js"><link rel="prefetch" href="/assets/js/71.0051199b.js"><link rel="prefetch" href="/assets/js/72.fa131834.js"><link rel="prefetch" href="/assets/js/73.fd8d275f.js"><link rel="prefetch" href="/assets/js/74.82095aed.js"><link rel="prefetch" href="/assets/js/75.41fad4ea.js"><link rel="prefetch" href="/assets/js/76.36bb1714.js"><link rel="prefetch" href="/assets/js/77.83c409c1.js"><link rel="prefetch" href="/assets/js/78.ca197ebf.js"><link rel="prefetch" href="/assets/js/79.9f0de524.js"><link rel="prefetch" href="/assets/js/80.7dd0f8a1.js"><link rel="prefetch" href="/assets/js/81.a5d44424.js"><link rel="prefetch" href="/assets/js/82.03d59f96.js"><link rel="prefetch" href="/assets/js/83.43da9399.js"><link rel="prefetch" href="/assets/js/84.e9ab171d.js"><link rel="prefetch" href="/assets/js/85.523fe07f.js"><link rel="prefetch" href="/assets/js/86.90aac9c6.js"><link rel="prefetch" href="/assets/js/87.1af6082d.js"><link rel="prefetch" href="/assets/js/88.3d7d10f0.js"><link rel="prefetch" href="/assets/js/89.69f4fbaf.js"><link rel="prefetch" href="/assets/js/90.30407e67.js"><link rel="prefetch" href="/assets/js/91.94355f67.js"><link rel="prefetch" href="/assets/js/92.8247a2fb.js"><link rel="prefetch" href="/assets/js/93.245ee436.js"><link rel="prefetch" href="/assets/js/94.a212b15e.js"><link rel="prefetch" href="/assets/js/95.dec85448.js"><link rel="prefetch" href="/assets/js/96.77ebb7ae.js"><link rel="prefetch" href="/assets/js/97.0a615ee3.js"><link rel="prefetch" href="/assets/js/98.9d539c75.js"><link rel="prefetch" href="/assets/js/99.270c2389.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.b7a3ab4f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8c53e149.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">周岐的个人博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/java SE/guide.html" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/项目总结/Mybatis使用/Mybatis分页实现.html" class="nav-link">
  项目总结
</a></div><div class="nav-item"><a href="/Java面试题/Java基础面试题/==和equals的区别.html" class="nav-link">
  Java面试题
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="了解更多" class="dropdown-title"><span class="title">了解更多</span> <span class="arrow down"></span></button> <button type="button" aria-label="了解更多" class="mobile-dropdown-title"><span class="title">了解更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/demo223" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://www.yuque.com/zhouqi-5zipq" target="_blank" rel="noopener noreferrer" class="nav-link external">
  语雀
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/java SE/guide.html" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/项目总结/Mybatis使用/Mybatis分页实现.html" class="nav-link">
  项目总结
</a></div><div class="nav-item"><a href="/Java面试题/Java基础面试题/==和equals的区别.html" class="nav-link">
  Java面试题
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="了解更多" class="dropdown-title"><span class="title">了解更多</span> <span class="arrow down"></span></button> <button type="button" aria-label="了解更多" class="mobile-dropdown-title"><span class="title">了解更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/demo223" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://www.yuque.com/zhouqi-5zipq" target="_blank" rel="noopener noreferrer" class="nav-link external">
  语雀
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/java SE/guide" class="sidebar-heading clickable"><span>java SE</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>java web</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>SpringBoot</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>微服务</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Linux</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Docker</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Mybatis-Plus</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>常用工具类</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Java面试题</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Java面试题/Java基础面试题/==和equals的区别" class="sidebar-heading clickable"><span>Java基础面试题</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Java面试题/多线程面试题/多线程面试题" class="sidebar-heading clickable"><span>多线程面试题</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Java面试题/集合面试题/Java集合相关面试题" class="sidebar-heading clickable"><span>集合面试题</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Java面试题/Mybatis面试题/Mybatis面试题" class="sidebar-heading clickable"><span>Mybatis面试题</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Java面试题/SpringBoot面试题/SpringBoot面试题" class="sidebar-heading clickable open active"><span>SpringBoot面试题</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/Java面试题/SpringBoot面试题/SpringBoot面试题.html" class="active sidebar-link">SpringBoot面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Java面试题/SpringBoot面试题/SpringBoot面试题.html#_1、spring-的两大核心是什么" class="sidebar-link">1、Spring 的两大核心是什么?</a></li><li class="sidebar-sub-header"><a href="/Java面试题/SpringBoot面试题/SpringBoot面试题.html#_2、谈一谈你对-ioc-的理解" class="sidebar-link">2、谈一谈你对 IOC 的理解</a></li><li class="sidebar-sub-header"><a href="/Java面试题/SpringBoot面试题/SpringBoot面试题.html#_3、ioc的优点有哪些" class="sidebar-link">3、IOC的优点有哪些？</a></li><li class="sidebar-sub-header"><a href="/Java面试题/SpringBoot面试题/SpringBoot面试题.html#_4、谈一下你对aop的理解" class="sidebar-link">4、谈一下你对AOP的理解</a></li><li class="sidebar-sub-header"><a href="/Java面试题/SpringBoot面试题/SpringBoot面试题.html#_5、spring-bean的生命周期-高薪常问" class="sidebar-link">5、Spring Bean的生命周期?(高薪常问)</a></li><li class="sidebar-sub-header"><a href="/Java面试题/SpringBoot面试题/SpringBoot面试题.html#_6、spring-支持-bean-的作用域有几种-必会" class="sidebar-link">6、Spring 支持 bean 的作用域有几种？(必会)</a></li><li class="sidebar-sub-header"><a href="/Java面试题/SpringBoot面试题/SpringBoot面试题.html#_7、beanfactory-和-applicationcontext-区别-了解" class="sidebar-link">7、BeanFactory 和 ApplicationContext 区别(了解)</a></li><li class="sidebar-sub-header"><a href="/Java面试题/SpringBoot面试题/SpringBoot面试题.html#_8、spring-框架中都用到了哪些设计模式-必会" class="sidebar-link">8、Spring 框架中都用到了哪些设计模式?(必会)</a></li><li class="sidebar-sub-header"><a href="/Java面试题/SpringBoot面试题/SpringBoot面试题.html#_9、spring-事务的实现方式和实现原理-必会" class="sidebar-link">9、Spring 事务的实现方式和实现原理(必会)</a></li><li class="sidebar-sub-header"><a href="/Java面试题/SpringBoot面试题/SpringBoot面试题.html#_10、spring中aop的通知类型有哪些" class="sidebar-link">10、Spring中aop的通知类型有哪些？</a></li><li class="sidebar-sub-header"><a href="/Java面试题/SpringBoot面试题/SpringBoot面试题.html#_11、spring-的对象默认是单例的还是多例的-单例-bean-存不存在线程安全问题呢-必会" class="sidebar-link">11、Spring 的对象默认是单例的还是多例的?单例 bean 存不存在线程安全问题呢?(必会)</a></li><li class="sidebar-sub-header"><a href="/Java面试题/SpringBoot面试题/SpringBoot面试题.html#_12、-resource-和-autowired-依赖注入的区别是什么-qualifier-使用场景是什么-了解" class="sidebar-link">12、@Resource 和@Autowired 依赖注入的区别是什么?@Qualifier 使用场景是什么?(了解)</a></li><li class="sidebar-sub-header"><a href="/Java面试题/SpringBoot面试题/SpringBoot面试题.html#spring事务-4种特性、7种传播行为-5种隔离级别" class="sidebar-link">Spring事务（4种特性、7种传播行为，5种隔离级别）</a></li><li class="sidebar-sub-header"><a href="/Java面试题/SpringBoot面试题/SpringBoot面试题.html#_13、spring-的7种事务传播行为-高薪常问" class="sidebar-link">13、Spring 的7种事务传播行为(高薪常问)</a></li><li class="sidebar-sub-header"><a href="/Java面试题/SpringBoot面试题/SpringBoot面试题.html#_14、spring中事务的4大特征" class="sidebar-link">14、Spring中事务的4大特征</a></li><li class="sidebar-sub-header"><a href="/Java面试题/SpringBoot面试题/SpringBoot面试题.html#_15、spring-中的5大隔离级别-高薪常问" class="sidebar-link">15、Spring 中的5大隔离级别(高薪常问)</a></li><li class="sidebar-sub-header"><a href="/Java面试题/SpringBoot面试题/SpringBoot面试题.html#_16、事务失效问题" class="sidebar-link">16、事务失效问题</a></li><li class="sidebar-sub-header"><a href="/Java面试题/SpringBoot面试题/SpringBoot面试题.html#_17、springboot自动装配原理" class="sidebar-link">17、SpringBoot自动装配原理</a></li><li class="sidebar-sub-header"><a href="/Java面试题/SpringBoot面试题/SpringBoot面试题.html#_18、什么是spring的循环依赖-如何解决循环依赖" class="sidebar-link">18、什么是Spring的循环依赖？如何解决循环依赖？</a></li><li class="sidebar-sub-header"><a href="/Java面试题/SpringBoot面试题/SpringBoot面试题.html#_19、spring-mvc中的拦截器和servlet中的filter有什么区别" class="sidebar-link">19、Spring MVC中的拦截器和Servlet中的filter有什么区别？</a></li><li class="sidebar-sub-header"><a href="/Java面试题/SpringBoot面试题/SpringBoot面试题.html#_20、springmvc的执行流程" class="sidebar-link">20、SpringMVC的执行流程</a></li></ul></li><li><a href="/Java面试题/SpringBoot面试题/SpringBoot面试题补充.html" class="sidebar-link">SpringBoot面试题补充</a></li><li><a href="/Java面试题/SpringBoot面试题/SSM相关面试题.html" class="sidebar-link">SSM相关面试题</a></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Java面试题/MySQL面试题/MySQL面试题" class="sidebar-heading clickable"><span>MySQL面试题</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Java面试题/Redis面试题/Redis面试题" class="sidebar-heading clickable"><span>Redis面试题</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Java面试题/微服务面试题/微服务面试题" class="sidebar-heading clickable"><span>微服务面试题</span> <span class="arrow right"></span></a> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>项目总结</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/SpringBoot文档/01-Spring-IOC" class="sidebar-heading clickable"><span>SpringBoot文档</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/微服务文档/SpringCloud介绍" class="sidebar-heading clickable"><span>微服务文档</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="springboot面试题"><a href="#springboot面试题" class="header-anchor">#</a> SpringBoot面试题</h1> <h2 id="_1、spring-的两大核心是什么"><a href="#_1、spring-的两大核心是什么" class="header-anchor">#</a> 1、Spring 的两大核心是什么?</h2> <p>Spring 的两大核心是：<code>IOC</code>（控制翻转）和 <code>AOP</code>（面向切面编程）</p> <p><code>DI</code>(Dependency Injection)即依赖注入，是<code>IOC</code>的一种实现方式。</p> <h2 id="_2、谈一谈你对-ioc-的理解"><a href="#_2、谈一谈你对-ioc-的理解" class="header-anchor">#</a> 2、谈一谈你对 IOC 的理解</h2> <p><a href="https://blog.csdn.net/wanghao72214/article/details/3969594" target="_blank" rel="noopener noreferrer">资料参考地址<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>IOC 的意思是<strong>控制反转</strong>，是指==创建对象的控制权的转移，以前创建对象的主动权和时机是由自己把控的，而现在把这种权力转移到 Spring 容器中==，并由容器根据配置文件去创建实例和管理各个实例之 间的依赖关系，对象与对象之间松散耦合，也利于功能的复用。最直观的表达就是，IOC 让对象的创建不用去 <code>new</code>了，可以由 spring 根据我们提供的配置文件自动生产，我们需要对象的时候，直接从 Spring 容器中获取即可。</p> <p>Spring 的配置文件中配置了类的字节码位置及信息，容器生成的时候加载配置文件识别字节码信息，通过反射创建类的对象。</p> <hr> <p>IOC(Inversion of Control)是一种设计思想，它将应用程序中对象之间的控制权反转过来，由容器来负责对象的生命周期管理和依赖关系维护。这意味着对象不再自行创建和管理所需的其他对象，而是由容器自动注入。这样可以更好地管理对象之间的依赖关系，以及减少代码冗余，提高代码的可测试性和可维护性。</p> <hr> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20230208161625213.png" alt="image-20230208161625213"></p> <p>由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。</p> <hr> <p>Spring的IoC容器支持三种注入方式：</p> <ul><li><p><strong>属性注入</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Autowired</span>
<span class="token keyword">private</span> <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p><strong>Setter 注入</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Controller</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span>
	<span class="token comment">// Setter 注入</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUserService</span><span class="token punctuation">(</span><span class="token class-name">UserService</span> userService<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>userService <span class="token operator">=</span> userService<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li> <li><p><strong>构造方法注入</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Controller</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>
   <span class="token comment">//  使用构造方法注入可以注入不可变对象</span>
   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span>

   <span class="token annotation punctuation">@Autowired</span>
   <span class="token keyword">public</span> <span class="token class-name">UserController</span><span class="token punctuation">(</span><span class="token class-name">UserService</span> userService<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>userService <span class="token operator">=</span> userService<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li></ul> <h2 id="_3、ioc的优点有哪些"><a href="#_3、ioc的优点有哪些" class="header-anchor">#</a> 3、IOC的优点有哪些？</h2> <ol><li>解耦：对象之间的依赖关系由容器维护，而不是代码本身，因此可以减少代码间的耦合。</li> <li>可维护性：通过IoC容器管理对象的生命周期和依赖关系，使得代码更易维护。</li> <li>可测试性：通过注入模拟的对象，可以更方便地对单个对象进行测试，减少了对整个系统的测试难度。</li> <li>易于重用：通过IoC容器管理对象的依赖关系，可以更方便地将对象复用到其他地方。</li> <li>易于扩展：通过IoC容器管理对象的生命周期和依赖关系，可以更方便地对系统进行扩展。</li></ol> <h2 id="_4、谈一下你对aop的理解"><a href="#_4、谈一下你对aop的理解" class="header-anchor">#</a> 4、谈一下你对AOP的理解</h2> <p>AOP一般称为==面向切面编程==，作为面向对象OOP的一种补充，==用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”==（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。</p> <p>在我们的项目中我们自己写AOP的场景其实很少 , 但是我们使用的很多框架的功能底层都是AOP  , 例如 ：</p> <ol><li><p>统一日志处理</p></li> <li><p>spring中内置的事务处理</p></li></ol> <hr> <p><strong>得分点</strong></p> <ul><li><p>AOP概念</p></li> <li><p>AOP作用</p></li> <li><p>AOP的实现方式</p> <p>​</p></li></ul> <p><strong>标准回答</strong></p> <p>AOP是一种编程思想，是通过==预编译方式和运行期动态代理==的方式<strong>实现不修改源代码的情况下给程序动态统一添加功能的技术</strong>。面向对象编程将程序抽象成各个层次的对象，而面向切面编程是将程序抽象成各个切面。所谓切面，相当于应用对象间的横切点，我们可以将其单独抽象为单独的模块。 AOP技术利用一种称为“横切”的技术，剖解开封装对象的内部，将影响多个类的公共行为封装到一个可重用的模块中，并将其命名为<strong>切面</strong>。所谓的切面，简单来说就是与业务无关，却为业务模块所共同调用的逻辑，将其封装起来便于减少系统的重复代码，降低模块的耦合度，有利用未来的可操作性和可维护性。</p> <hr> <p>利用AOP可以对业务逻辑各个部分进行隔离，从而使业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高开发效率。</p> <ol><li>减少代码重复：通过抽象公共行为到单独的切面，避免了系统中重复代码的出现。</li> <li>提高模块间的松耦合性：切面中的逻辑不直接影响业务模块，提高了模块间的松耦合性。</li> <li>提高代码可维护性：通过抽象切面的方式，使代码变得更加清晰，提高了代码的可维护性。</li> <li>支持动态添加功能：通过AOP技术，可以在运行期动态给程序添加功能，不需要修改源代码。</li> <li>提高代码的可读性：通过抽象切面的方式，使代码更加清晰易懂，提高了代码的可读性。</li></ol> <hr> <p>AOP可以有多种实现方式，而Spring AOP支持如下两种实现方式。</p> <ul><li><code>JDK</code>动态代理：这是Java提供的动态代理技术，可以在运行时创建接口的代理实例。Spring AOP默认采用这种方式，在接口的代理实例中织入代码。</li> <li><code>CGLib</code>动态代理：采用底层的字节码技术，在运行时创建子类代理的实例。当目标对象不存在接口时，Spring AOP就会采用这种方式，在子类实例中织入代码。</li></ul> <p>二者区别：<code>JDK</code>代理只能==对实现接口的类生成代理==；<code>CGlib</code>是==针对类实现代理，对指定的类生成一个子类，并覆盖其中的方法==，这种通过继承类的实现方式，不能代理<code>final</code>修饰的类。</p> <p>关于AOP中使用的是<code>JDK</code>代理还是<code>CGLib</code>代理</p> <p>SpringBoot默认配置<code>spring.aop.proxy-target-class=true</code>(使用类代理，而不是接口代理。)，此时无论目标是否实现接口，都是采用<code>cglib</code></p> <p>如果设置了 <code>spring.aop.proxy-target-class=false</code>，那么又分两种情况</p> <ul><li>如果在AOP中被代理的是一个==接口的实现类==，那么AOP中使用就是<code>JDK</code>动态代理</li> <li>如果在AOP中被代理的类是一个==普通类==，那么AOP中使用就是<code>CGlib</code>动态代理</li></ul> <blockquote><p><strong>动态代理</strong>是23种设计模式中的一种，属于结构型模式。==动态代理类不是在编译时生成的，而是在运行时通过反射机制动态生成的==。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰。</p></blockquote> <p><strong>加分回答</strong></p> <p>在应用场景方面，Spring AOP为IOC的使用提供了更多的便利，一方面，应用可以直接使用AOP的功能，设计应用的横切关注点，把跨越应用程序多个模块的功能抽象出来，并通过简单的AOP的使用，灵活地编制到模块中，比如可以通过AOP实现应用程序中的==日志功能==。另一方面，在Spring内部，例如==事务处理==之类的一些支持模块也是通过Spring AOP来实现的。 AOP不能增强的类： 1. Spring AOP只能对IOC容器中的Bean进行增强，对于不受容器管理的对象不能增强。 2. 由于CGLib采用动态创建子类的方式生成代理对象，所以不能对final修饰的类进行代理。</p> <h2 id="_5、spring-bean的生命周期-高薪常问"><a href="#_5、spring-bean的生命周期-高薪常问" class="header-anchor">#</a> 5、Spring Bean的生命周期?(高薪常问)</h2> <ol><li>Bean 创建：Spring 容器通过读取配置信息并创建 Bean 对象。</li> <li>Bean 初始化：在 Bean 创建完成后，容器将对 Bean 进行初始化，包括对 Bean 进行属性设置、对 Bean 进行任何必要的初始化操作。</li> <li>Bean 调用：容器初始化完成后，开始调用 Bean，执行 Bean 中的业务逻辑。</li> <li>Bean 销毁：当容器关闭时，容器将调用 Bean 的销毁方法，对 Bean 进行清理和回收资源操作。</li></ol> <hr> <p><strong>得分点</strong></p> <ul><li>Spring Bean生命周期的==四大部分==以及详细步骤</li></ul> <p><strong>标准回答</strong></p> <p>Bean 生命周期大致分为 Bean 的<strong>创建</strong>，<strong>初始化</strong>，<strong>调用</strong>，<strong>销毁</strong>4个部分。</p> <p><strong>具体步骤如下</strong></p> <ol><li><p>Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化</p></li> <li><p>Bean实例化后对将Bean的引入和值注入到Bean的属性中</p></li> <li><p>如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法</p></li> <li><p>如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入</p></li> <li><p>如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。</p></li> <li><p>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。</p></li> <li><p>如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用</p></li> <li><p>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。</p></li> <li><p>此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。</p></li> <li><p>如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。</p></li></ol> <p><strong>加分回答</strong></p> <p>这个过程是由Spring容器自动管理的，其中有两个环节我们可以进行干预。 1. 我们可以自定义初始化方法，并在该方法前增加@PostConstruct注解，届时Spring容器将在调用SetBeanFactory方法之后调用该方法。 2. 我们可以自定义销毁方法，并在该方法前增加@PreDestroy注解，届时Spring容器将在自身销毁前，调用这个方法。</p> <blockquote><p>Spring Bean的生命周期包括以下阶段：</p> <ol><li>实例化（Instantiation）：当Spring容器启动时，它会读取配置文件并创建Bean的实例。</li> <li>属性赋值（Populating properties）：Spring容器会通过将属性值或引用注入到Bean中来完成属性赋值。</li> <li>初始化（Initialization）：在所有的属性都被设置之后，Spring容器将调用Bean的初始化方法（如果有定义的话），例如init-method 。</li> <li>使用（Using）：此时Bean已经可以使用了，可以被其他Bean依赖注入或通过ApplicationContext.getBean()方法获取。</li> <li>销毁（Destroying）：当应用程序关闭时，Spring容器将销毁所有的Bean，并调用其销毁方法（如果有定义的话），例如destroy-method。</li></ol></blockquote> <h2 id="_6、spring-支持-bean-的作用域有几种-必会"><a href="#_6、spring-支持-bean-的作用域有几种-必会" class="header-anchor">#</a> 6、Spring 支持 bean 的作用域有几种？(必会)</h2> <p><code>@Scope</code> 用于指定bean的作用范围。</p> <p>在类上使用<code>@Scope</code>注解定义Bean的作用域，Spring支持五种作用域，==后三种在web环境(<code>Spring MVC</code>)才生效==。</p> <p>属性：value 指定范围的取值。常用取值：<code>singleton</code>(单例)和<code>prototype</code>(多例)。</p> <p>Spring支持以下五种bean的作用域：</p> <ol><li><code>singleton</code>：默认作用域，单例模式，在整个应用中，同一个bean只有一个实例存在。</li> <li><code>prototype</code>：原型作用域，每次请求都会创建一个新的bean实例。</li> <li><code>request</code>：请求作用域，在Web应用中，每一次HTTP请求都会创建一个新的bean实例。</li> <li><code>session</code>：会话作用域，在Web应用中，一个用户的一次会话中只会有一个bean实例。</li> <li><code>application</code>：应用作用域，在整个应用中，同一个bean只有一个实例存在。</li></ol> <blockquote><p><code>@Scope</code> 注解默认情况下为单例模式，因此加不加<code>@Scope(&quot;singleton)</code>都是一样的。</p> <p>spring中singleton作用域和application作用域区别</p> <ul><li><code>singleton</code>是 Spring Core 的作⽤域；<code>application</code>是 Spring Web 中的作⽤域；</li> <li><code>singleton</code>作⽤于 <code>IOC</code>的容器，⽽ <code>application</code>作⽤于 <code>Servlet</code>容器。</li></ul></blockquote> <h2 id="_7、beanfactory-和-applicationcontext-区别-了解"><a href="#_7、beanfactory-和-applicationcontext-区别-了解" class="header-anchor">#</a> 7、BeanFactory 和 ApplicationContext 区别(了解)</h2> <p><code>BeanFactory</code>和 <code>ApplicationContext</code>是两个用于==管理 Bean 的容器==。</p> <p><code>Spring</code>框架中<code>ApplicationContext</code>与<code>BeanFactory</code>的区别。其中，<code>BeanFactory</code>为<code>ApplicationContext</code>的父类，是一种继承关系，<code>ApplicationContext</code>的功能要强于<code>BeanFactory</code>。</p> <ol><li><code>BeanFactory</code>: <code>BeanFactory</code>在启动的时候不会去实例化，<code>BeanFactory</code>实现了懒加载，在 Bean 第一次被使用时才会初始化。</li> <li><code>ApplicationContext</code>: 是 <code>BeanFactory</code>的子接口，在 <code>BeanFactory</code>的基础上添加了更多的功能。<code>ApplicationContext</code>实现了 Bean 的预加载，即==在启动容器时已经初始化所有的 Bean==。</li></ol> <p>为了在服务器启动的时候就能把费时的对象创建操作执行完成，在一般使用<code>Spring</code>框架编写程序的时候使用<code>ApplicationContext</code>接口来加载配置文件并创建对象。</p> <blockquote><p>Spring中的bean是由<code>ApplicationContext</code>创建的。 <code>BeanFactory</code>是 Spring IoC 容器的基础接口，而 <code>ApplicationContext</code>是 <code>BeanFactory</code>的子接口，并且提供了更多的高级特性，如消息资源处理、国际化、事件传播、访问上下文、AOP等。因此，通常情况下我们使用的是 <code>ApplicationContext</code>而不是 <code>BeanFactory</code>。</p></blockquote> <h2 id="_8、spring-框架中都用到了哪些设计模式-必会"><a href="#_8、spring-框架中都用到了哪些设计模式-必会" class="header-anchor">#</a> 8、Spring 框架中都用到了哪些设计模式?(必会)</h2> <p>Spring 框架中使用了以下几种设计模式：</p> <ol><li><strong>工厂模式</strong> ： Spring使用工厂模式通过 BeanFactory、ApplicationContext创建 bean 对象。</li> <li><strong>代理模式</strong> ： Spring AOP 功能的实现。</li> <li><strong>单例模式</strong> ： Spring 中的 Bean 默认都是单例的。</li> <li><strong>模板方法模式</strong> ： Spring 中 jdbcTemplate、RestTemplate等以 Template结尾的对数据库操作的类，它们就使用到了模板模式。</li> <li><strong>观察者模式</strong>： Spring 事件驱动模型就是观察者模式很经典的一个应用。</li> <li><strong>包装器设计模式</strong> ： 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li> <li><strong>适配器模式</strong> ：Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。</li></ol> <h2 id="_9、spring-事务的实现方式和实现原理-必会"><a href="#_9、spring-事务的实现方式和实现原理-必会" class="header-anchor">#</a> 9、Spring 事务的实现方式和实现原理(必会)</h2> <p>Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring 是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过 <code>binlog</code>或者 <code>undolog</code>实现的。</p> <p>spring 事务实现主要有两种方法</p> <ol><li><strong>编程式事务管理</strong>，基于 <code>transactionTemplate</code>的声明式事务管理，此种方式是自动的事务管理，无需手动开启、提交、回滚。</li> <li><strong>声明式事务管理</strong>，利用注解 <code>@Transactional</code>或者 <code>aop</code>配置，唯一不足地方是，最细粒度只能作用到==方法级别==，无法做到像==编程式事务==那样可以作用到==代码块级别==。</li></ol> <p>以上的开启事务方式，仅需要了解即可，如今在工作中，一般不会用到这几种方式，过于繁琐。一般都是直接用springboot自带的<code>@Transactional</code> 注解，就可以完成这些事务管理操作。但是如果想知道事务底层的实现原理，以上的几种原始方式，还是可以参考一下的。</p> <h2 id="_10、spring中aop的通知类型有哪些"><a href="#_10、spring中aop的通知类型有哪些" class="header-anchor">#</a> 10、Spring中aop的通知类型有哪些？</h2> <p>通知/增强（Advice）中提供的五中类型（非常重要）：</p> <table><thead><tr><th>通知类型</th> <th>描述</th></tr></thead> <tbody><tr><td>前置通知(<code>@Before</code>)</td> <td>在我们执行目标方法之前运行</td></tr> <tr><td>返回通知(<code>@AfterReturning</code>)</td> <td>在我们的目标方法正常返回值后运行</td></tr> <tr><td>异常通知(<code>@AfterThrowing</code>)</td> <td>在我们的目标方法出现异常后运行</td></tr> <tr><td>后置通知(<code>@After</code>)</td> <td>在我们目标方法运行结束之后 ，不管有没有异常</td></tr> <tr><td>环绕通知(<code>@Around</code>)</td> <td>功能最为强大的通知，能在方法调用前后自定义一些操作</td></tr></tbody></table> <p>通知的执行顺序可以根据下面的代码模型判断</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 通知的执行以及顺序</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 前置通知	@Before</span>
    <span class="token comment">// 目标方法</span>
    <span class="token comment">// 返回通知	@AfterReturning</span>
<span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 异常通知	@AfterThrowing</span>
<span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token punctuation">{</span>
    <span class="token comment">// 后置通知	@After</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>目标方法执行没有异常时，以下三个通知生效</p> <p><code>@Before</code>、<code>@After</code>、<code>@AfterReturning</code></p> <p>目标方法执行出现异常时，以下三个通知生效 <code>@Before</code>、<code>@After</code>、<code>@AfterThrowing</code></p> <p><strong>通知的执行顺序</strong></p> <p>当有多个切面的通知方法都被执行时，它们的执行顺序是怎样的呢？</p> <ul><li>默认按照 bean 的名称字母排序</li> <li>用 <code>@Order</code>(数字)加在==切面类==上来控制顺序，==数字越小，优先级越高==，没有加数字的默认为<code>int</code>的最大值</li></ul> <h2 id="_11、spring-的对象默认是单例的还是多例的-单例-bean-存不存在线程安全问题呢-必会"><a href="#_11、spring-的对象默认是单例的还是多例的-单例-bean-存不存在线程安全问题呢-必会" class="header-anchor">#</a> 11、Spring 的对象默认是单例的还是多例的?单例 bean 存不存在线程安全问题呢?(必会)</h2> <p>在 spring 中的对象默认是单例的，但是也可以配置为多例。</p> <hr> <p>单例 bean 对象对应的类<strong>如果存在可变的成员变量</strong>并且其中存在改变这个变量的线程时，多线程操作该 bean 对象时会出现线程安全问题。但是<strong>如果该bean对象是无状态的</strong>，那么在多线程环境中是安全的。</p> <p><strong>如何处理Spring Bean的线程安全问题</strong></p> <p>方法1：将<code>scope</code>的模式改为<code>prototype</code>，也就是将Bean的作用域由单例改为多例模式。</p> <p>方法2： 在 bean 对象中==避免定义可变成员变量==；</p> <p>方法3：在类中定义 <code>ThreadLocal</code> 的成员变量，并将需要的可变成员变量保存在 <code>ThreadLocal</code> 中</p> <p><code>ThreadLocal</code> 本身就具备线程隔离的特性，这就相当于为每个线程提供了一个独立的变量副本，每个线程只需要操作自己的线程副本变量，从而解决线程安全问题。</p> <hr> <p><strong>任何无状态单例都是线程安全的</strong>。</p> <p>Spring 的根本就是通过大量这种单例构建起系统，以事务脚本的方式提供服务。</p> <blockquote><p>问题：对于<code>@Controller</code>，<code>@Service</code>等注解如果在类中加了<code>@Scope</code>注解改为<code>prototype</code>模式是否一定是线程安全的呢？</p> <p>不一定，在 <code>@Controller</code>/<code>@Service</code> 等容器中定义<strong>静态变量</strong>，不论是单例 (singleton) 还是多实例 (prototype) 都是线程不安全的。</p></blockquote> <hr> <h2 id="_12、-resource-和-autowired-依赖注入的区别是什么-qualifier-使用场景是什么-了解"><a href="#_12、-resource-和-autowired-依赖注入的区别是什么-qualifier-使用场景是什么-了解" class="header-anchor">#</a> 12、@Resource 和@Autowired 依赖注入的区别是什么?@Qualifier 使用场景是什么?(了解)</h2> <p><code>@Resource</code>和<code>@Autowired</code>都是用于依赖注入的注解。</p> <p><code>@Resource</code><strong>默认按照名称进行装配</strong>，==当找不到与名称匹配的 bean 时，才会按类型进行装配==。可以通过 <code>name</code>属性指定 bean 的名称。</p> <p><code>@Autowired</code><strong>默认按类型进行装配</strong>，==当找不到与类型匹配的 bean 时，才会按照名称进行装配==。也可以通过 <code>@Qualifier</code>注解指定装配的 bean 名称。</p> <p><code>@Qualifier</code>注解通常与<code>@Autowired</code>一起使用，用来指定装配 bean 的名称。</p> <blockquote><p><code>@Qualifier</code>不能单独使用，它必须和其他注解一起使用，通常配合<code>@Autowired</code>一起使用，用来解决某种类型的多个实现的情况。</p></blockquote> <p>例如：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">&quot;userDaoImpl&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">UserDao</span> userDao<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>假设在 Spring 容器中存在多个实现了 <code>UserDao</code>接口的类，而且它们的类名都以大写字母开头，为了指定装配名为 <code>userDaoImpl</code>的 <code>UserDao</code>类型的 bean，可以使用 <code>@Qualifier</code> 注解和 <code>@Autowired</code> 注解结合使用。</p> <p>这样就指定了装配名为 <code>userDaoImpl</code> 的 <code>UserDao</code> 类型的 bean。</p> <p>000</p> <h2 id="spring事务-4种特性、7种传播行为-5种隔离级别"><a href="#spring事务-4种特性、7种传播行为-5种隔离级别" class="header-anchor">#</a> Spring事务（4种特性、7种传播行为，5种隔离级别）</h2> <h2 id="_13、spring-的7种事务传播行为-高薪常问"><a href="#_13、spring-的7种事务传播行为-高薪常问" class="header-anchor">#</a> 13、Spring 的7种事务传播行为(高薪常问)</h2> <p>在Spring中对于事务的传播行为定义了七种类型分别是：</p> <p>备注(方便记忆)：</p> <p>propagation 传播 		require 必须的			suppor 支持			mandatory [ˈmændətɔːri] 强制性的</p> <p>requires-new 需要新建			not-supported 不支持			never 从不			nested 嵌套的</p> <ol><li><code>PROPAGATION_REQUIRED</code>: 如果当前存在事务，则加入该事务；如果当前==没有==事务，则==创建一个新的事务==。</li> <li><code>PROPAGATION_SUPPORTS</code>: 如果当前存在事务，则加入该事务；如果当前==没有==事务，则==以非事务方式执行==。</li> <li><code>PROPAGATION_MANDATORY</code>: 如果当前存在事务，则加入该事务；如果当前没有事务，则==抛出异常==。</li> <li><code>PROPAGATION_REQUIRES_NEW</code>: 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li> <li><code>PROPAGATION_NOT_SUPPORTED</code>: 以==非事务==方式执行操作，如果当前==存在==事务，则把当前事务挂起。</li> <li><code>PROPAGATION_NEVER</code>: 以==非事务==方式执行，如果当前==存在==事务，则==抛出异常==。</li> <li><code>PROPAGATION_NESTED</code>: 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来进行。</li></ol> <blockquote><p><code>@Transactional</code>默认的事务传播行为是<code>PROPAGATION_REQUIRED</code>。这意味着如果当前存在事务，则该方法必须在该事务中运行；如果不存在事务，则新启动一个事务。</p></blockquote> <h2 id="_14、spring中事务的4大特征"><a href="#_14、spring中事务的4大特征" class="header-anchor">#</a> 14、Spring中事务的4大特征</h2> <p>事务有四大特性（ACID）：</p> <p><strong>原子性（Atomicity）：</strong> ==一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节==。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</p> <p><strong>一致性（Consistency）：</strong> ==在事务开始之前和事务结束以后，数据库的完整性没有被破坏==。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。例如，转账前A、B共5000元，A、B之间转账后，两者之和仍应该是5000元。</p> <p><strong>隔离性（Isolation）：</strong> 数据库允许多个并发事务同时对其数据进行读写和修改，==隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致==。事务隔离分为不同级别，包括未提交读（Read Uncommitted）、提交读（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。</p> <p><strong>持久性（Durability）:</strong> 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p> <h2 id="_15、spring-中的5大隔离级别-高薪常问"><a href="#_15、spring-中的5大隔离级别-高薪常问" class="header-anchor">#</a> 15、Spring 中的5大隔离级别(高薪常问)</h2> <table><thead><tr><th>隔离级别</th> <th>含义</th></tr></thead> <tbody><tr><td>ISOLATION_DEFAULT<br><strong>默认隔离</strong></td> <td>使用后端数据库默认的隔离级别</td></tr> <tr><td>ISOLATION_READ_UNCOMMITTED<br><strong>读未提交</strong></td> <td>最低的隔离级别，==允许读取尚未提交的数据变更==，可能会导致脏读、幻读或不可重复读</td></tr> <tr><td>ISOLATION_READ_COMMITTED<br><strong>读已提交</strong></td> <td>==允许读取并发事务已经提交的数据==，==可以阻止脏读==，但是幻读或不可重复读仍有可能发生</td></tr> <tr><td>ISOLATION_REPEATABLE_READ<br><strong>可重复读</strong></td> <td>==对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改==，==可以阻止脏读和不可重复读==，但幻读仍有可能发生</td></tr> <tr><td>ISOLATION_SERIALIZABLE<br><strong>串行化</strong></td> <td>最高的隔离级别，完全服从ACID的隔离级别，确保==阻止脏读、不可重复读以及幻读，也是最慢的事务隔离级别==，因为它通常是通过完全锁定事务相关的数据库表来实现的</td></tr></tbody></table> <blockquote><ol><li><strong>脏读</strong>（Dirty reads）——脏读发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的。</li> <li><strong>不可重复读</strong>（Nonrepeatable read）——不可重复读发生在一个事务执行相同的查询两次或两次以上，但是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间进行了更新。</li> <li><strong>幻读</strong>（Phantom read）——幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录。</li></ol></blockquote> <h2 id="_16、事务失效问题"><a href="#_16、事务失效问题" class="header-anchor">#</a> 16、事务失效问题</h2> <p>这个主要是针对声明式事务的，声明式事务底层其实就是 AOP，实际上就是一个AOP失效的问题</p> <p>Spring事务失效场景：</p> <ol><li><p><strong>数据库引擎不支持事务</strong>，比如<code>MyISAM</code></p></li> <li><p><strong>方法不是<code>public</code></strong>，这一点由Spring的AOP特性决定的，理论上而言，不public也能切入，但spring可能是觉得private自己用的方法，应该自己控制，不应该用事务切进去吧）。另外<code>private</code>方法, <code>final</code>方法 和 <code>static</code>方法不能添加事务，加了也不生效</p></li> <li><p><strong>出现非运行时异常</strong>，Spring事务默认只有抛出运行时异常（即 RuntimeException 及子类）或 Error 及子类时，才会回滚事务，如果抛出的是其它编译时异常，仍然会提交事务。</p> <p>解决办法：<em>配置 <code>rollbackFor = Exception.class</code></em></p></li> <li><p><strong>捕捉异常导致事务失效</strong>，如果代理对象不知道出现了异常，也就没有机会去执行回滚，自己 try-catch异常，意味着代理对象认为没有发生异常，因此也会提交事务。所以我们应该将捕获的异常抛出</p></li> <li><p><strong>同一个类中调用事务方法</strong>，<code>@Transactional</code>的事务开启 ，或者是基于接口的 或者是基于类的代理被创建。所以 ==在同一个类中一个无事务的方法调用另一个有事务的方法，事务是不会起作用的。==</p></li> <li><p><strong>操作事务的类/对象没有被Spring管理</strong>，使用spring事务的前提是对象要被spring管理。</p></li></ol> <p><img src="https://image.z.itpub.net/zitpub.net/JPG/2021-09-18/8CEF7F469B3856928EF1A723D6A7BCA4.jpg" alt="img"></p> <h2 id="_17、springboot自动装配原理"><a href="#_17、springboot自动装配原理" class="header-anchor">#</a> 17、SpringBoot自动装配原理</h2> <ol><li><p>在Spring Boot项目中的引导类上有一个注解<code>@SpringBootApplication</code>，这个注解是对三个注解进行了封装，分别是：</p> <ul><li><p><code>@SpringBootConfiguration</code></p></li> <li><p><code>@EnableAutoConfiguration</code></p></li> <li><p><code>@ComponentScan</code></p></li></ul> <p>其中<code>@EnableAutoConfiguration</code>是实现自动化配置的核心注解。</p> <p>该注解通过<code>@Import</code>注解导入对应的配置选择器。关键的是内部就是读取了该项目和该项目引用的Jar包的的classpath路径下<strong>META-INF/spring.factories</strong>文件中的所配置的类的全类名。</p> <p>在这些配置类中所定义的Bean会根据条件注解所<strong>指定的条件来决定</strong>是否需要将其导入到Spring容器中。</p> <p>一般条件判断会有像<code>@ConditionalOnClass</code>这样的注解，判断是否有对应的class文件，如果有则加载该类，把这个配置类的所有的Bean放入spring容器中使用。</p></li></ol> <hr> <p><code>@SpringBootApplication</code>的本质是一个组合注解，主要包含3个注解：</p> <ul><li><p><code>@SpringBootConfiguration</code>（里面就是<code>@Configuration</code>，标注当前类为配置类，其实只是做了一层封装改了个名字而已）</p></li> <li><p><code>@EnableAutoConfiguration</code>（开启自动导入配置）(可以扫描到不在启动类所在包及其子包下面的配置类)</p> <ul><li><strong>自动配置包必须在<code>META-INF</code>目录中提供一个<code>spring.factories</code>文件</strong>，文件中定义所有需要加载的配置类的全类名，用逗号隔开。</li> <li><code>spring.factories</code>文件中的key是固定的：<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code></li></ul> <p>在引导类上使用<code>@Import</code>注解导入配置类，并从Spring容器中获取，<code>@Import({A.class, B.class})</code> 导入指定名称的配置类</p></li> <li><p><code>@ComponentScan</code>（包扫描）定义要扫描的特定包。 如果没有定义特定的包，将从声明该注解的类的所在包及其子包。</p></li></ul> <h2 id="_18、什么是spring的循环依赖-如何解决循环依赖"><a href="#_18、什么是spring的循环依赖-如何解决循环依赖" class="header-anchor">#</a> 18、什么是Spring的循环依赖？如何解决循环依赖？</h2> <p>简单的来说就是A依赖B的同时，B依赖A。在创建A对象的同时需要使用的B对象，在创建B对象的同时需要使用到A对象。如下代码所示：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;A的构造方法执行了...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token class-name">B</span> b<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setB</span><span class="token punctuation">(</span><span class="token class-name">B</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;给A注入B&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;B的构造方法执行了...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token class-name">A</span> a<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setA</span><span class="token punctuation">(</span><span class="token class-name">A</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;给B注入了A&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>解决方案：使用<code>@Lazy</code>注解</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>

    <span class="token comment">// B成员变量</span>
    <span class="token keyword">private</span> <span class="token class-name">B</span> b<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Lazy</span> <span class="token class-name">B</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;A的构造方法执行了...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在构造参数前面加了<code>@Lazy</code>注解之后, 就不会真正的注入真实对象, 该注入对象会被延迟加载 ， 此时注入的是一个代理对象 。</p> <h2 id="_19、spring-mvc中的拦截器和servlet中的filter有什么区别"><a href="#_19、spring-mvc中的拦截器和servlet中的filter有什么区别" class="header-anchor">#</a> 19、Spring MVC中的拦截器和Servlet中的filter有什么区别？</h2> <p><a href="https://blog.csdn.net/xinzhifu1/article/details/106356958" target="_blank" rel="noopener noreferrer">拦截器和过滤器的区别<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li>归属不同： <code>Filter</code>属于<code>Servlet</code>技术，<code>Interceptor</code>属于<code>SpringMVC</code>技术</li> <li>执行顺序不同：先执行过滤器，后执行拦截器</li> <li>拦截内容不同： <code>Filter</code>是拦截请求和响应的，<code>Interceptor</code> 拦截访问处理器中的方法，也就是拦截Controller中的方法 调用。</li> <li>实现原理不同：<code>Filter</code> 是基于函数回调的，<code>Interceptor</code> 则是基于Java的反射机制 (AOP动态代理) 实现的</li> <li>拦截的请求范围不同：<code>Filter</code>几乎可以对所有进入容器的请求起作用，而<code>Interceptor</code>只会对<code>Controller</code>中请求或访问<code>static</code>目录下的资源请求起作用。</li></ul> <p>详细内容查看<a href="https://blog.csdn.net/xinzhifu1/article/details/106356958" target="_blank" rel="noopener noreferrer">原文地址<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <hr> <p>拦截器和过滤器是用于在web应用程序中实现请求和响应的处理和控制的两种机制。它们的作用相似，但是有一些区别。</p> <p><strong>位置不同</strong>：</p> <p>过滤器(Filter)是在 Servlet 容器内部执行的，它在客户端请求访问目标资源之前拦截，对请求和响应进行处理；而拦截器(Interceptor)是在 SpringMVC 执行链的处理方法之前或之后执行的，它在客户端请求访问目标资源之后拦截，对控制器方法的调用进行处理。</p> <p><strong>作用对象不同</strong>：</p> <p>过滤器(Filter)的作用对象是 Servlet 容器所管理的 web 资源，包括 JSP、静态文件等等，主要用于校验用户输入参数、管理 session 和 cookie、执行 XSS 过滤、日志记录等；而拦截器(Interceptor)的作用对象是 SpringMVC 框架中的控制器(Controller)，它主要用于检查用户认证信息、处理业务逻辑等。</p> <p><strong>工作方式不同</strong>：</p> <p>过滤器(Filter)是通过回调函数实现的，实现了 Servlet 中的 <code>Filter</code> 接口，它的实现类是由容器调用的；而拦截器(Interceptor)是使用 AOP 实现的，拦截器实现类由 SpringMVC 框架调用。</p> <p><strong>依赖框架不同</strong>：</p> <p>过滤器(Filter)是 Servlet 规范的一部分，它是与 Web 容器绑定的，所以可以在任何 Java Web 项目中使用；而拦截器(Interceptor)是 Spring 框架的一部分，所以只有在使用 SpringMVC 框架时才可以使用。</p> <p>综上所述，过滤器和拦截器都是用于在web应用程序中实现请求和响应的处理和控制的机制，但是它们的作用对象、位置、工作方式和依赖框架等方面有所不同。</p> <h2 id="_20、springmvc的执行流程"><a href="#_20、springmvc的执行流程" class="header-anchor">#</a> 20、SpringMVC的执行流程</h2> <p>Spring MVC 的三大组件</p> <ul><li><strong>处理器映射器</strong> <code>HandlerMapping</code>：解析Controller中的路径，和我们客户端的路径进行匹配，找到要访问的Controller中的方法</li> <li><strong>处理器适配器</strong> <code>HandlerAdapter</code>：负责去调用Controller中的对应的方法，执行该方法，将结果封装成ModelAndView对象。</li> <li><strong>视图解析器</strong> <code>ViewResolver</code>：负责解析ModelAndView对象中的数据和页面，最终告诉前端控制器去响应。</li></ul> <p>SpringMVC的执行流程图如下</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20230219224112834.png" alt="image-20230219224112834"></p> <hr> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20221128101807670.png" alt="image-20221128101807670"></p> <hr> <p>1、用户发送出请求到前端控制器DispatcherServlet。</p> <p>2、DispatcherServlet收到请求调用HandlerMapping（处理器映射器）。</p> <p>3、HandlerMapping找到具体的处理器(可查找xml配置或注解配置)，生成处理器对象及处理器拦截器(如果有)，再一起返回给DispatcherServlet。</p> <p>4、DispatcherServlet调用HandlerAdapter（处理器适配器）。</p> <p>5、HandlerAdapter经过适配调用具体的处理器（Handler/Controller）。</p> <hr> <p>6、Controller执行完成返回ModelAndView对象。</p> <p>7、HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet。</p> <p>8、DispatcherServlet将ModelAndView传给ViewReslover（视图解析器）。</p> <p>9、ViewReslover解析后返回具体View（视图）。</p> <p>10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</p> <p>11、DispatcherServlet响应用户。</p> <p>当然现在的开发，基本都是前后端分离的开发的，并没有视图这些，一般都是handler中使用Response直接结果返回</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新时间:</span> <span class="time">2023/10/29</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Java面试题/Mybatis面试题/Mybatis面试题.html" class="prev">
        Mybatis面试题
      </a></span> <span class="next"><a href="/Java面试题/SpringBoot面试题/SpringBoot面试题补充.html">
        SpringBoot面试题补充
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a19eb3cb.js" defer></script><script src="/assets/js/2.34fff606.js" defer></script><script src="/assets/js/1.16393a26.js" defer></script><script src="/assets/js/62.11484b5e.js" defer></script>
  </body>
</html>
