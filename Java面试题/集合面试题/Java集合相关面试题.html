<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java集合相关面试题 | 周岐的个人博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="logo.jpg">
    <meta name="description" content="个人技术博客">
    
    <link rel="preload" href="/assets/css/0.styles.8c53e149.css" as="style"><link rel="preload" href="/assets/js/app.a19eb3cb.js" as="script"><link rel="preload" href="/assets/js/2.34fff606.js" as="script"><link rel="preload" href="/assets/js/1.16393a26.js" as="script"><link rel="preload" href="/assets/js/72.fa131834.js" as="script"><link rel="prefetch" href="/assets/js/10.717bd423.js"><link rel="prefetch" href="/assets/js/100.c5cd47b0.js"><link rel="prefetch" href="/assets/js/101.7151b423.js"><link rel="prefetch" href="/assets/js/102.6b36385a.js"><link rel="prefetch" href="/assets/js/103.d3861779.js"><link rel="prefetch" href="/assets/js/104.9578b311.js"><link rel="prefetch" href="/assets/js/105.aae477dc.js"><link rel="prefetch" href="/assets/js/106.1d5215a7.js"><link rel="prefetch" href="/assets/js/107.3c330c2f.js"><link rel="prefetch" href="/assets/js/108.cefc2802.js"><link rel="prefetch" href="/assets/js/109.541aa22e.js"><link rel="prefetch" href="/assets/js/11.e0bfb9a4.js"><link rel="prefetch" href="/assets/js/110.60e0b929.js"><link rel="prefetch" href="/assets/js/111.45058523.js"><link rel="prefetch" href="/assets/js/112.d10d50d0.js"><link rel="prefetch" href="/assets/js/113.4a3deb35.js"><link rel="prefetch" href="/assets/js/114.b917d1a1.js"><link rel="prefetch" href="/assets/js/115.50e3fa0f.js"><link rel="prefetch" href="/assets/js/116.78f04bf7.js"><link rel="prefetch" href="/assets/js/117.b5372645.js"><link rel="prefetch" href="/assets/js/118.f990eb5b.js"><link rel="prefetch" href="/assets/js/119.f178eabd.js"><link rel="prefetch" href="/assets/js/12.bdf46c02.js"><link rel="prefetch" href="/assets/js/120.d98a3aa8.js"><link rel="prefetch" href="/assets/js/121.abcdf60f.js"><link rel="prefetch" href="/assets/js/122.ed3550a9.js"><link rel="prefetch" href="/assets/js/123.8ef421f8.js"><link rel="prefetch" href="/assets/js/124.1adba2c7.js"><link rel="prefetch" href="/assets/js/125.6706c196.js"><link rel="prefetch" href="/assets/js/126.1e50c7b4.js"><link rel="prefetch" href="/assets/js/127.be9df6e0.js"><link rel="prefetch" href="/assets/js/128.9e68fe60.js"><link rel="prefetch" href="/assets/js/129.f9313e6a.js"><link rel="prefetch" href="/assets/js/13.05b00624.js"><link rel="prefetch" href="/assets/js/130.87d4d918.js"><link rel="prefetch" href="/assets/js/131.b7ab0bc3.js"><link rel="prefetch" href="/assets/js/132.4bf1103a.js"><link rel="prefetch" href="/assets/js/133.2bda9aa2.js"><link rel="prefetch" href="/assets/js/134.e6631028.js"><link rel="prefetch" href="/assets/js/135.5b78aed3.js"><link rel="prefetch" href="/assets/js/136.377fd687.js"><link rel="prefetch" href="/assets/js/137.623e1a9d.js"><link rel="prefetch" href="/assets/js/138.c2e1c9a1.js"><link rel="prefetch" href="/assets/js/139.6263f657.js"><link rel="prefetch" href="/assets/js/14.092a5584.js"><link rel="prefetch" href="/assets/js/140.a54c064d.js"><link rel="prefetch" href="/assets/js/141.0de2ed45.js"><link rel="prefetch" href="/assets/js/142.61ea0663.js"><link rel="prefetch" href="/assets/js/143.24d35022.js"><link rel="prefetch" href="/assets/js/144.196d7653.js"><link rel="prefetch" href="/assets/js/145.223f0fcf.js"><link rel="prefetch" href="/assets/js/146.a09f8d1b.js"><link rel="prefetch" href="/assets/js/147.62d69c7c.js"><link rel="prefetch" href="/assets/js/148.d46a05d0.js"><link rel="prefetch" href="/assets/js/149.467faf3d.js"><link rel="prefetch" href="/assets/js/15.758ee11b.js"><link rel="prefetch" href="/assets/js/150.0443932e.js"><link rel="prefetch" href="/assets/js/151.0879c074.js"><link rel="prefetch" href="/assets/js/152.4d08f8a9.js"><link rel="prefetch" href="/assets/js/153.ce46c4fa.js"><link rel="prefetch" href="/assets/js/154.fd65dd72.js"><link rel="prefetch" href="/assets/js/155.b975728f.js"><link rel="prefetch" href="/assets/js/156.61194924.js"><link rel="prefetch" href="/assets/js/157.97e4f54e.js"><link rel="prefetch" href="/assets/js/158.5290a2f0.js"><link rel="prefetch" href="/assets/js/159.3613e64b.js"><link rel="prefetch" href="/assets/js/16.2569be64.js"><link rel="prefetch" href="/assets/js/160.87d90e6b.js"><link rel="prefetch" href="/assets/js/161.a2a67f25.js"><link rel="prefetch" href="/assets/js/162.b51ccce1.js"><link rel="prefetch" href="/assets/js/163.85d33d23.js"><link rel="prefetch" href="/assets/js/164.5504b77f.js"><link rel="prefetch" href="/assets/js/165.be283131.js"><link rel="prefetch" href="/assets/js/166.8d0352c5.js"><link rel="prefetch" href="/assets/js/167.89c23a71.js"><link rel="prefetch" href="/assets/js/168.aa736b2c.js"><link rel="prefetch" href="/assets/js/169.296ccc1d.js"><link rel="prefetch" href="/assets/js/17.5b873df7.js"><link rel="prefetch" href="/assets/js/170.c706da49.js"><link rel="prefetch" href="/assets/js/171.6f79aeb1.js"><link rel="prefetch" href="/assets/js/172.ddcae302.js"><link rel="prefetch" href="/assets/js/173.f308eb43.js"><link rel="prefetch" href="/assets/js/174.b5ece966.js"><link rel="prefetch" href="/assets/js/175.538e3125.js"><link rel="prefetch" href="/assets/js/176.d54091dd.js"><link rel="prefetch" href="/assets/js/177.2ee0aa3d.js"><link rel="prefetch" href="/assets/js/178.667b3c59.js"><link rel="prefetch" href="/assets/js/179.07595c3e.js"><link rel="prefetch" href="/assets/js/18.4c170722.js"><link rel="prefetch" href="/assets/js/180.300e0b70.js"><link rel="prefetch" href="/assets/js/181.89473dcd.js"><link rel="prefetch" href="/assets/js/182.ea6036d1.js"><link rel="prefetch" href="/assets/js/183.647f8d55.js"><link rel="prefetch" href="/assets/js/184.2e79dd55.js"><link rel="prefetch" href="/assets/js/185.bf4d6269.js"><link rel="prefetch" href="/assets/js/186.7a7ceaa7.js"><link rel="prefetch" href="/assets/js/187.09bb0f21.js"><link rel="prefetch" href="/assets/js/188.3604ce73.js"><link rel="prefetch" href="/assets/js/189.49b47b33.js"><link rel="prefetch" href="/assets/js/19.a45744ea.js"><link rel="prefetch" href="/assets/js/190.88e59ff4.js"><link rel="prefetch" href="/assets/js/191.a4b3e5c7.js"><link rel="prefetch" href="/assets/js/192.7527e6ed.js"><link rel="prefetch" href="/assets/js/193.c44a652d.js"><link rel="prefetch" href="/assets/js/194.6aaca2ce.js"><link rel="prefetch" href="/assets/js/195.64837df2.js"><link rel="prefetch" href="/assets/js/196.e1bd3d69.js"><link rel="prefetch" href="/assets/js/197.2b01de81.js"><link rel="prefetch" href="/assets/js/198.d1496fd2.js"><link rel="prefetch" href="/assets/js/199.27ab1442.js"><link rel="prefetch" href="/assets/js/20.4cb27e25.js"><link rel="prefetch" href="/assets/js/200.996d49f4.js"><link rel="prefetch" href="/assets/js/201.b71a4422.js"><link rel="prefetch" href="/assets/js/202.0ea49eaa.js"><link rel="prefetch" href="/assets/js/203.8ebb1f77.js"><link rel="prefetch" href="/assets/js/204.c8d10533.js"><link rel="prefetch" href="/assets/js/205.0b8c4d0d.js"><link rel="prefetch" href="/assets/js/206.cce9bcce.js"><link rel="prefetch" href="/assets/js/207.8130e9ba.js"><link rel="prefetch" href="/assets/js/208.871753be.js"><link rel="prefetch" href="/assets/js/209.757eda19.js"><link rel="prefetch" href="/assets/js/21.445690e6.js"><link rel="prefetch" href="/assets/js/210.983cae1d.js"><link rel="prefetch" href="/assets/js/211.8e4ddaf8.js"><link rel="prefetch" href="/assets/js/212.6412fc61.js"><link rel="prefetch" href="/assets/js/213.656a6a73.js"><link rel="prefetch" href="/assets/js/214.befcd199.js"><link rel="prefetch" href="/assets/js/215.2c292e81.js"><link rel="prefetch" href="/assets/js/216.78cc7e8b.js"><link rel="prefetch" href="/assets/js/217.4fa8b1da.js"><link rel="prefetch" href="/assets/js/218.4c8cce7c.js"><link rel="prefetch" href="/assets/js/219.d041d013.js"><link rel="prefetch" href="/assets/js/22.bc7c4cdb.js"><link rel="prefetch" href="/assets/js/220.10a9ed88.js"><link rel="prefetch" href="/assets/js/221.bc25f391.js"><link rel="prefetch" href="/assets/js/222.dfdd15b7.js"><link rel="prefetch" href="/assets/js/223.1afa90d8.js"><link rel="prefetch" href="/assets/js/224.69bb037f.js"><link rel="prefetch" href="/assets/js/225.94590311.js"><link rel="prefetch" href="/assets/js/226.d1818961.js"><link rel="prefetch" href="/assets/js/227.2a969459.js"><link rel="prefetch" href="/assets/js/228.e3f5706b.js"><link rel="prefetch" href="/assets/js/229.0e6df830.js"><link rel="prefetch" href="/assets/js/23.b7994ecf.js"><link rel="prefetch" href="/assets/js/230.6bc93aa6.js"><link rel="prefetch" href="/assets/js/231.9b7cc0ec.js"><link rel="prefetch" href="/assets/js/232.80b7488d.js"><link rel="prefetch" href="/assets/js/233.302790de.js"><link rel="prefetch" href="/assets/js/234.68b70723.js"><link rel="prefetch" href="/assets/js/235.1b3c3110.js"><link rel="prefetch" href="/assets/js/236.e536b7bb.js"><link rel="prefetch" href="/assets/js/237.cca351a3.js"><link rel="prefetch" href="/assets/js/238.f4d0edb0.js"><link rel="prefetch" href="/assets/js/239.4f57e73d.js"><link rel="prefetch" href="/assets/js/24.26e26a07.js"><link rel="prefetch" href="/assets/js/240.1e76f670.js"><link rel="prefetch" href="/assets/js/241.8795d427.js"><link rel="prefetch" href="/assets/js/242.c72205cb.js"><link rel="prefetch" href="/assets/js/243.d7105431.js"><link rel="prefetch" href="/assets/js/244.361b2ea5.js"><link rel="prefetch" href="/assets/js/245.055fa0a3.js"><link rel="prefetch" href="/assets/js/246.0dee7b05.js"><link rel="prefetch" href="/assets/js/247.c13fc7d7.js"><link rel="prefetch" href="/assets/js/248.4e481dba.js"><link rel="prefetch" href="/assets/js/25.626c2c33.js"><link rel="prefetch" href="/assets/js/26.c4aa6beb.js"><link rel="prefetch" href="/assets/js/27.b1a828b7.js"><link rel="prefetch" href="/assets/js/28.f9133ade.js"><link rel="prefetch" href="/assets/js/29.54e09df1.js"><link rel="prefetch" href="/assets/js/3.4db2e19a.js"><link rel="prefetch" href="/assets/js/30.d2654359.js"><link rel="prefetch" href="/assets/js/31.c57cf20e.js"><link rel="prefetch" href="/assets/js/32.ed5593a9.js"><link rel="prefetch" href="/assets/js/33.05f050d1.js"><link rel="prefetch" href="/assets/js/34.6d7f5b2f.js"><link rel="prefetch" href="/assets/js/35.67cc577c.js"><link rel="prefetch" href="/assets/js/36.0bbc204a.js"><link rel="prefetch" href="/assets/js/37.8ac35368.js"><link rel="prefetch" href="/assets/js/38.50bd8dba.js"><link rel="prefetch" href="/assets/js/39.38b783ce.js"><link rel="prefetch" href="/assets/js/4.66c035fd.js"><link rel="prefetch" href="/assets/js/40.cd3ee2ff.js"><link rel="prefetch" href="/assets/js/41.f4bec9a4.js"><link rel="prefetch" href="/assets/js/42.27fa7fec.js"><link rel="prefetch" href="/assets/js/43.2af4a015.js"><link rel="prefetch" href="/assets/js/44.8e48aaf4.js"><link rel="prefetch" href="/assets/js/45.d41c0319.js"><link rel="prefetch" href="/assets/js/46.de5cb880.js"><link rel="prefetch" href="/assets/js/47.cc7c8048.js"><link rel="prefetch" href="/assets/js/48.22c69558.js"><link rel="prefetch" href="/assets/js/49.cdd62276.js"><link rel="prefetch" href="/assets/js/5.632744e8.js"><link rel="prefetch" href="/assets/js/50.a7eebe42.js"><link rel="prefetch" href="/assets/js/51.a447aa90.js"><link rel="prefetch" href="/assets/js/52.c0f076a5.js"><link rel="prefetch" href="/assets/js/53.3564c5b0.js"><link rel="prefetch" href="/assets/js/54.c5c6e6be.js"><link rel="prefetch" href="/assets/js/55.0fcb916b.js"><link rel="prefetch" href="/assets/js/56.2812bd7d.js"><link rel="prefetch" href="/assets/js/57.4f95d22a.js"><link rel="prefetch" href="/assets/js/58.d9baba05.js"><link rel="prefetch" href="/assets/js/59.371bd0d7.js"><link rel="prefetch" href="/assets/js/6.85f26be6.js"><link rel="prefetch" href="/assets/js/60.a715876a.js"><link rel="prefetch" href="/assets/js/61.6b1a782b.js"><link rel="prefetch" href="/assets/js/62.11484b5e.js"><link rel="prefetch" href="/assets/js/63.7b92573e.js"><link rel="prefetch" href="/assets/js/64.98aee69e.js"><link rel="prefetch" href="/assets/js/65.aa40eacd.js"><link rel="prefetch" href="/assets/js/66.67703170.js"><link rel="prefetch" href="/assets/js/67.392b86af.js"><link rel="prefetch" href="/assets/js/68.9610b8e9.js"><link rel="prefetch" href="/assets/js/69.6277fc7a.js"><link rel="prefetch" href="/assets/js/7.b775b056.js"><link rel="prefetch" href="/assets/js/70.b47adb04.js"><link rel="prefetch" href="/assets/js/71.0051199b.js"><link rel="prefetch" href="/assets/js/73.fd8d275f.js"><link rel="prefetch" href="/assets/js/74.82095aed.js"><link rel="prefetch" href="/assets/js/75.41fad4ea.js"><link rel="prefetch" href="/assets/js/76.36bb1714.js"><link rel="prefetch" href="/assets/js/77.83c409c1.js"><link rel="prefetch" href="/assets/js/78.ca197ebf.js"><link rel="prefetch" href="/assets/js/79.9f0de524.js"><link rel="prefetch" href="/assets/js/80.7dd0f8a1.js"><link rel="prefetch" href="/assets/js/81.a5d44424.js"><link rel="prefetch" href="/assets/js/82.03d59f96.js"><link rel="prefetch" href="/assets/js/83.43da9399.js"><link rel="prefetch" href="/assets/js/84.e9ab171d.js"><link rel="prefetch" href="/assets/js/85.523fe07f.js"><link rel="prefetch" href="/assets/js/86.90aac9c6.js"><link rel="prefetch" href="/assets/js/87.1af6082d.js"><link rel="prefetch" href="/assets/js/88.3d7d10f0.js"><link rel="prefetch" href="/assets/js/89.69f4fbaf.js"><link rel="prefetch" href="/assets/js/90.30407e67.js"><link rel="prefetch" href="/assets/js/91.94355f67.js"><link rel="prefetch" href="/assets/js/92.8247a2fb.js"><link rel="prefetch" href="/assets/js/93.245ee436.js"><link rel="prefetch" href="/assets/js/94.a212b15e.js"><link rel="prefetch" href="/assets/js/95.dec85448.js"><link rel="prefetch" href="/assets/js/96.77ebb7ae.js"><link rel="prefetch" href="/assets/js/97.0a615ee3.js"><link rel="prefetch" href="/assets/js/98.9d539c75.js"><link rel="prefetch" href="/assets/js/99.270c2389.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.b7a3ab4f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8c53e149.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">周岐的个人博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/java SE/guide.html" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/项目总结/Mybatis使用/Mybatis分页实现.html" class="nav-link">
  项目总结
</a></div><div class="nav-item"><a href="/Java面试题/Java基础面试题/==和equals的区别.html" class="nav-link">
  Java面试题
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="了解更多" class="dropdown-title"><span class="title">了解更多</span> <span class="arrow down"></span></button> <button type="button" aria-label="了解更多" class="mobile-dropdown-title"><span class="title">了解更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/demo223" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://www.yuque.com/zhouqi-5zipq" target="_blank" rel="noopener noreferrer" class="nav-link external">
  语雀
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/java SE/guide.html" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/项目总结/Mybatis使用/Mybatis分页实现.html" class="nav-link">
  项目总结
</a></div><div class="nav-item"><a href="/Java面试题/Java基础面试题/==和equals的区别.html" class="nav-link">
  Java面试题
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="了解更多" class="dropdown-title"><span class="title">了解更多</span> <span class="arrow down"></span></button> <button type="button" aria-label="了解更多" class="mobile-dropdown-title"><span class="title">了解更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/demo223" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://www.yuque.com/zhouqi-5zipq" target="_blank" rel="noopener noreferrer" class="nav-link external">
  语雀
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/java SE/guide" class="sidebar-heading clickable"><span>java SE</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>java web</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>SpringBoot</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>微服务</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Linux</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Docker</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Mybatis-Plus</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>常用工具类</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Java面试题</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Java面试题/Java基础面试题/==和equals的区别" class="sidebar-heading clickable"><span>Java基础面试题</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Java面试题/多线程面试题/多线程面试题" class="sidebar-heading clickable"><span>多线程面试题</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Java面试题/集合面试题/Java集合相关面试题" class="sidebar-heading clickable open active"><span>集合面试题</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/Java面试题/集合面试题/Java集合相关面试题.html" class="active sidebar-link">Java集合相关面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Java面试题/集合面试题/Java集合相关面试题.html#导读" class="sidebar-link">导读</a></li><li class="sidebar-sub-header"><a href="/Java面试题/集合面试题/Java集合相关面试题.html#_1-数据结构" class="sidebar-link">1 数据结构</a></li><li class="sidebar-sub-header"><a href="/Java面试题/集合面试题/Java集合相关面试题.html#_2-集合常见面试题" class="sidebar-link">2 集合常见面试题</a></li><li class="sidebar-sub-header"><a href="/Java面试题/集合面试题/Java集合相关面试题.html#_3-真实面试还原" class="sidebar-link">3 真实面试还原</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Java面试题/Mybatis面试题/Mybatis面试题" class="sidebar-heading clickable"><span>Mybatis面试题</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Java面试题/SpringBoot面试题/SpringBoot面试题" class="sidebar-heading clickable"><span>SpringBoot面试题</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Java面试题/MySQL面试题/MySQL面试题" class="sidebar-heading clickable"><span>MySQL面试题</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Java面试题/Redis面试题/Redis面试题" class="sidebar-heading clickable"><span>Redis面试题</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Java面试题/微服务面试题/微服务面试题" class="sidebar-heading clickable"><span>微服务面试题</span> <span class="arrow right"></span></a> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>项目总结</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/SpringBoot文档/01-Spring-IOC" class="sidebar-heading clickable"><span>SpringBoot文档</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/微服务文档/SpringCloud介绍" class="sidebar-heading clickable"><span>微服务文档</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="java集合相关面试题"><a href="#java集合相关面试题" class="header-anchor">#</a> Java集合相关面试题</h1> <h2 id="导读"><a href="#导读" class="header-anchor">#</a> 导读</h2> <p>本文共分为三部分，第一个是数据结构的普及，让大家快速掌握常见数据结构的一些特点。第二个是集合相关的面试题，这个也是本文的重点部分，包含了常见面试题的必问部分，比如：ArrayList和HashMap相关等等。第三个是面试现场或者叫做真实面试还原场景，我会以面试官和候选人的角度去提出问题和解答问题，希望能帮助到你！</p> <h2 id="_1-数据结构"><a href="#_1-数据结构" class="header-anchor">#</a> 1 数据结构</h2> <h3 id="_1-1-算法复杂度分析"><a href="#_1-1-算法复杂度分析" class="header-anchor">#</a> 1.1 算法复杂度分析</h3> <h4 id="_1-1-1-概念"><a href="#_1-1-1-概念" class="header-anchor">#</a> 1.1.1 概念</h4> <ol><li><p><strong>数据结构</strong>是指一组数据的存储结构</p></li> <li><p><strong>算法</strong>就是操作数据的方法</p></li></ol> <p>举个例子：</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220918101508113.png" alt="image-20220918101508113"></p> <blockquote><p>比如，你要搬家，有一堆货物，这个时候你可以选择使用小桥车拉走货物，你可以选择小货车拉走货物。其实现在你选择哪辆车装载货物就相当于选择了哪种数据结构。</p> <p>你选择小货车拉走货物，但是货物依然很多，你这个时候需要规整一下，难看怎么着更能节省空间，更能节省效率，这个动作就是算法了</p></blockquote> <p>清楚了这些概念之后，如果只是单独讲数据结构和算法是不合适的，它们两个是相辅相成的。</p> <h4 id="_1-1-2-算法复杂度"><a href="#_1-1-2-算法复杂度" class="header-anchor">#</a> 1.1.2 算法复杂度</h4> <p>复杂度也叫渐进复杂度，包括<strong>时间复杂度</strong>和<strong>空间复杂度</strong>，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。</p> <p>复杂度描述的是算法执行时间或占用内存空间随数据规模的增长关系。</p> <blockquote><p>举例：</p> <p>有200人需要从成都到北京，可以选择很多交通工具，每个交通工具的载客量和时间都不相同</p> <ul><li><p>大型载人客车，50人每车，需要4辆车，时间大概为30小时</p></li> <li><p>普通火车，载客量超大，满足200人的需求，时间大概为20小时</p></li> <li><p>高铁，载客量超大，满足200人的需求，时间大概为9小时</p></li> <li><p>飞机，载客量适中，满足200人的需求，时间大概为3小时</p></li></ul></blockquote> <p>算法的执行效率，粗略地讲，就是算法代码执行的时间，那如何在不直接运行代码的前提下粗略的计算执行时间呢？</p> <p>分析以下代码</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**
  * 求1~n的累加和
  * @param n
  * @return
  */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sum  <span class="token operator">=</span> sum <span class="token operator">+</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><blockquote><p>假设每行代码执行时间都一样为：timer</p> <p>此代码的执行时间为：(3n+3) timer</p> <p>总结：<strong>所有代码的执行时间T(n)与代码的执行次数成正比</strong>。</p></blockquote> <p>按照该思路我们接着看下面一段代码</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sum2</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sum <span class="token operator">=</span> sum <span class="token operator">+</span> i <span class="token operator">*</span> j<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>同理，此代码的执行时间为： (3 n^2 + 3n + 3) * timer</p> <p>因此有一个重要结论：<strong>代码的执行时间T(n)与总的执行次数相关</strong> ，我们可以把这个规律总结成一个公式。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">T</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token class-name">O</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>T(n)表示代码的执行时间，n表示数据规模的大小，f(n)表示了代码执行的总次数，它是一个公式因此用f(n)表示，O表示了代码执行时间与f(n)成正比</p></blockquote> <h4 id="_1-1-3-大o复杂度表示法"><a href="#_1-1-3-大o复杂度表示法" class="header-anchor">#</a> 1.1.3 大O复杂度表示法</h4> <p><strong>大 O 时间复杂度</strong>实际上并不具体表示代码真正的执行时间，而是<strong>表示代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作渐进时间复杂度，简称时间复杂度。</p> <p>当n很大时，公式中的<strong>低阶，常量，系数</strong>三部分并不左右其增长趋势，因此可以忽略，我们只需要记录一个最大的量级就可以了，因此如果用大O表示刚刚的时间复杂度可以记录为</p> <p>第一个例子中的T(n)=O(3n+3) -----&gt; T(n)=O(n)</p> <p>第二个例子中的T(n)=O(3 n^2 + 3n + 3) -------&gt; T(n)=O(n^2)</p> <p><strong>常见的复杂度</strong></p> <table><thead><tr><th><strong>描述</strong></th> <th><strong>表示形式</strong></th></tr></thead> <tbody><tr><td>常数</td> <td>O(1)</td></tr> <tr><td>线性</td> <td>O(n)</td></tr> <tr><td>对数</td> <td>O(log n)</td></tr> <tr><td>线性对数</td> <td>O(n * log n)</td></tr> <tr><td>平方</td> <td>O(n ^2)</td></tr> <tr><td>立方</td> <td>O(n ^3)</td></tr> <tr><td>k次方</td> <td>O(n ^k)</td></tr> <tr><td>指数</td> <td>O(2 ^n)</td></tr> <tr><td>阶乘</td> <td>O(n !)</td></tr></tbody></table> <h4 id="_1-1-4-o-1"><a href="#_1-1-4-o-1" class="header-anchor">#</a> 1.1.4  O(1)</h4> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> i<span class="token operator">+</span>j<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>代码只有三行，它的复杂度也是O(1)，而不是O(3)</p> <p>再看如下代码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test02</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">100</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        sum <span class="token operator">=</span> sum<span class="token operator">+</span>i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>整个代码中因为循环次数是固定的就是100次，这样的代码复杂度我们认为也是O(1)</p> <p>一句话总结：<strong>只要代码的执行时间不随着n的增大而增大，这样的代码复杂度都是O(1)</strong></p> <h4 id="_1-1-5-o-n"><a href="#_1-1-5-o-n" class="header-anchor">#</a> 1.1.5 O(n)</h4> <p>这个大家已经不陌生了，就是刚才上面的两个例子</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**
 * 求1~n的累加和
 * @param n
 * @return
 */</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sum <span class="token operator">=</span> sum <span class="token operator">+</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>一层for循环的时间复杂度是 O(n)</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sum2</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sum <span class="token operator">=</span> sum <span class="token operator">+</span> i <span class="token operator">*</span> j<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>两层for循环的时间复杂度是 O(n^2)</p> <h4 id="_1-1-6-o-log-n"><a href="#_1-1-6-o-log-n" class="header-anchor">#</a> 1.1.6 O(log n)</h4> <p>对数复杂度非常的常见，但相对比较难以分析，代码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test04</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">)</span><span class="token punctuation">{</span>
        i <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>分析这个代码的复杂度，我们必须要再强调一个前提：<strong>复杂度分析就是要弄清楚代码的执行次数和数据规模n之间的关系</strong></p> <p>以上代码最关键的一行是：<code>i = i * 2</code>，这行代码可以决定这个while循环执行代码的行数，<code>i</code>的值是可以无限接近<code>n</code>的值的。如果<code>i</code> 一旦大于等于了<code>n</code>则循环条件就不满足了。也就说达到了最大的行数。我们可以分析一下<code>i</code>这个值变化的过程</p> <p>分析过程如下：</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220918103139078.png" alt="image-20220918103139078"></p> <p>由此可知，代码的时间复杂度表示为O(log n)</p> <h4 id="_1-1-7-o-n-log-n"><a href="#_1-1-7-o-n-log-n" class="header-anchor">#</a> 1.1.7 O(n * log n)</h4> <p>分析完O( log n )，那O( n * log n )就很容易理解了，比如下列代码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test05</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">test04</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test04</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">)</span><span class="token punctuation">{</span>
        i <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="_1-1-8-空间复杂度"><a href="#_1-1-8-空间复杂度" class="header-anchor">#</a> 1.1.8 空间复杂度</h4> <p>空间复杂度全称是渐进空间复杂度，表示算法占用的额外<strong>存储空间</strong>与<strong>数据规模</strong>之间的增长关系</p> <p>看下面代码</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        sum <span class="token operator">=</span> sum<span class="token operator">+</span>i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>代码执行并不需要占用额外的存储空间，只需要常量级的内存空间大小，因此空间复杂度是O(1)</p> <p>再来看一个其他例子：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">;</span> i <span class="token operator">&lt;</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">*</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>传入一个变量n，决定申请多少的int数组空间内存，此段代码的空间复杂度为O(n)</p> <p>我们常见的空间复杂度就是O(1),O(n),O(n ^2)，其他像对数阶的复杂度几乎用不到，因此空间复杂度比时间复杂度分析要简单的多。</p> <h3 id="_1-2-数组"><a href="#_1-2-数组" class="header-anchor">#</a> 1.2 数组</h3> <h4 id="_1-2-1-数组概述"><a href="#_1-2-1-数组概述" class="header-anchor">#</a> 1.2.1 数组概述</h4> <p>数组（Array）是一种用<strong>连续的内存空间</strong>存储<strong>相同数据类型</strong>数据的线性数据结构。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820104114601.png" alt="image-20220820104114601"></p> <p>数组的表示方式：使用<strong>下标</strong>来获取数组元素数据</p> <p>设有一个字符串数组arr，元素个数为n</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820104323869.png" alt="image-20220820104323869"></p> <p>通过下标来表示和获取元素，数组下标从0开始</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820104411788.png" alt="image-20220820104411788"></p> <blockquote><h3 id="思考-操作平台是如何根据下标来找到对应元素的内存地址的呢"><a href="#思考-操作平台是如何根据下标来找到对应元素的内存地址的呢" class="header-anchor">#</a> 思考：操作平台是如何根据下标来找到对应元素的内存地址的呢？</h3></blockquote> <p>我们拿一个长度为10的数组来举例，int [] a= new int[10]，在下面的图中，计算机给数组分配了一块连续的空间，100-139，其中内存的起始地址为baseAddress=100</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820104541023.png" alt="image-20220820104541023"></p> <p>计算机给每个内存单元都分配了一个地址，通过地址来访问其数据，因此要访问数组中的某个元素时，首先要经过一个寻址公式计算要访问的元素在内存中的地址：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> baseAddress <span class="token operator">+</span> i <span class="token operator">*</span> dataTypeSize
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>dataTypeSize代表数组中元素类型的大小，在这个例子中，存储的是int型的数据，因此dataTypeSize=4个字节</p></blockquote> <h4 id="_1-2-2-数组的特点"><a href="#_1-2-2-数组的特点" class="header-anchor">#</a> 1.2.2 数组的特点</h4> <p><strong>1.查询O(1)</strong></p> <p>数组元素的访问是通过下标来访问的，计算机通过数组的首地址和寻址公式能够很快速的找到想要访问的元素</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820104736261.png" alt="image-20220820104736261"></p> <p>代码的执行次数并不会随着数组的数据规模大小变化而变化，是常数级的，所以查询数据操作的时间复杂度是O(1)</p> <p><strong>2.插入O(n)</strong></p> <p>数组是一段连续的内存空间，因此为了保证数组的连续性会使得数组的插入和删除的效率变的很低。</p> <p>假设数组的长度为 n，现在如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。如下图所示：</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820104903422.png" alt="image-20220820104903422"></p> <p>新增之后的数据变化，如下</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820104950846.png" alt="image-20220820104950846"></p> <p>所以：</p> <p>插入操作，最好情况下是O(1)的，最坏情况下是O(n)的，<strong>平均情况下的时间复杂度是O(n)</strong>。</p> <p><strong>3.删除O(n)</strong></p> <p>同理可得：如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了，时间复杂度仍然是O(n)。</p> <h3 id="_1-3-链表"><a href="#_1-3-链表" class="header-anchor">#</a> 1.3 链表</h3> <h4 id="_1-3-1-链表概述"><a href="#_1-3-1-链表概述" class="header-anchor">#</a> 1.3.1 链表概述</h4> <p>链表（<strong>Linked list</strong>）是一种物理<strong>存储单元上非连续、非顺序</strong>的存储结构，链表中的每一个元素称之为<strong>结点（Node）</strong>，结点之间用指针（引用）连接起来，指针的指向顺序代表了结点的逻辑顺序，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820105408000.png" alt="image-20220820105408000"></p> <h4 id="_1-3-2-链表分类"><a href="#_1-3-2-链表分类" class="header-anchor">#</a> 1.3.2 链表分类</h4> <ul><li><p>单链表</p></li> <li><p>双向链表</p></li> <li><p>循环链表</p></li></ul> <h4 id="_1-3-3-单链表"><a href="#_1-3-3-单链表" class="header-anchor">#</a> 1.3.3 单链表</h4> <p>单链表就是我们刚刚讲到的链表的最基本的结构，链表通过指针将一组零散的内存块串联在一起。。如图所示，我们把这个记录下个结点地址的指针叫作后继指针 next ，如果链表中的某个节点为p，p的下一个节点为q，我们可以表示为：p.next=q</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820105617336.png" alt="image-20220820105617336"></p> <h4 id="_1-3-4-双向链表"><a href="#_1-3-4-双向链表" class="header-anchor">#</a> 1.3.4 双向链表</h4> <p>单向链表只有一个方向，结点只有一个后继指针 next。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点，如图所示</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820110348884.png" alt="image-20220820110348884"></p> <p>特点：</p> <ul><li><p>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址</p></li> <li><p>支持双向遍历，这样也带来了双向链表操作的灵活性</p></li> <li><p>可以在O(1)时间内找到给定结点的前驱节点，而对于单链表则需要O(n)的时间</p></li> <li><p>根据索引来查找元素时可极大提升查找效率</p></li></ul> <h4 id="_1-3-5-循环链表"><a href="#_1-3-5-循环链表" class="header-anchor">#</a> 1.3.5 循环链表</h4> <p>循环链表是一种特殊的单链表。循环链表的尾结点指针是指向链表的头结点。它像一个环一样首尾相连，所以叫作“循环”链表，和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表，循环链表的结构如图所示</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820110434956.png" alt="image-20220820110434956"></p> <h4 id="_1-3-6-链表时间复杂度分析"><a href="#_1-3-6-链表时间复杂度分析" class="header-anchor">#</a> 1.3.6 链表时间复杂度分析</h4> <p>针对链表的<strong>插入和删除</strong>操作，我们只需要考虑相邻结点的指针改变，所以<strong>插入删除的时间复杂度是 O(1)</strong>。</p> <p>插入操作，解析X想要插入到AB节点之间</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820105809873.png" alt="image-20220820105809873"></p> <p>移动之后的效果，如下：</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820105845299.png" alt="image-20220820105845299"></p> <p>删除操作</p> <p>想要删除B节点</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820110017015.png" alt="image-20220820110017015"></p> <p>删除之后的效果，如下：</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820110059579.png" alt="image-20220820110059579"></p> <p><strong>查询的复杂度</strong></p> <p>链表要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据针一个结点一个结点地依次遍历，直到找到相应的结点，所以，链表随机访问的性能没有数组好，查询的时间复杂度是O(n)。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820110310821.png" alt="image-20220820110310821"></p> <h3 id="_1-4-栈和队列"><a href="#_1-4-栈和队列" class="header-anchor">#</a> 1.4 栈和队列</h3> <h4 id="_1-4-1-栈"><a href="#_1-4-1-栈" class="header-anchor">#</a> 1.4.1 栈</h4> <p>栈（Stack）并非指某种特定的数据结构，它是有着相同典型特征的一类数据结构的统称，因为栈可以用数组实现，也可以用链表实现。该典型特征是：<strong>后进先出</strong>；英文表示为：<strong>Last In First Out即 LIFO</strong>，只要满足这种特点的数据结构我们就可以说这是栈，为了更好的理解栈这种数据结构，我们以一幅图的形式来表示，如下：</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820110550405.png" alt="image-20220820110550405"></p> <p><strong>时间复杂度均为O(1)</strong></p> <h4 id="_1-4-1-队列"><a href="#_1-4-1-队列" class="header-anchor">#</a> 1.4.1 队列</h4> <p>队列（Queue）和栈一样，代表具有某一类操作特征的数据结构，队列先进先出的特点英文表示为：<strong>First In First Out即FIFO</strong>，为了更好的理解队列这种数据结构，我们以一幅图的形式来表示，如下：</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820110755299.png" alt="image-20220820110755299"></p> <p><strong>入队列和出队列操作的时间复杂度均为O(1)</strong></p> <h3 id="_1-5-散列表"><a href="#_1-5-散列表" class="header-anchor">#</a> 1.5 散列表</h3> <h4 id="_1-5-1-散列表-hash-table"><a href="#_1-5-1-散列表-hash-table" class="header-anchor">#</a> 1.5.1 散列表（Hash Table）</h4> <p>散列表(Hash Table)又名哈希表/Hash表，是根据键（Key）直接访问在内存存储位置值（Value）的数据结构，它是由数组演化而来的，利用了数组支持按照下标进行随机访问数据的特性</p> <p>例子1：</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820124203789.png" alt="image-20220820124203789"></p> <p>假设有100个人参加马拉松，编号是1-100，如果要编程实现根据选手的编号迅速找到选手信息？</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820124245754.png" alt="image-20220820124245754"></p> <blockquote><p><strong>实现思路</strong>：</p> <p>我们可以让选手的编号存储到数组中，其中选手的编号就是数组的下标，我们需要查询某一个选手的时候，只需要根据选手编号作为数组下标查询即可，时间复杂度为O(1)，效率很高</p></blockquote> <p>例子2：</p> <p>假设有100个人参加马拉松，不采用1-100的自然数对选手进行编号，编号有一定的规则比如：2022ZHBJ001，其中2022代表年份，ZH代表中国，BJ代表北京，001代表原来的编号，那此时的编号2022ZHBJ001不能直接作为数组的下标，此时应该如何实现呢？</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820124803331.png" alt="image-20220820124803331"></p> <blockquote><p>我们让选手的编号（2022ZHBJ001）进行hash计算，hash计算后得到一个<strong>整数值</strong>，可以<strong>做为数组的下标</strong>进行存储。</p></blockquote> <h4 id="_1-5-2-散列函数"><a href="#_1-5-2-散列函数" class="header-anchor">#</a> 1.5.2 散列函数</h4> <p><strong>将键(key)映射为数组下标的函数叫做散列函数</strong>。可以表示为：<strong>hashValue = hash(key)</strong></p> <p>散列函数的基本要求：</p> <ul><li><p>散列函数计算得到的散列值必须是大于等于0的正整数，因为hashValue需要作为数组的下标。</p></li> <li><p>如果key1==key2，那么经过hash后得到的哈希值也必相同即：hash(key1) == hash(key2）</p></li> <li><p>如果key1 != key2，那么经过hash后得到的哈希值也必不相同即：hash(key1) != hash(key2)</p></li></ul> <blockquote><p>上面要求的前2条很容易理解，也很容易实现，但是第三条是不太容易实现的，因而会产生散列冲突</p></blockquote> <h4 id="_1-5-3-散列冲突"><a href="#_1-5-3-散列冲突" class="header-anchor">#</a> 1.5.3 散列冲突</h4> <p>第三个要求看起来没有任何问题，但是在实际的情况下想找一个散列函数能够做到对于不同的key计算得到的散列值都不同几乎是不可能的，即便像著名的MD5,SHA等哈希算法也无法避免这一情况，这也就是我们即将要说到的<strong>散列冲突(或者哈希冲突，哈希碰撞，就是指多个key映射到同一个数组下标位置)</strong></p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220918214811289.png" alt="image-20220918214811289"></p> <blockquote><p>如上图所示</p> <p>​	上图中的选手编号，如果进行hash计算后得到的值是一样的，则会计算到数组中的同一个下标中</p></blockquote> <h4 id="_1-5-4-散列冲突-链表法-拉链"><a href="#_1-5-4-散列冲突-链表法-拉链" class="header-anchor">#</a> 1.5.4 散列冲突-链表法（拉链）</h4> <p>在散列表中，数组的每个下标位置我们可以称之为<strong>桶（bucket）<strong>或者</strong>槽（slot）</strong>，每个桶(槽)会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820125740873.png" alt="image-20220820125740873"></p> <p><strong>时间复杂度</strong></p> <ul><li><p>插入操作，通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，插入的时间复杂度是 O(1)</p></li> <li><p>当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除</p> <ul><li>平均情况下基于链表法解决冲突时查询的时间复杂度是O(1)</li> <li>如果散列函数设计得不好，或者装载因子过高，都可能导致散列冲突发生的概率升高，都散列到同一个槽里,散列表就会退化为链表,查询的时间复杂度就从 O(1) 急剧退化为 O(n)</li> <li>如果链表法稍加改造，可以实现一个更加高效的散列表。我们将链表法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树，查询的时间复杂度也只不过是 O(logn)</li></ul></li></ul> <h3 id="_1-6-二叉树"><a href="#_1-6-二叉树" class="header-anchor">#</a> 1.6 二叉树</h3> <h4 id="_1-6-1-二叉树"><a href="#_1-6-1-二叉树" class="header-anchor">#</a> 1.6.1 二叉树</h4> <p>二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。</p> <p>二叉树每个节点的左子树和右子树也分别满足二叉树的定义。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820130006241.png" alt="image-20220820130006241"></p> <p>很多其他高级数据结构都是基于二叉树，他们的操作特点各有不同，但从存储上来说底层无外乎就是两种：数组存储，链式存储。</p> <p>基于链式存储的树的节点可定义如下：</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820130107208.png" alt="image-20220820130107208"></p> <h4 id="_1-6-2-二叉树分类"><a href="#_1-6-2-二叉树分类" class="header-anchor">#</a> 1.6.2 二叉树分类</h4> <p>在二叉树中，有几种特殊的情况，分别叫做：满二叉树，完全二叉树</p> <p>1、满二叉树</p> <p>叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作满二叉树。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820130159106.png" alt="image-20220820130159106"></p> <p>2、完全二叉树</p> <ul><li><p>叶子节点都在最底下两层</p></li> <li><p>最后一层的叶子节点都靠左排列(某个节点只有一个叶子节点的情况下)，</p></li> <li><p>并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作完全二叉树。</p></li></ul> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820130259368.png" alt="image-20220820130259368"></p> <blockquote><h3 id="思考-为什么偏偏把最后一层的叶子节点靠左排列的叫完全二叉树"><a href="#思考-为什么偏偏把最后一层的叶子节点靠左排列的叫完全二叉树" class="header-anchor">#</a> 思考：为什么偏偏把最后一层的叶子节点靠左排列的叫完全二叉树？</h3></blockquote> <p>完全二叉树更倾向采用基于<strong>数组</strong>的顺序存储方式，特征如下：</p> <p>任意一个节点在数组下标为k的位置</p> <ul><li><p>下标2*k的位置存储的它的左子节点</p></li> <li><p>下标2*k + 1的位置存储的它的右子节点</p></li></ul> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820130536328.png" alt="image-20220820130536328"></p> <p><strong>数组存储完全二叉树能够有效利用存储空间</strong></p> <h4 id="_1-6-3-二叉树遍历"><a href="#_1-6-3-二叉树遍历" class="header-anchor">#</a> 1.6.3 二叉树遍历</h4> <p>经典的三种遍历方式：<strong>前序遍历</strong>，<strong>中序遍历</strong>，<strong>后序遍历</strong></p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820130710363.png" alt="image-20220820130710363"></p> <ul><li><p>前序遍历：对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</p> <p>遍历结果：3467589</p></li> <li><p>中序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</p> <p>遍历结果：6473859</p></li> <li><p>后序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。</p> <p>遍历结果：6748953</p></li></ul> <p><strong>总结：</strong></p> <p>通过我们分析的二叉树的遍历流程我们可以发现，遍历二叉树的时间复杂度跟二叉树节点的个数n成正比，因此，二叉树遍历的时间复杂度是O(n)。</p> <h4 id="_1-6-4-二叉搜索树"><a href="#_1-6-4-二叉搜索树" class="header-anchor">#</a> 1.6.4 二叉搜索树</h4> <p>二叉搜索树(Binary Search Tree,BST)又名二叉查找树，有序二叉树或者排序二叉树，是二叉树中比较常用的一种类型</p> <p>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820131129455.png" alt="image-20220820131129455"></p> <p>详细可以分为以下4点：</p> <ol><li><p>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</p></li> <li><p>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</p></li> <li><p>任意节点的左、右子树也分别为二叉查找树；</p></li> <li><p>没有键值相等的节点。</p></li></ol> <p><strong>对于二叉查找树而言，它的中序遍历结果是一个递增的序列</strong></p> <h4 id="_1-6-5-二叉搜索树-时间复杂度分析"><a href="#_1-6-5-二叉搜索树-时间复杂度分析" class="header-anchor">#</a> 1.6.5 二叉搜索树-时间复杂度分析</h4> <p>实际上由于二叉查找树的形态各异，时间复杂度也不尽相同，我画了几棵树我们来看一下插入，查找，删除的时间复杂度</p> <p>（1）完全二叉查找树</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820131319323.png" alt="image-20220820131319323"></p> <p>插入，查找，删除的时间复杂度其实和树的高度成正比，那也就是说时间复杂度为O(height)</p> <p><strong>O(height) == O(logn)</strong></p> <p>（2）满二叉查找树</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820131416879.png" alt="image-20220820131416879"></p> <p>插入，查找，删除的时间复杂度其实和树的高度成正比，那也就是说时间复杂度为O(height)</p> <p><strong>O(height) == O(logn)</strong></p> <p>（3）极端情况</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820131528861.png" alt="image-20220820131528861"></p> <p>对于图中这种情况属于最坏的情况，二叉查找树已经退化成了链表，左右子树极度不平衡，<strong>此时查找的时间复杂度肯定是O(n)</strong>。</p> <p><strong>总结：</strong></p> <p>二叉查找树也可以叫做平衡二叉查找树。平衡二叉查找树的高度接近logn，所以插入、删除、查找操作的时间复杂度也比较稳定，是 O(logn)。</p> <h3 id="_1-7-红黑树"><a href="#_1-7-红黑树" class="header-anchor">#</a> 1.7 红黑树</h3> <h4 id="_1-7-1-红黑树-概述"><a href="#_1-7-1-红黑树-概述" class="header-anchor">#</a> 1.7.1 红黑树-概述</h4> <p><strong>红黑树（Red Black Tree）</strong>：也是一种自平衡的二叉搜索树(BST)，之前叫做平衡二叉B树（Symmetric Binary B-Tree）</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820123725685.png" alt="image-20220820123725685"></p> <h4 id="_1-7-2-红黑树的特质"><a href="#_1-7-2-红黑树的特质" class="header-anchor">#</a> 1.7.2 红黑树的特质</h4> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820123851714.png" alt="image-20220820123851714"></p> <p>性质1：节点要么是<strong>红色</strong>,要么是<strong>黑色</strong></p> <p>性质2：根节点是<strong>黑色</strong></p> <p>性质3：叶子节点都是黑色的空节点</p> <p>性质4：红黑树中红色节点的子节点都是黑色</p> <p>性质5：从任一节点到叶子节点的所有路径都包含相同数目的黑色节点</p> <p><font color="red"><strong>在这些规则的约束下，红黑树能够保证平衡</strong></font></p> <h4 id="_1-7-3-红黑树的复杂度"><a href="#_1-7-3-红黑树的复杂度" class="header-anchor">#</a> 1.7.3 红黑树的复杂度</h4> <ul><li><p>查找：</p> <p>红黑树也是一棵BST（二叉搜索树）树，查找操作的时间复杂度为：O(log n)</p></li> <li><p>添加：</p> <p>添加先要从根节点开始找到元素添加的位置，时间复杂度O(log n)</p> <p>添加完成后涉及到复杂度为O(1)的旋转调整操作</p> <p>故整体复杂度为：O(log n)</p></li> <li><p>删除：</p> <p>首先从根节点开始找到被删除元素的位置，时间复杂度O(log n)</p> <p>删除完成后涉及到复杂度为O(1)的旋转调整操作</p> <p>故整体复杂度为：O(log n)</p></li></ul> <h2 id="_2-集合常见面试题"><a href="#_2-集合常见面试题" class="header-anchor">#</a> 2 集合常见面试题</h2> <h3 id="_2-1-java常见的集合类"><a href="#_2-1-java常见的集合类" class="header-anchor">#</a> 2.1 Java常见的集合类</h3> <h4 id="_2-1-1-说一说-画一画-collection结构图"><a href="#_2-1-1-说一说-画一画-collection结构图" class="header-anchor">#</a> 2.1.1 说一说（画一画）Collection结构图</h4> <blockquote><p>难易程度：☆☆</p> <p>出现频率：☆☆☆☆</p></blockquote> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820133508556.png" alt="image-20220820133508556"></p> <p>Map接口和Collection接口是所有集合框架的父接口：</p> <p>1.Collection接口的子接口包括：Set接口和List接口</p> <p>2.Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</p> <p>3.List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</p> <p>4.Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及 Properties等</p> <h3 id="_2-2-arraylist"><a href="#_2-2-arraylist" class="header-anchor">#</a> 2.2 ArrayList</h3> <p>ArrayList 底层实现是数组，是动态数组。与Java中的数组相比，它的容量能动态增长。</p> <p>它的算法时间复杂度与数组是一致的。</p> <ul><li><p>查询的复杂度为：O(1)</p></li> <li><p>新增和删除的复杂度为：O(n)</p></li></ul> <h4 id="_2-2-1-arraylist-list-new-arraylist-10-中的list扩容几次"><a href="#_2-2-1-arraylist-list-new-arraylist-10-中的list扩容几次" class="header-anchor">#</a> 2.2.1 ArrayList list=new ArrayList(10)中的list扩容几次</h4> <blockquote><p>难易程度：☆☆</p> <p>出现频率：☆☆</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**
* 构造一个具有指定初始容量的空列表。
* 参数：initialCapacity - 列表的初始容量
* 抛出：IllegalArgumentException – 如果指定的初始容量为负
*/</span>
<span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token constant">EMPTY_ELEMENTDATA</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;Illegal Capacity: &quot;</span><span class="token operator">+</span>                initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>该语句只是申明和实例了一个 ArrayList，指定了容量为 10，未扩容</p> <h4 id="_2-2-2-如何实现数组和list之间的转换"><a href="#_2-2-2-如何实现数组和list之间的转换" class="header-anchor">#</a> 2.2.2 如何实现数组和List之间的转换</h4> <blockquote><p>难易程度：☆☆</p> <p>出现频率：☆☆</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//数组转 List ，使用 JDK 中 java.util.Arrays 工具类的 asList 方法</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testArray2List</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">&quot;aaa&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;bbb&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;ccc&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>strs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> s <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//List 转数组</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testList2Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">&quot;aaa&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;bbb&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;ccc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> s <span class="token operator">:</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><ul><li>数组转 List ，使用 JDK 中 java.util.Arrays 工具类的 asList 方法</li> <li>List 转数组，使用 List 的 toArray 方法。无参 toArray 方法返回 Object 数组，传入初始化长度的数组对象，返回该对象数组</li></ul> <h3 id="_2-3-linkedlist"><a href="#_2-3-linkedlist" class="header-anchor">#</a> 2.3 LinkedList</h3> <p>底层是双向链表实现的List</p> <ul><li><p>非线程安全的</p></li> <li><p>元素允许为null，允许重复元素</p></li> <li><p>实现了栈和队列的操作方法，因此也可以作为栈、队列和双端队列来使用</p></li> <li><p>时间复杂度：</p> <p>因此插入删除效率高，复杂度为O(1)，查找效率低，复杂度为：O(n)</p></li></ul> <h4 id="_2-3-1-arraylist-和-linkedlist-的区别是什么"><a href="#_2-3-1-arraylist-和-linkedlist-的区别是什么" class="header-anchor">#</a> 2.3.1 ArrayList 和 LinkedList 的区别是什么？</h4> <blockquote><p>难易程度：☆☆☆</p> <p>出现频率：☆☆☆☆☆</p></blockquote> <p>参考回答：</p> <ol><li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li> <li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数 据存储方式，所以需要移动指针从前往后依次查找。</li> <li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li> <li>内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储 了两个引用，一个指向前一个元素，一个指向后一个元素。</li> <li>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li></ol> <h3 id="_2-4-hashmap"><a href="#_2-4-hashmap" class="header-anchor">#</a> 2.4 HashMap</h3> <h4 id="_2-4-1-说一下hashmap的实现原理"><a href="#_2-4-1-说一下hashmap的实现原理" class="header-anchor">#</a> 2.4.1 说一下HashMap的实现原理？</h4> <blockquote><p>难易程度：☆☆☆</p> <p>出现频率：☆☆☆☆☆</p></blockquote> <p>HashMap的数据结构： 底层使用hash表数据结构，即数组和链表的结合体。</p> <p>HashMap 基于 Hash 算法实现的</p> <ol><li><p>当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数 组中的下标</p></li> <li><p>存储时，如果出现hash值相同的key，此时有两种情况。</p></li></ol> <ul><li><p>如果key相同，则覆盖原始值；</p></li> <li><p>如果key不同（出现冲突），则将当前的key-value放入链表中</p></li></ul> <ol start="3"><li>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</li></ol> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820134330871.png" alt="image-20220820134330871"></p> <p><strong>HashMap JDK1.8之前</strong></p> <p>JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820134415862.png" alt="image-20220820134415862"></p> <p><strong>HashMap JDK1.8之后</strong></p> <p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8） 时，将链表转化为红黑树，以减少搜索时间。扩容 resize( ) 时，红黑树拆分成的树的结点数小于等于临界值6个，则退化成链表。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820134516934.png" alt="image-20220820134516934"></p> <h4 id="_2-4-2-hashmap的put方法的具体流程"><a href="#_2-4-2-hashmap的put方法的具体流程" class="header-anchor">#</a> 2.4.2 HashMap的put方法的具体流程？</h4> <blockquote><p>难易程度：☆☆☆</p> <p>出现频率：☆☆☆☆</p></blockquote> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/HashMap%E7%9A%84put%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B.jpg" alt=""></p> <p>参考回答：</p> <ol><li>判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</li> <li>根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向 ⑥，如果table[i]不为空，转向③；</li> <li>判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的 是hashCode以及equals；</li> <li>判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值 对，否则转向⑤</li> <li>遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操 作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</li> <li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩 容。</li></ol> <h4 id="_2-4-3-hashmap的寻址算法"><a href="#_2-4-3-hashmap的寻址算法" class="header-anchor">#</a> 2.4.3 hashMap的寻址算法</h4> <blockquote><p>难易程度：☆☆☆☆</p> <p>出现频率：☆☆☆☆</p></blockquote> <p>我们先研究下key的哈希值是如何计算出来的。key的哈希值是通过上述方法计算出来的。</p> <p>这个哈希方法首先计算出key的hashCode赋值给h,然后与h无符号右移16位后的二进制进行按位异或得到最后的	hash值。计算过程如下所示：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> 
 <span class="token punctuation">{</span>
        <span class="token keyword">int</span> h<span class="token punctuation">;</span>
     	<span class="token comment">/*
     		1）如果key等于null：
     			可以看到当key等于null的时候也是有哈希值的，返回的是0.
     		2）如果key不等于null：
     			首先计算出key的hashCode赋值给h,然后与h无符号右移16位后的二进制进行按位异或得到最后的					hash值
     	*/</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>在putVal函数中使用到了上述hash函数计算的哈希值：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>
                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        。。。。。。。。。。。。。。
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token comment">//这里的n表示数组长度16</span>
       。。。。。。。。。。。。。。
  <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>计算过程如下所示：</p> <p>​	说明：</p> <p>​		1）key.hashCode()；返回散列值也就是hashcode。假设随便生成的一个值。</p> <p>​		2）n表示数组初始化的长度是16</p> <p>​		3）&amp;（按位与运算）：运算规则：相同的二进制数位上，都是1的时候，结果为1，否则为零。</p> <p>​	    4）^（按位异或运算）：运算规则：相同的二进制数位上，数字相同，结果为0，不同为1。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220918214854113.png" alt="image-20220918214854113"></p> <h4 id="_2-4-4-讲一讲hashmap的扩容机制"><a href="#_2-4-4-讲一讲hashmap的扩容机制" class="header-anchor">#</a> 2.4.4 讲一讲HashMap的扩容机制</h4> <blockquote><p>难易程度：☆☆☆</p> <p>出现频率：☆☆☆☆</p></blockquote> <p>参考回答：</p> <ol><li><p>在jdk1.8中，resize方法是在hashmap中的键值对大于阀值(0.75)时或者初始化时，就调用resize方法进 行扩容；</p></li> <li><p>每次扩展的时候，都是扩展2倍；</p></li> <li><p>扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</p></li></ol> <p>增强补充：</p> <p>在put过程中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值(第一次为12) , 这个时候在扩 容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方</p> <p>在1.7 中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据 在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p> <h4 id="_2-4-5-为何hashmap的数组长度一定是2的次幂"><a href="#_2-4-5-为何hashmap的数组长度一定是2的次幂" class="header-anchor">#</a> 2.4.5 为何HashMap的数组长度一定是2的次幂？</h4> <blockquote><p>难易程度：☆☆☆</p> <p>出现频率：☆☆☆</p></blockquote> <ol><li>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模</li> <li>扩容时重新计算索引效率更高： hash &amp; oldCap == 0 的元素留在原来位置 ，否则新位置 = 旧位置 + oldCap</li></ol> <h4 id="_2-4-6-hashmap在1-7情况下的多线程死循环问题"><a href="#_2-4-6-hashmap在1-7情况下的多线程死循环问题" class="header-anchor">#</a> 2.4.6 hashmap在1.7情况下的多线程死循环问题</h4> <blockquote><p>难易程度：☆☆☆</p> <p>出现频率：☆☆</p></blockquote> <p>jdk7的的数据结构是：数组+链表</p> <p>在数组进行扩容的时候，因为链表是<strong>头插法</strong>，在进行数据迁移的过程中，有可能导致死循环</p> <p>线程一：<strong>读取</strong>到当前的hashmap情况，在准备扩容时，线程二介入</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820223950488.png" alt="image-20220820223950488"></p> <p>线程二：读取hashmap，进行扩容</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820223716959.png" alt="image-20220820223716959"></p> <p>线程一：继续执行</p> <p>此线程先将A移入新的链表，再将B插入到链头，由于另外一个线程的原因，B的next指向了A，所以B-&gt;A-&gt;B,形成循环。</p> <p><img src="https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220820223903190.png" alt="image-20220820223903190"></p> <p>JDK 8 将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），<strong>尾插法</strong></p> <h3 id="_2-5-hashset"><a href="#_2-5-hashset" class="header-anchor">#</a> 2.5 HashSet</h3> <ol><li>不允许重复（<strong>底层是HashMap</strong>，用key储存元素，value统一都是 PRESENT），可以为null，无顺序</li> <li>HashSet就是为了提高查找效率的（在查找是否存在某个值时，ArrayList需要遍历才能确定某个值的位置，而HashSet可以通过HashCode快速定位）</li></ol> <h4 id="_2-5-1-hashset与hashmap的区别"><a href="#_2-5-1-hashset与hashmap的区别" class="header-anchor">#</a> 2.5.1 HashSet与HashMap的区别</h4> <blockquote><p>难易程度：☆☆</p> <p>出现频率：☆☆</p></blockquote> <p>(1)HashSet实现了Set接口, 仅存储对象; HashMap实现了 Map接口, 存储的是键值对.</p> <p>(2)HashSet底层其实是用HashMap实现存储的, HashSet封装了一系列HashMap的方法. 依靠HashMap来存储元素值,(利用hashMap的key键进行存储), 而value值默认为Object对象. 所以HashSet也不允许出现重复值, 判断标准和HashMap判断标准相同, 两个元素的hashCode相等并且通过equals()方法返回true.</p> <h2 id="_3-真实面试还原"><a href="#_3-真实面试还原" class="header-anchor">#</a> 3 真实面试还原</h2> <h3 id="_3-1-java常见的集合类"><a href="#_3-1-java常见的集合类" class="header-anchor">#</a> 3.1 Java常见的集合类</h3> <blockquote><p><strong>面试官</strong>：说一说Java提供的常见集合？（画一下集合结构图）</p> <p><strong>候选人</strong>：</p> <p>嗯~~，好的。</p> <p>在java中提供了量大类的集合框架，主要分为两类：</p> <p>第一个是Collection  属于单列集合，第二个是Map  属于双列集合</p> <ul><li>在Collection中有两个子接口List和Set。在我们平常开发的过程中用的比较多像list接口中的实现类ArrarList和LinkedList。  在Set接口中有实现类HashSet和TreeSet。</li> <li>在map接口中有很多的实现类，平时比较常见的是HashMap、TreeMap，还有一个线程安全的map:ConcurrentHashMap</li></ul></blockquote> <h3 id="_3-2-arraylist"><a href="#_3-2-arraylist" class="header-anchor">#</a> 3.2 ArrayList</h3> <blockquote><p><strong>面试官</strong>：ArrayList list=new ArrayList(10)中的list扩容几次</p> <p><strong>候选人</strong>：</p> <p>​	是new了一个ArrarList并且给了一个构造参数10，对吧？(问题一定要问清楚再答)</p> <p><strong>面试官</strong>：是的</p> <p><strong>候选人</strong>：</p> <p>​    好的，在ArrayList的源码中提供了一个带参数的构造方法，这个参数就是指定的集合初始长度，所以给了一个10的参数，就是指定了集合的初始长度是10，这里面并没有扩容。</p> <hr> <p><strong>面试官</strong>：如何实现数组和List之间的转换</p> <p><strong>候选人</strong>：</p> <p>​	嗯，这个在我们平时开发很常见</p> <p>​    数组转list，可以使用jdk自动的一个工具类Arrars，里面有一个asList方法可以转换为数组</p> <p>​    List 转数组，可以直接调用list中的toArray方法，需要给一个参数，指定数组的类型，需要指定数组的长度。</p></blockquote> <h3 id="_3-3-linkedlist"><a href="#_3-3-linkedlist" class="header-anchor">#</a> 3.3 LinkedList</h3> <blockquote><p><strong>面试官</strong>：ArrayList 和 LinkedList 的区别是什么？</p> <p><strong>候选人</strong>：</p> <p>​	嗯，它们两个主要是底层使用的数据结构不一样，ArrayList 是动态数组，LinkedList 是双向链表，这也导致了它们很多不同的特点。</p> <p>查询操作是ArrarList较快，它是根据数组下标获取的。LinkedList 由于是双向列表，需要移动指针从前往后依次查找，所以比较慢</p> <p>增加和删除是LinkedList 效率更好，只需要挪动节点的指针即可；ArrayList 增删操作比较慢，它要影响数组内的其他数据的下标.</p> <p>内存空间：也主要是因为数据结构不一样，LinkedList 比 ArrayList 更占内存</p> <p>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全（看情况回答，一般回答这个问题，就会引出下一个问题，看下面）</p> <p><strong>面试官</strong>：嗯，好的，刚才你说了ArrayList 和 LinkedList 不是线程安全的，你们在项目中是如何解决这个的线程安全问题的？</p> <p><strong>候选人</strong>：</p> <p>嗯，是这样的，主要有两种解决方案：</p> <p>第一：我们使用这个集合，优先在方法内使用，定义为局部变量，这样的话，就不会出现线程安全问题。</p> <p>第二：如果非要在成员变量中使用的话，可以使用线程安全的集合来替代</p> <p>ArrayList可以通过Collections 的 synchronizedList 方法将 ArrayList 转换成线程安全的容器后再使用。</p> <p>LinkedList 换成ConcurrentLinkedQueue来使用</p></blockquote> <h3 id="_3-4-hashmap"><a href="#_3-4-hashmap" class="header-anchor">#</a> 3.4 HashMap</h3> <blockquote><p><strong>面试官</strong>：说一下HashMap的实现原理？</p> <p><strong>候选人</strong>：</p> <p>​	嗯。它主要分为了一下几个部分：</p> <p>当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标 。计算key时，有可能会先两种情况，一是key之前是存在的，则覆盖原始值；第二是key不同则将当前的key-value放入链表中 。</p> <p>其实在它的底层实现中jdk1.7和1.8是不一样的。JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8） 时且数组长度大于64时，将链表转化为红黑树，以减少搜索时间。扩容 时，红黑树拆分成的树的结点数小于等于临界值6个，则退化成链表。</p> <p>后期使用map获取值时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</p> <p><strong>面试官</strong>：好的，你能说下HashMap的put方法的具体流程吗？</p> <p><strong>候选人</strong>：</p> <p>嗯好的。</p> <p>在往hashmap中添加元素的时候。首先判断键值对数组是否为空或为null，否则执行扩容；根据键值key计算hash值得到插入的数组索引，如果数组为null，直接新建节点添加，插入成功后，判断实际存在的键值对数量size是否超多了最大容量，如果超过，进行扩 容</p> <p>如果数组不为空，判断数组的首个元素是否和key一样，如果相同直接覆盖value。</p> <p>这个时候还要判断数组的下标元素是否是一个红黑树，如果是红黑树则需要向树中添加键值对</p> <p>如果不是红黑树，则需要走链表的逻辑，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操 作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p> <p>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩 容。</p> <p><strong>面试官</strong>：好的，刚才你说的通过hash计算后找到数组的下标，是如何找到的呢，你了解hashMap的寻址算法吗？</p> <p><strong>候选人</strong>：</p> <p>这个哈希方法首先计算出key的hashCode值，然后通过这个hash值右移16位后的二进制进行按位<strong>异或运算</strong>得到最后的hash值。</p> <p>在putValue的方法中，计算数组下标的时候使用hash值与数组长度取模得到存储数据下标的位置，hashmap为了性能更好，并没有直接采用取模的方式，而是使用了数组长度-1 得到一个值，用这个值按位与运算hash值，最终得到数组的位置。</p> <p><strong>面试官</strong>：好的，刚才你多次介绍了hsahmap的扩容，能讲一讲HashMap的扩容机制吗？</p> <p><strong>候选人</strong>：</p> <p>好的，其实在jdk1.8中，resize方法是在hashmap中的键值对大于阀值(0.75)时或者初始化时，就调用resize方法进 行扩容；每次扩展的时候，都是扩展2倍； 扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</p> <p><strong>面试官</strong>：为何HashMap的数组长度一定是2的次幂？</p> <p><strong>候选人</strong>：</p> <p>嗯，好的。hashmap这么设计主要有两个原因：</p> <p>第一：</p> <p>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模</p> <p>第二：</p> <p>扩容时重新计算索引效率更高：在进行扩容是会进行判断 hash值按位与运算旧数组长租是否 == 0</p> <p>如果等于0，则把元素留在原来位置 ，否则新位置是等于旧位置的下标+旧数组长度</p> <p><strong>面试官</strong>：好的，我看你对hashmap了解的挺深入的，你知道hashmap在1.7情况下的多线程死循环问题吗？</p> <p><strong>候选人</strong>：</p> <p>嗯，知道的。是这样</p> <p>jdk7的的数据结构是：数组+链表</p> <p>在数组进行扩容的时候，因为链表是<strong>头插法</strong>，在进行数据迁移的过程中，有可能导致死循环</p> <p>比如说，现在有两个线程</p> <p>线程一：<strong>读取</strong>到当前的hashmap数据，数据中一个链表，在准备扩容时，线程二介入</p> <p>线程二也读取hashmap，直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。比如原来的顺序是AB，扩容后的顺序是BA，线程二执行结束。</p> <p>当线程一再继续执行的时候就会出现死循环的问题。</p> <p>线程一先将A移入新的链表，再将B插入到链头，由于另外一个线程的原因，B的next指向了A，所以B-&gt;A-&gt;B,形成循环。</p> <p>当然，JDK 8 将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），<strong>尾插法</strong>，就避免了jdk7中死循环的问题。</p> <p><strong>面试官</strong>：好的，hashmap是线程安全的吗？</p> <p><strong>候选人</strong>：不是线程安全的</p> <p><strong>面试官</strong>：那我们想要使用线程安全的map该怎么做呢？</p> <p><strong>候选人</strong>：我们可以采用ConcurrentHashMap进行使用，它是一个线程安全的HashMap</p> <p><strong>面试官</strong>：那你能聊一下ConcurrentHashMap的原理吗？</p> <p><strong>候选人</strong>：好的，请参考《多线程相关面试题》中的ConcurrentHashMap部分的讲解</p> <hr> <p><strong>面试官</strong>：HashSet与HashMap的区别？</p> <p><strong>候选人</strong>：嗯，是这样。</p> <p>HashSet底层其实是用HashMap实现存储的, HashSet封装了一系列HashMap的方法. 依靠HashMap来存储元素值,(利用hashMap的key键进行存储), 而value值默认为Object对象. 所以HashSet也不允许出现重复值, 判断标准和HashMap判断标准相同, 两个元素的hashCode相等并且通过equals()方法返回true.</p></blockquote></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新时间:</span> <span class="time">2023/10/29</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Java面试题/多线程面试题/多线程相关面试题.html" class="prev">
        多线程相关面试题
      </a></span> <span class="next"><a href="/Java面试题/Mybatis面试题/Mybatis面试题.html">
        Mybatis面试题
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a19eb3cb.js" defer></script><script src="/assets/js/2.34fff606.js" defer></script><script src="/assets/js/1.16393a26.js" defer></script><script src="/assets/js/72.fa131834.js" defer></script>
  </body>
</html>
