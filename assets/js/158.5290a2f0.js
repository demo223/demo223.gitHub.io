(window.webpackJsonp=window.webpackJsonp||[]).push([[158],{439:function(v,_,t){"use strict";t.r(_);var a=t(14),s=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"类和对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类和对象"}},[v._v("#")]),v._v(" 类和对象")]),v._v(" "),_("h2",{attrs:{id:"类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类"}},[v._v("#")]),v._v(" 类")]),v._v(" "),_("h3",{attrs:{id:"什么是类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是类"}},[v._v("#")]),v._v(" 什么是类？")]),v._v(" "),_("p",[v._v("类就是具备某些共同特征的实体的集合，它是一种抽象的数据类型，它是对所具有相同特征实体的抽象。在面向对象的程序设计语言中，"),_("strong",[v._v("类是对一类对象的属性与行为的描述")]),v._v("。")]),v._v(" "),_("p",[v._v("一个类可以包含以下类型变量：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("局部变量")]),v._v("：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。")]),v._v(" "),_("li",[_("strong",[v._v("成员变量")]),v._v("：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。")]),v._v(" "),_("li",[_("strong",[v._v("类变量")]),v._v("（也叫"),_("strong",[v._v("静态变量")]),v._v("）：类变量声明在类中，方法体之外，是类中独立于方法之外的变量，用static 修饰。")])]),v._v(" "),_("h3",{attrs:{id:"如何定义类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何定义类"}},[v._v("#")]),v._v(" 如何定义类？")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("类名"),_("strong",[v._v("首字母建议大写")]),v._v("，且有意义，满足“驼峰模式”。")])]),v._v(" "),_("li",[_("p",[v._v("一个Java文件中可以定义多个class类，但"),_("strong",[v._v("只能一个类是public修饰")]),v._v("，而且public修饰的类名必须成为代码文件名。 "),_("strong",[v._v("实际开发中建议还是一个文件定义一个class类")]),v._v("。")])]),v._v(" "),_("li",[_("p",[v._v("成员变量的完整定义格式是：修饰符 数据类型 变量名称； 一般无需指定初始化值，存在默认值。成员变量的数据类型可以是基本数据类型也可以是引用类型。")])])]),v._v(" "),_("h2",{attrs:{id:"对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对象"}},[v._v("#")]),v._v(" 对象")]),v._v(" "),_("p",[_("code",[v._v("Java")]),v._v(" 是面向对象的编程语言，对象就是面向对象程序设计的核心。所谓对象就是真实世界中的实体，对象与实体是一一对应的，也就是说现实世界中每一个实体都是一个对象，它是一种具体的概念。对象有以下特点：")]),v._v(" "),_("ul",[_("li",[v._v("对象具有属性和行为。")]),v._v(" "),_("li",[v._v("对象具有变化的状态。")]),v._v(" "),_("li",[v._v("对象具有唯一性。")]),v._v(" "),_("li",[v._v("对象都是某个类别的实例。")]),v._v(" "),_("li",[v._v("一切皆为对象，真实世界中的所有事物都可以视为对象。")])]),v._v(" "),_("h2",{attrs:{id:"面向对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#面向对象"}},[v._v("#")]),v._v(" 面向对象")]),v._v(" "),_("p",[v._v("面向对象的三大特征：封装、继承、多态。")]),v._v(" "),_("h3",{attrs:{id:"封装"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#封装"}},[v._v("#")]),v._v(" 封装")]),v._v(" "),_("p",[v._v("封装是"),_("strong",[v._v("将代码及其处理的数据绑定在一起的一种编程机制")]),v._v("，该机制保证了"),_("strong",[v._v("程序和数据都不受外部干扰且不被误用")]),v._v("。"),_("code",[v._v("封装的目的在于保护信息")])]),v._v(" "),_("h4",{attrs:{id:"封装的优点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#封装的优点"}},[v._v("#")]),v._v(" 封装的优点")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("保护类中的信息")]),v._v("，它可以阻止在外部定义的代码随意访问内部代码和数据。")]),v._v(" "),_("li",[_("strong",[v._v("隐藏细节信息")]),v._v("，一些不需要程序员修改和使用的信息，比如取款机中的键盘，用户只需要知道按哪个键实现什么操作就可以，至于它内部是如何运行的，用户不需要知道。")]),v._v(" "),_("li",[v._v("有助于建立各个系统之间的松耦合关系，"),_("strong",[v._v("提高系统的独立性")]),v._v("。当一个系统的实现方式发生变化时，只要它的接口不变，就不会影响其他系统的使用。例如 U 盘，不管里面的存储方式怎么改变，只要 U 盘上的 USB 接口不变，就不会影响用户的正常操作。")]),v._v(" "),_("li",[_("strong",[v._v("提高软件的复用率，降低成本")]),v._v("。每个系统都是一个相对独立的整体，可以在不同的环境中得到使用。例如，一个 U 盘可以在多台电脑上使用。")])]),v._v(" "),_("p",[_("code",[v._v("Java 语言的基本封装单位是类")]),v._v("。由于类的用途是封装复杂性，所以类的内部有隐藏实现复杂性的机制。Java 提供了私有和公有的访问模式，类的公有接口代表外部的用户应该知道或可以知道的每件东西，私有的方法数据只能通过该类的成员代码来访问，这就可以确保不会发生不希望的事情。")]),v._v(" "),_("h3",{attrs:{id:"继承"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[v._v("#")]),v._v(" 继承")]),v._v(" "),_("p",[v._v("继承就是"),_("strong",[v._v("子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为")]),v._v("。")]),v._v(" "),_("p",[v._v("父类有时也叫基类、超类；子类有时也被称为派生类。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20221009171409868.png",alt:"image-20221009171409868"}})]),v._v(" "),_("h4",{attrs:{id:"继承的优点和缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#继承的优点和缺点"}},[v._v("#")]),v._v(" 继承的优点和缺点")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("继承的好处")]),v._v(" "),_("ul",[_("li",[v._v("提高了代码的复用性")]),v._v(" "),_("li",[v._v("提高了代码的维护性")]),v._v(" "),_("li",[v._v("让类与类之间产生了关系，是多态的前提")])])]),v._v(" "),_("li",[_("p",[v._v("继承的弊端")])]),v._v(" "),_("li",[_("p",[v._v("类的耦合性提高了。")])]),v._v(" "),_("li",[_("p",[v._v("开发的原则：高内聚，低耦合。")])]),v._v(" "),_("li",[_("p",[v._v("耦合：类与类的关系")])]),v._v(" "),_("li",[_("p",[v._v("内聚：就是自己完成某件事情的能力")])])]),v._v(" "),_("h3",{attrs:{id:"多态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多态"}},[v._v("#")]),v._v(" 多态")]),v._v(" "),_("p",[v._v("多态是指"),_("strong",[v._v("在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为")]),v._v("，这使得同一个属性或方法在父类及其各个子类中具有不同的含义。")]),v._v(" "),_("p",[v._v("多态的优点")]),v._v(" "),_("h4",{attrs:{id:"多态的优点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多态的优点"}},[v._v("#")]),v._v(" 多态的优点")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("消除类型之间的耦合关系")])]),v._v(" "),_("li",[_("p",[v._v("可替换性")])]),v._v(" "),_("li",[_("p",[v._v("可扩充性")])]),v._v(" "),_("li",[_("p",[v._v("接口性")])]),v._v(" "),_("li",[_("p",[v._v("灵活性")])]),v._v(" "),_("li",[_("p",[v._v("简化性")])])])])}),[],!1,null,null,null);_.default=s.exports}}]);