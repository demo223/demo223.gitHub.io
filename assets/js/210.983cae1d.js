(window.webpackJsonp=window.webpackJsonp||[]).push([[210],{493:function(s,t,a){"use strict";a.r(t);var e=a(14),r=Object(e.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"分布式缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分布式缓存"}},[s._v("#")]),s._v(" 分布式缓存")]),s._v(" "),t("p",[s._v("基于Redis集群解决单机Redis存在的问题")]),s._v(" "),t("p",[s._v("单机的Redis存在四大问题：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725144240631.png",alt:"image-20210725144240631"}})]),s._v(" "),t("h1",{attrs:{id:"_1-redis持久化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-redis持久化"}},[s._v("#")]),s._v(" 1.Redis持久化")]),s._v(" "),t("p",[s._v("Redis有两种持久化方案：")]),s._v(" "),t("ul",[t("li",[s._v("RDB持久化")]),s._v(" "),t("li",[s._v("AOF持久化")])]),s._v(" "),t("h2",{attrs:{id:"_1-1-rdb持久化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-rdb持久化"}},[s._v("#")]),s._v(" 1.1.RDB持久化")]),s._v(" "),t("p",[s._v("RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。")]),s._v(" "),t("h3",{attrs:{id:"_1-1-1-执行时机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-1-执行时机"}},[s._v("#")]),s._v(" 1.1.1.执行时机")]),s._v(" "),t("p",[s._v("RDB持久化在四种情况下会执行：")]),s._v(" "),t("ul",[t("li",[s._v("执行save命令")]),s._v(" "),t("li",[s._v("执行bgsave命令")]),s._v(" "),t("li",[s._v("Redis停机时")]),s._v(" "),t("li",[s._v("触发RDB条件时")])]),s._v(" "),t("p",[t("strong",[s._v("1）save命令")])]),s._v(" "),t("p",[s._v("执行下面的命令，可以立即执行一次RDB：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725144536958.png",alt:"image-20210725144536958"}})]),s._v(" "),t("p",[s._v("save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。")]),s._v(" "),t("p",[t("strong",[s._v("查看日志信息：")])]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/1647075780141.png",alt:"1647075780141"}})]),s._v(" "),t("p",[t("strong",[s._v("2）bgsave命令")])]),s._v(" "),t("p",[s._v("下面的命令可以异步执行RDB：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725144725943.png",alt:"image-20210725144725943"}})]),s._v(" "),t("p",[s._v("这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。")]),s._v(" "),t("p",[t("strong",[s._v("查看日志信息：")])]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/1647075843288.png",alt:"1647075843288"}})]),s._v(" "),t("p",[t("strong",[s._v("3）停机时")])]),s._v(" "),t("p",[s._v("Redis停机时会执行一次save命令，实现RDB持久化。")]),s._v(" "),t("p",[t("strong",[s._v("4）触发RDB条件")])]),s._v(" "),t("p",[s._v("Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：")]),s._v(" "),t("div",{staticClass:"language-properties line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-properties"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v('# 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save "" 则表示禁用RDB')]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token key attr-name"}},[s._v("save")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token value attr-value"}},[s._v("900 1  ")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token key attr-name"}},[s._v("save")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token value attr-value"}},[s._v("300 10  ")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token key attr-name"}},[s._v("save")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token value attr-value"}},[s._v("60 10000 ")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("p",[s._v("RDB的其它配置也可以在redis.conf文件中设置：")]),s._v(" "),t("div",{staticClass:"language-properties line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-properties"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token key attr-name"}},[s._v("rdbcompression")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token value attr-value"}},[s._v("yes")]),s._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# RDB文件名称")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token key attr-name"}},[s._v("dbfilename")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token value attr-value"}},[s._v("dump.rdb  ")]),s._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 文件保存的路径目录")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token key attr-name"}},[s._v("dir")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token value attr-value"}},[s._v("./ ")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br")])]),t("h3",{attrs:{id:"_1-1-2-rdb原理-异步持久化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-2-rdb原理-异步持久化"}},[s._v("#")]),s._v(" 1.1.2.RDB原理-异步持久化")]),s._v(" "),t("p",[s._v("bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。")]),s._v(" "),t("p",[s._v("fork采用的是copy-on-write技术：")]),s._v(" "),t("ul",[t("li",[s._v("当主进程执行读操作时，访问共享内存；")]),s._v(" "),t("li",[s._v("当主进程执行写操作时，则会拷贝一份数据，执行写操作。")])]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725151319695.png",alt:"image-20210725151319695"}})]),s._v(" "),t("blockquote",[t("p",[s._v("页表：在Linux系统中所有的进程都没有办法直接操作物理内存，而是由每个进程分配一个虚拟内存，而操作系统会维护一个虚拟内存和物理内存之间的一个映射关系表，那么这个表就叫页表")]),s._v(" "),t("p",[s._v("具体执行流程")]),s._v(" "),t("p",[s._v("1、主进程执行fork创建子进程的时候，主进程是阻塞的")]),s._v(" "),t("p",[s._v("2、主进程操作页表进行读取物理内存数据A和数据B的时候，然后fork一个子进程，而fork复制仅仅是页表，那么此时子进程和主进程中的页表是一样的，那么就可以达到两个进程共享一套内存数据")]),s._v(" "),t("p",[s._v("3、那么此时子进程能够得到内存数据之后，就会写入RDB文件替换旧的RDB文件")]),s._v(" "),t("p",[s._v("但是此时有一个问题：既然是异步的，那么子进程在写RDB的过程中，主进程可能会修改内存中的数据，所以此时的情况是，子进程在读取共享内存数据，那么主进程在修改共享内存数据的话，这样就会出现脏数据")]),s._v(" "),t("p",[s._v("那怎么解决呢？")]),s._v(" "),t("p",[s._v("1、fork底层是采用copy-on-write(写时拷贝技术)，表示当我写的时候，我先拷贝一份")]),s._v(" "),t("p",[s._v("2、所以我们把共享数据设置成只读模式，任何进程只能读取共享内存数据，不能修改")]),s._v(" "),t("p",[s._v("3、那么加入主进程要进行对共享数据写操作的话，那么只能把共享数据完整拷贝一份出来，然后去修改这个备份数据，那么以后主进程读的时候也要读取备份数据。")]),s._v(" "),t("p",[s._v("4、所以每一次主进程要想写，那么就会拷贝数据，然后写入备份数据操作，这样就会避免脏数据出现")]),s._v(" "),t("p",[s._v("总的来说fork就是用两个进程，主进程会赋值一份数据进行修改，而子进程会将修改前的数据进行持久化到磁盘中，所以可以确认RDB文件备份一定会比当前修改版本落后。")])]),s._v(" "),t("h3",{attrs:{id:"_1-1-3-小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-3-小结"}},[s._v("#")]),s._v(" 1.1.3.小结")]),s._v(" "),t("p",[s._v("RDB方式bgsave的基本流程？")]),s._v(" "),t("ul",[t("li",[s._v("fork主进程得到一个子进程，共享内存空间")]),s._v(" "),t("li",[s._v("子进程读取内存数据并写入新的RDB文件")]),s._v(" "),t("li",[s._v("用新RDB文件替换旧的RDB文件")])]),s._v(" "),t("p",[s._v("RDB会在什么时候执行？save 60 1000代表什么含义？")]),s._v(" "),t("ul",[t("li",[s._v("默认是服务停止时")]),s._v(" "),t("li",[s._v("代表60秒内至少执行1000次修改则触发RDB")])]),s._v(" "),t("p",[s._v("RDB的缺点？")]),s._v(" "),t("ul",[t("li",[s._v("RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险")]),s._v(" "),t("li",[s._v("fork子进程、压缩、写出RDB文件都比较耗时")])]),s._v(" "),t("h2",{attrs:{id:"_1-2-aof持久化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-aof持久化"}},[s._v("#")]),s._v(" 1.2.AOF持久化")]),s._v(" "),t("h3",{attrs:{id:"_1-2-1-aof原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-1-aof原理"}},[s._v("#")]),s._v(" 1.2.1.AOF原理")]),s._v(" "),t("p",[s._v("AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725151543640.png",alt:"image-20210725151543640"}})]),s._v(" "),t("h3",{attrs:{id:"_1-2-2-aof配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-2-aof配置"}},[s._v("#")]),s._v(" 1.2.2.AOF配置")]),s._v(" "),t("p",[s._v("AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：")]),s._v(" "),t("div",{staticClass:"language-properties line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-properties"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 是否开启AOF功能，默认是no")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token key attr-name"}},[s._v("appendonly")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token value attr-value"}},[s._v("yes")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# AOF文件的名称")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token key attr-name"}},[s._v("appendfilename")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token value attr-value"}},[s._v('"appendonly.aof"')]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("p",[s._v("AOF的命令记录的频率也可以通过redis.conf文件来配：")]),s._v(" "),t("div",{staticClass:"language-properties line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-properties"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 表示每执行一次写命令，立即记录到AOF文件")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token key attr-name"}},[s._v("appendfsync")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token value attr-value"}},[s._v("always ")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token key attr-name"}},[s._v("appendfsync")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token value attr-value"}},[s._v("everysec ")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token key attr-name"}},[s._v("appendfsync")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token value attr-value"}},[s._v("no")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br")])]),t("p",[s._v("三种策略对比：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725151654046.png",alt:"image-20210725151654046"}})]),s._v(" "),t("h3",{attrs:{id:"_1-2-3-aof文件重写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-3-aof文件重写"}},[s._v("#")]),s._v(" 1.2.3.AOF文件重写")]),s._v(" "),t("p",[s._v("因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725151729118.png",alt:"image-20210725151729118"}})]),s._v(" "),t("p",[s._v("如图，AOF原本有三个命令，但是"),t("code",[s._v("set num 123 和 set num 666")]),s._v("都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。")]),s._v(" "),t("p",[s._v("所以重写命令后，AOF文件内容就是："),t("code",[s._v("mset name jack num 666")])]),s._v(" "),t("p",[s._v("Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：")]),s._v(" "),t("div",{staticClass:"language-properties line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-properties"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# AOF文件比上次文件 增长超过多少百分比则触发重写")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token key attr-name"}},[s._v("auto-aof-rewrite-percentage")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token value attr-value"}},[s._v("100")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# AOF文件体积最小多大以上才触发重写 ")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token key attr-name"}},[s._v("auto-aof-rewrite-min-size")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token value attr-value"}},[s._v("64mb ")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("h2",{attrs:{id:"_1-3-rdb与aof对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-rdb与aof对比"}},[s._v("#")]),s._v(" 1.3.RDB与AOF对比")]),s._v(" "),t("p",[s._v("RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会"),t("strong",[s._v("结合")]),s._v("两者来使用。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725151940515.png",alt:"image-20210725151940515"}})]),s._v(" "),t("h1",{attrs:{id:"_2-redis主从"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-redis主从"}},[s._v("#")]),s._v(" 2.Redis主从")]),s._v(" "),t("h2",{attrs:{id:"_2-1-搭建主从架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-搭建主从架构"}},[s._v("#")]),s._v(" 2.1.搭建主从架构")]),s._v(" "),t("p",[s._v("单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725152037611.png",alt:"image-20210725152037611"}})]),s._v(" "),t("p",[s._v("具体搭建流程参考课前资料《Redis集群.md》：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725152052501.png",alt:"image-20210725152052501"}})]),s._v(" "),t("h2",{attrs:{id:"_2-2-主从数据同步原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-主从数据同步原理"}},[s._v("#")]),s._v(" 2.2.主从数据同步原理")]),s._v(" "),t("h3",{attrs:{id:"_2-2-1-全量同步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-全量同步"}},[s._v("#")]),s._v(" 2.2.1.全量同步")]),s._v(" "),t("p",[s._v("主从第一次建立连接时，会执行"),t("strong",[s._v("全量同步")]),s._v("，将master节点的所有数据都拷贝给slave节点，流程：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725152222497.png",alt:"image-20210725152222497"}})]),s._v(" "),t("p",[s._v("这里有一个问题，master如何得知salve是第一次来连接呢？？")]),s._v(" "),t("p",[s._v("有几个概念，可以作为判断依据：")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("Replication Id")]),s._v("：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid")]),s._v(" "),t("li",[t("strong",[s._v("offset")]),s._v("：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。")])]),s._v(" "),t("p",[s._v("因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据。")]),s._v(" "),t("p",[s._v("因为slave原本也是一个master，有自己的replid和offset，当第一次变成slave，与master建立连接时，发送的replid和offset是自己的replid和offset。")]),s._v(" "),t("p",[s._v("master判断发现slave发送来的replid与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。")]),s._v(" "),t("p",[s._v("master会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master一致了。")]),s._v(" "),t("p",[s._v("因此，"),t("strong",[s._v("master判断一个节点是否是第一次同步的依据，就是看replid是否一致")]),s._v("。")]),s._v(" "),t("p",[s._v("如图：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725152700914.png",alt:"image-20210725152700914"}})]),s._v(" "),t("p",[s._v("完整流程描述：")]),s._v(" "),t("ul",[t("li",[s._v("slave节点请求增量同步")]),s._v(" "),t("li",[s._v("master节点判断replid，发现不一致，拒绝增量同步")]),s._v(" "),t("li",[s._v("master将完整内存数据生成RDB，发送RDB到slave")]),s._v(" "),t("li",[s._v("slave清空本地数据，加载master的RDB")]),s._v(" "),t("li",[s._v("master将RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给slave")]),s._v(" "),t("li",[s._v("slave执行接收到的命令，保持与master之间的同步")])]),s._v(" "),t("h3",{attrs:{id:"_2-2-2-增量同步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2-增量同步"}},[s._v("#")]),s._v(" 2.2.2.增量同步")]),s._v(" "),t("p",[s._v("全量同步需要先做RDB，然后将RDB文件通过网络传输个slave，成本太高了。因此除了第一次做全量同步，其它大多数时候slave与master都是做"),t("strong",[s._v("增量同步")]),s._v("。")]),s._v(" "),t("p",[s._v("什么是增量同步？就是只更新slave与master存在差异的部分数据。如图：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725153201086.png",alt:"image-20210725153201086"}})]),s._v(" "),t("p",[s._v("那么master怎么知道slave与自己的数据差异在哪里呢?")]),s._v(" "),t("h3",{attrs:{id:"_2-2-3-repl-backlog原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-3-repl-backlog原理"}},[s._v("#")]),s._v(" 2.2.3.repl_backlog原理")]),s._v(" "),t("p",[s._v("master怎么知道slave与自己的数据差异在哪里呢?")]),s._v(" "),t("p",[s._v("这就要说到全量同步时的repl_baklog文件了。")]),s._v(" "),t("p",[s._v("这个文件是一个固定大小的数组，只不过数组是环形，也就是说"),t("strong",[s._v("角标到达数组末尾后，会再次从0开始读写")]),s._v("，这样数组头部的数据就会被覆盖。")]),s._v(" "),t("p",[s._v("repl_baklog中会记录Redis处理过的命令日志及offset，包括master当前的offset，和slave已经拷贝到的offset：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725153359022.png",alt:"image-20210725153359022"}})]),s._v(" "),t("p",[s._v("slave与master的offset之间的差异，就是salve需要增量拷贝的数据了。")]),s._v(" "),t("p",[s._v("随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725153524190.png",alt:"image-20210725153524190"}})]),s._v(" "),t("p",[s._v("直到数组被填满：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725153715910.png",alt:"image-20210725153715910"}})]),s._v(" "),t("p",[s._v("此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分。")]),s._v(" "),t("p",[s._v("但是，如果slave出现网络阻塞，导致master的offset远远超过了slave的offset：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725153937031.png",alt:"image-20210725153937031"}})]),s._v(" "),t("p",[s._v("如果master继续写入新数据，其offset就会覆盖旧的数据，直到将slave现在的offset也覆盖：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725154155984.png",alt:"image-20210725154155984"}})]),s._v(" "),t("p",[s._v("棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的offset都没有了，无法完成增量同步了。只能做全量同步。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725154216392.png",alt:"image-20210725154216392"}})]),s._v(" "),t("h2",{attrs:{id:"_2-3-主从同步优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-主从同步优化"}},[s._v("#")]),s._v(" 2.3.主从同步优化")]),s._v(" "),t("p",[s._v("主从同步可以保证主从数据的一致性，非常重要。")]),s._v(" "),t("p",[s._v("可以从以下几个方面来优化Redis主从就集群：")]),s._v(" "),t("ul",[t("li",[s._v("在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。")]),s._v(" "),t("li",[s._v("Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO")]),s._v(" "),t("li",[s._v("适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步")]),s._v(" "),t("li",[s._v("限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力")])]),s._v(" "),t("p",[s._v("主从从架构图：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725154405899.png",alt:"image-20210725154405899"}})]),s._v(" "),t("h2",{attrs:{id:"_2-4-小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-小结"}},[s._v("#")]),s._v(" 2.4.小结")]),s._v(" "),t("p",[s._v("简述全量同步和增量同步区别？")]),s._v(" "),t("ul",[t("li",[s._v("全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。")]),s._v(" "),t("li",[s._v("增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave")])]),s._v(" "),t("p",[s._v("什么时候执行全量同步？")]),s._v(" "),t("ul",[t("li",[s._v("slave节点第一次连接master节点时")]),s._v(" "),t("li",[s._v("slave节点断开时间太久，repl_baklog中的offset已经被覆盖时")])]),s._v(" "),t("p",[s._v("什么时候执行增量同步？")]),s._v(" "),t("ul",[t("li",[s._v("slave节点断开又恢复，并且在repl_baklog中能找到offset时")])]),s._v(" "),t("h1",{attrs:{id:"_3-redis哨兵"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-redis哨兵"}},[s._v("#")]),s._v(" 3.Redis哨兵")]),s._v(" "),t("p",[s._v("Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。")]),s._v(" "),t("h2",{attrs:{id:"_3-1-哨兵原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-哨兵原理"}},[s._v("#")]),s._v(" 3.1.哨兵原理")]),s._v(" "),t("h3",{attrs:{id:"_3-1-1-集群结构和作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-1-集群结构和作用"}},[s._v("#")]),s._v(" 3.1.1.集群结构和作用")]),s._v(" "),t("p",[s._v("哨兵的结构如图：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725154528072.png",alt:"image-20210725154528072"}})]),s._v(" "),t("p",[s._v("哨兵的作用如下：")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("监控")]),s._v("：Sentinel 会不断检查您的master和slave是否按预期工作")]),s._v(" "),t("li",[t("strong",[s._v("自动故障恢复")]),s._v("：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主")]),s._v(" "),t("li",[t("strong",[s._v("通知")]),s._v("：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端")])]),s._v(" "),t("h3",{attrs:{id:"_3-1-2-集群监控原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-2-集群监控原理"}},[s._v("#")]),s._v(" 3.1.2.集群监控原理")]),s._v(" "),t("p",[s._v("Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：")]),s._v(" "),t("p",[s._v("•主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例"),t("strong",[s._v("主观下线")]),s._v("。")]),s._v(" "),t("p",[s._v("•客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例"),t("strong",[s._v("客观下线")]),s._v("。quorum值最好超过Sentinel实例数量的一半。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725154632354.png",alt:"image-20210725154632354"}})]),s._v(" "),t("h3",{attrs:{id:"_3-1-3-集群故障恢复原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-3-集群故障恢复原理"}},[s._v("#")]),s._v(" 3.1.3.集群故障恢复原理")]),s._v(" "),t("p",[s._v("一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：")]),s._v(" "),t("ul",[t("li",[s._v("首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds[Sentinel判断实例进入主观下线所需的时间长度] * 10）则会排除该slave节点")]),s._v(" "),t("li",[s._v("然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举")]),s._v(" "),t("li",[s._v("如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高")]),s._v(" "),t("li",[s._v("最后是判断slave节点的运行id大小，越小优先级越高。")])]),s._v(" "),t("p",[s._v("当选出一个新的master后，该如何实现切换呢？")]),s._v(" "),t("p",[s._v("流程如下：")]),s._v(" "),t("ul",[t("li",[s._v("sentinel给备选的slave1节点发送slaveof no one命令，让该节点成为master")]),s._v(" "),t("li",[s._v("sentinel给所有其它slave发送slaveof 192.168.150.101 7002 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。")]),s._v(" "),t("li",[s._v("最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点")])]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725154816841.png",alt:"image-20210725154816841"}})]),s._v(" "),t("h3",{attrs:{id:"_3-1-4-小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-4-小结"}},[s._v("#")]),s._v(" 3.1.4.小结")]),s._v(" "),t("p",[s._v("Sentinel的三个作用是什么？")]),s._v(" "),t("ul",[t("li",[s._v("监控")]),s._v(" "),t("li",[s._v("故障转移")]),s._v(" "),t("li",[s._v("通知")])]),s._v(" "),t("p",[s._v("Sentinel如何判断一个redis实例是否健康？")]),s._v(" "),t("ul",[t("li",[s._v("每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主观下线")]),s._v(" "),t("li",[s._v("如果大多数sentinel都认为实例主观下线，则判定服务下线")])]),s._v(" "),t("p",[s._v("故障转移步骤有哪些？")]),s._v(" "),t("ul",[t("li",[s._v("首先选定一个slave作为新的master，执行slaveof no one")]),s._v(" "),t("li",[s._v("然后让所有节点都执行slaveof 新master")]),s._v(" "),t("li",[s._v("修改故障节点配置，添加slaveof 新master")])]),s._v(" "),t("h2",{attrs:{id:"_3-2-搭建哨兵集群"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-搭建哨兵集群"}},[s._v("#")]),s._v(" 3.2.搭建哨兵集群")]),s._v(" "),t("p",[s._v("具体搭建流程参考课前资料《Redis集群.md》：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725155019276.png",alt:"image-20210725155019276"}})]),s._v(" "),t("h2",{attrs:{id:"_3-3-redistemplate"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-redistemplate"}},[s._v("#")]),s._v(" 3.3.RedisTemplate")]),s._v(" "),t("p",[s._v("在Sentinel集群监管下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化，及时更新连接信息。Spring的RedisTemplate底层利用lettuce实现了节点的感知和自动切换。")]),s._v(" "),t("p",[s._v("下面，我们通过一个测试来实现RedisTemplate集成哨兵机制。")]),s._v(" "),t("h3",{attrs:{id:"_3-3-1-导入demo工程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-1-导入demo工程"}},[s._v("#")]),s._v(" 3.3.1.导入Demo工程")]),s._v(" "),t("p",[s._v("首先，我们引入课前资料提供的Demo工程：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725155124958.png",alt:"image-20210725155124958"}})]),s._v(" "),t("h3",{attrs:{id:"_3-3-2-引入依赖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-2-引入依赖"}},[s._v("#")]),s._v(" 3.3.2.引入依赖")]),s._v(" "),t("p",[s._v("在项目的pom文件中引入依赖：")]),s._v(" "),t("div",{staticClass:"language-xml line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-xml"}},[t("code",[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),s._v("dependency")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),s._v("groupId")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v("org.springframework.boot"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("</")]),s._v("groupId")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),s._v("artifactId")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v("spring-boot-starter-data-redis"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("</")]),s._v("artifactId")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("</")]),s._v("dependency")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("h3",{attrs:{id:"_3-3-3-配置redis地址"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-3-配置redis地址"}},[s._v("#")]),s._v(" 3.3.3.配置Redis地址")]),s._v(" "),t("p",[s._v("然后在配置文件application.yml中指定redis的sentinel相关信息：")]),s._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[s._v("spring"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v("\n  redis"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v("\n    sentinel"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v("\n      master"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" mymaster\n      nodes"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("192.168")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v(".150")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v(".101")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("27001")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("192.168")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v(".150")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v(".101")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("27002")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("192.168")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v(".150")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v(".101")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("27003")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br")])]),t("h3",{attrs:{id:"_3-3-4-配置读写分离"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-4-配置读写分离"}},[s._v("#")]),s._v(" 3.3.4.配置读写分离")]),s._v(" "),t("p",[s._v("在项目的启动类中，添加一个新的bean：")]),s._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[s._v("@Bean")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("LettuceClientConfigurationBuilderCustomizer")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("clientConfigurationBuilderCustomizer")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" clientConfigurationBuilder "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("->")]),s._v(" clientConfigurationBuilder"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("readFrom")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("ReadFrom")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token constant"}},[s._v("REPLICA_PREFERRED")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("p",[s._v("这个bean中配置的就是读写策略，包括四种：")]),s._v(" "),t("ul",[t("li",[s._v("MASTER：从主节点读取")]),s._v(" "),t("li",[s._v("MASTER_PREFERRED：优先从master节点读取，master不可用才读取replica")]),s._v(" "),t("li",[s._v("REPLICA：从slave（replica）节点读取")]),s._v(" "),t("li",[s._v("REPLICA _PREFERRED：优先从slave（replica）节点读取，所有的slave都不可用才读取master")])]),s._v(" "),t("h1",{attrs:{id:"_4-redis分片集群"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-redis分片集群"}},[s._v("#")]),s._v(" 4.Redis分片集群")]),s._v(" "),t("h2",{attrs:{id:"_4-1-搭建分片集群"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-搭建分片集群"}},[s._v("#")]),s._v(" 4.1.搭建分片集群")]),s._v(" "),t("p",[s._v("主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("海量数据存储问题")])]),s._v(" "),t("li",[t("p",[s._v("高并发写的问题")])])]),s._v(" "),t("p",[s._v("使用分片集群可以解决上述问题，如图:")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725155747294.png",alt:"image-20210725155747294"}})]),s._v(" "),t("p",[s._v("分片集群特征：")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("集群中有多个master，每个master保存不同数据")])]),s._v(" "),t("li",[t("p",[s._v("每个master都可以有多个slave节点")])]),s._v(" "),t("li",[t("p",[s._v("master之间通过ping监测彼此健康状态")])]),s._v(" "),t("li",[t("p",[s._v("客户端请求可以访问集群任意节点，最终都会被转发到正确节点")])])]),s._v(" "),t("p",[s._v("具体搭建流程参考课前资料《Redis集群.md》：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725155806288.png",alt:"image-20210725155806288"}})]),s._v(" "),t("h2",{attrs:{id:"_4-2-散列插槽"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-散列插槽"}},[s._v("#")]),s._v(" 4.2.散列插槽")]),s._v(" "),t("h3",{attrs:{id:"_4-2-1-插槽原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-1-插槽原理"}},[s._v("#")]),s._v(" 4.2.1.插槽原理")]),s._v(" "),t("p",[s._v("Redis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上，查看集群信息时就能看到：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725155820320.png",alt:"image-20210725155820320"}})]),s._v(" "),t("p",[s._v("数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：")]),s._v(" "),t("ul",[t("li",[s._v('key中包含"{}"，且“{}”中至少包含1个字符，“{}”中的部分是有效部分')]),s._v(" "),t("li",[s._v("key中不包含“{}”，整个key都是有效部分")])]),s._v(" "),t("p",[s._v("例如：key是num，那么就根据num计算，如果是{itcast}num，则根据itcast计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725155850200.png",alt:"image-20210725155850200"}})]),s._v(" "),t("p",[s._v("如图，在7001这个节点执行set a 1时，对a做hash运算，对16384取余，得到的结果是15495，因此要存储到103节点。")]),s._v(" "),t("p",[s._v("到了7003后，执行"),t("code",[s._v("get num")]),s._v("时，对num做hash运算，对16384取余，得到的结果是2765，因此需要切换到7001节点")]),s._v(" "),t("h3",{attrs:{id:"_4-2-1-小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-1-小结"}},[s._v("#")]),s._v(" 4.2.1.小结")]),s._v(" "),t("p",[s._v("Redis如何判断某个key应该在哪个实例？")]),s._v(" "),t("ul",[t("li",[s._v("将16384个插槽分配到不同的实例")]),s._v(" "),t("li",[s._v("根据key的有效部分计算哈希值，对16384取余")]),s._v(" "),t("li",[s._v("余数作为插槽，寻找插槽所在实例即可")])]),s._v(" "),t("p",[s._v("如何将同一类数据固定的保存在同一个Redis实例？")]),s._v(" "),t("ul",[t("li",[s._v("这一类数据使用相同的有效部分，例如key都以{typeId}为前缀")])]),s._v(" "),t("h2",{attrs:{id:"_4-3-集群伸缩"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-集群伸缩"}},[s._v("#")]),s._v(" 4.3.集群伸缩")]),s._v(" "),t("p",[s._v("redis-cli --cluster提供了很多操作集群的命令，可以通过下面方式查看：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725160138290.png",alt:"image-20210725160138290"}})]),s._v(" "),t("p",[s._v("比如，添加节点的命令：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725160448139.png",alt:"image-20210725160448139"}})]),s._v(" "),t("h3",{attrs:{id:"_4-3-1-需求分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-1-需求分析"}},[s._v("#")]),s._v(" 4.3.1.需求分析")]),s._v(" "),t("p",[s._v("需求：向集群中添加一个新的master节点，并向其中存储 num = 10")]),s._v(" "),t("ul",[t("li",[s._v("启动一个新的redis实例，端口为7004")]),s._v(" "),t("li",[s._v("添加7004到之前的集群，并作为一个master节点")]),s._v(" "),t("li",[s._v("给7004节点分配插槽，使得num这个key可以存储到7004实例")])]),s._v(" "),t("p",[s._v("这里需要两个新的功能：")]),s._v(" "),t("ul",[t("li",[s._v("添加一个节点到集群中")]),s._v(" "),t("li",[s._v("将部分插槽分配到新插槽")])]),s._v(" "),t("h3",{attrs:{id:"_4-3-2-创建新的redis实例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-2-创建新的redis实例"}},[s._v("#")]),s._v(" 4.3.2.创建新的redis实例")]),s._v(" "),t("p",[s._v("docker操作如下：")]),s._v(" "),t("div",{staticClass:"language-properties line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-properties"}},[t("code",[t("span",{pre:!0,attrs:{class:"token key attr-name"}},[s._v("docker")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token value attr-value"}},[s._v("run -d --name redis7  \\\n--net host  \\\n--privileged=true redis:6.2.4  \\\n--cluster-enabled yes --appendonly yes --port 7004")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("h3",{attrs:{id:"_4-3-3-添加新节点到redis"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-3-添加新节点到redis"}},[s._v("#")]),s._v(" 4.3.3.添加新节点到redis")]),s._v(" "),t("p",[s._v("添加节点的语法如下：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725160448139.png",alt:"image-20210725160448139"}})]),s._v(" "),t("p",[s._v("执行命令：")]),s._v(" "),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("redis-cli "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[s._v("--cluster")]),s._v(" add-node  "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("192.168")]),s._v(".33.31:7004 "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("192.168")]),s._v(".33.31:7001\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("通过命令查看集群状态：")]),s._v(" "),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("redis-cli "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[s._v("-p")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("7001")]),s._v(" cluster nodes\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("如图，7004加入了集群，并且默认是一个master节点：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725161007099.png",alt:"image-20210725161007099"}})]),s._v(" "),t("p",[s._v("但是，可以看到7004节点的插槽数量为0，因此没有任何数据可以存储到7004上")]),s._v(" "),t("h3",{attrs:{id:"_4-3-4-转移插槽"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-4-转移插槽"}},[s._v("#")]),s._v(" 4.3.4.转移插槽")]),s._v(" "),t("p",[s._v("我们要将num存储到7004节点，因此需要先看看num的插槽是多少：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725161241793.png",alt:"image-20210725161241793"}})]),s._v(" "),t("p",[s._v("如上图所示，num的插槽为2765.")]),s._v(" "),t("p",[s._v("我们可以将0~3000的插槽从7001转移到7004，命令格式如下：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725161401925.png",alt:"image-20210725161401925"}})]),s._v(" "),t("p",[s._v("具体命令如下：")]),s._v(" "),t("p",[s._v("建立连接：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725161506241.png",alt:"image-20210725161506241"}})]),s._v(" "),t("p",[s._v("代码如下：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("redis-cli --cluster reshard 192.168.33.31:7001\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("得到下面的反馈：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725161540841.png",alt:"image-20210725161540841"}})]),s._v(" "),t("p",[s._v("询问要移动多少个插槽，我们计划是3000个：")]),s._v(" "),t("p",[s._v("新的问题来了：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725161637152.png",alt:"image-20210725161637152"}})]),s._v(" "),t("p",[s._v("那个node来接收这些插槽？？")]),s._v(" "),t("p",[s._v("显然是7004，那么7004节点的id是多少呢？")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725161731738.png",alt:"image-20210725161731738"}})]),s._v(" "),t("p",[s._v("复制这个id，然后拷贝到刚才的控制台后：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725161817642.png",alt:"image-20210725161817642"}})]),s._v(" "),t("p",[s._v("这里询问，你的插槽是从哪里移动过来的？")]),s._v(" "),t("ul",[t("li",[s._v("all：代表全部，也就是三个节点各转移一部分")]),s._v(" "),t("li",[s._v("具体的id：目标节点的id")]),s._v(" "),t("li",[s._v("done：没有了")])]),s._v(" "),t("p",[s._v("这里我们要从7001获取，因此填写7001的id：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725162030478.png",alt:"image-20210725162030478"}})]),s._v(" "),t("p",[s._v("填完后，点击done，这样插槽转移就准备好了：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725162101228.png",alt:"image-20210725162101228"}})]),s._v(" "),t("p",[s._v("确认要转移吗？输入yes：")]),s._v(" "),t("p",[s._v("然后，通过命令"),t("code",[s._v("redis-cli -p 7001 cluster nodes")]),s._v("查看结果：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725162145497.png",alt:"image-20210725162145497"}})]),s._v(" "),t("p",[s._v("可以看到：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725162224058.png",alt:"image-20210725162224058"}})]),s._v(" "),t("p",[s._v("目的达成。")]),s._v(" "),t("h3",{attrs:{id:"_4-3-5-删除集群中的一个节点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-5-删除集群中的一个节点"}},[s._v("#")]),s._v(" 4.3.5 删除集群中的一个节点")]),s._v(" "),t("p",[s._v("注意：在删除master节点之前，要先保证当前master节点中的槽要先转移到别的master的节点上")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/1647100011943.png",alt:"1647100011943"}})]),s._v(" "),t("p",[s._v("第一步，转移槽到别的节点上")]),s._v(" "),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#语法：")]),s._v("\nredis-cli "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[s._v("--cluster")]),s._v(" reshard IP:port\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#具体命令")]),s._v("\nredis-cli  "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[s._v("--cluster")]),s._v(" reshard "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("192.168")]),s._v(".200.137:7004\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/1647100103457.png",alt:"1647100103457"}})]),s._v(" "),t("p",[s._v("第二步，删除节点")]),s._v(" "),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#语法")]),s._v("\nredis-cli "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[s._v("--cluster")]),s._v(" del-node IP:port 节点的id\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#具体命令")]),s._v("\nredis-cli "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[s._v("--cluster")]),s._v(" del-node "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("192.168")]),s._v(".200.128:7004 0746ccdcd7bb03cd86470998e9a9aabcb11b397d\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/1647100372962.png",alt:"1647100372962"}})]),s._v(" "),t("p",[s._v("第三步，查看集群节点信息，发现没有了7004节点")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/1647100403487.png",alt:"1647100403487"}})]),s._v(" "),t("h2",{attrs:{id:"_4-4-故障转移"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-故障转移"}},[s._v("#")]),s._v(" 4.4.故障转移")]),s._v(" "),t("p",[s._v("集群初识状态是这样的：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210727161152065.png",alt:"image-20210727161152065"}})]),s._v(" "),t("p",[s._v("其中7001、7002、7003都是master，我们计划让7002宕机。")]),s._v(" "),t("h3",{attrs:{id:"_4-4-1-自动故障转移"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-1-自动故障转移"}},[s._v("#")]),s._v(" 4.4.1.自动故障转移")]),s._v(" "),t("p",[s._v("当集群中有一个master宕机会发生什么呢？")]),s._v(" "),t("p",[s._v("直接停止一个redis实例，例如7002：")]),s._v(" "),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("redis-cli "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[s._v("-p")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("7002")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("shutdown")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("1）首先是该实例与其它实例失去连接")]),s._v(" "),t("p",[s._v("2）然后是疑似宕机：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725162319490.png",alt:"image-20210725162319490"}})]),s._v(" "),t("p",[s._v("3）最后是确定下线，自动提升一个slave为新的master：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725162408979.png",alt:"image-20210725162408979"}})]),s._v(" "),t("p",[s._v("4）当7002再次启动，就会变为一个slave节点了：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210727160803386.png",alt:"image-20210727160803386"}})]),s._v(" "),t("h3",{attrs:{id:"_4-4-2-手动故障转移"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-2-手动故障转移"}},[s._v("#")]),s._v(" 4.4.2.手动故障转移")]),s._v(" "),t("p",[s._v("利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。其流程如下：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210725162441407.png",alt:"image-20210725162441407"}})]),s._v(" "),t("p",[s._v("这种failover命令可以指定三种模式：")]),s._v(" "),t("ul",[t("li",[s._v("缺省：默认的流程，如图1~6歩")]),s._v(" "),t("li",[s._v("force：省略了对offset的一致性校验")]),s._v(" "),t("li",[s._v("takeover：直接执行第5歩，忽略数据一致性、忽略master状态和其它master的意见")])]),s._v(" "),t("p",[t("strong",[s._v("案例需求")]),s._v("：在7002这个slave节点执行手动故障转移，重新夺回master地位")]),s._v(" "),t("p",[s._v("步骤如下：")]),s._v(" "),t("p",[s._v("1）利用redis-cli连接7002这个节点")]),s._v(" "),t("p",[s._v("2）执行cluster failover命令")]),s._v(" "),t("p",[s._v("如图：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20210727160037766.png",alt:"image-20210727160037766"}})]),s._v(" "),t("p",[s._v("效果：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20230214141904786.png",alt:"image-20230214141904786"}})]),s._v(" "),t("h2",{attrs:{id:"_4-5-redistemplate访问分片集群"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-redistemplate访问分片集群"}},[s._v("#")]),s._v(" 4.5.RedisTemplate访问分片集群")]),s._v(" "),t("p",[s._v("RedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致：")]),s._v(" "),t("p",[s._v("1）引入redis的starter依赖")]),s._v(" "),t("p",[s._v("2）配置分片集群地址")]),s._v(" "),t("p",[s._v("3）配置读写分离")]),s._v(" "),t("p",[s._v("​\t参考redis哨兵")]),s._v(" "),t("p",[s._v("与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下：")]),s._v(" "),t("div",{staticClass:"language-yaml line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-yaml"}},[t("code",[t("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("spring")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("redis")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("cluster")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n      "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("nodes")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v(" 192.168.33.31"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("7001")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v(" 192.168.33.31"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("7002")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v(" 192.168.33.31"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("7003")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v(" 192.168.33.31"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("8001")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v(" 192.168.33.31"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("8002")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v(" 192.168.33.31"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("8003")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br")])])])}),[],!1,null,null,null);t.default=r.exports}}]);