(window.webpackJsonp=window.webpackJsonp||[]).push([[246],{527:function(e,a,r){"use strict";r.r(a);var o=r(14),v=Object(o.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"kafka使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kafka使用"}},[e._v("#")]),e._v(" kafka使用")]),e._v(" "),a("p",[e._v("说说你对kafka的理解")]),e._v(" "),a("p",[e._v("kafka是一个流式数据处理平台，他具有消息系统的能力，也有实时流式数据处理分析能力，只是我们更多的偏向于把他当做消息队列系统来使用。")]),e._v(" "),a("p",[e._v("如果说按照容易理解来分层的话，大致可以分为3层：")]),e._v(" "),a("p",[e._v("第一层是Zookeeper，相当于注册中心，他负责kafka集群元数据的管理，以及集群的协调工作，在每个kafka服务器启动的时候去连接到Zookeeper，把自己注册到Zookeeper当中")]),e._v(" "),a("p",[e._v("第二层里是kafka的核心层，这里就会包含很多kafka的基本概念在内：")]),e._v(" "),a("p",[e._v("record：代表消息")]),e._v(" "),a("p",[e._v("topic：主题，消息都会由一个主题方式来组织，可以理解为对于消息的一个分类")]),e._v(" "),a("p",[e._v("producer：生产者，负责发送消息")]),e._v(" "),a("p",[e._v("consumer：消费者，负责消费消息")]),e._v(" "),a("p",[e._v("broker：kafka服务器")]),e._v(" "),a("p",[e._v("partition：分区，主题会由多个分区组成，通常每个分区的消息都是按照顺序读取的，不同的分区无法保证顺序性，分区也就是我们常说的数据分片sharding机制，主要目的就是为了提高系统的伸缩能力，通过分区，消息的读写可以负载均衡到多个不同的节点上")]),e._v(" "),a("p",[e._v("Leader/Follower：分区的副本。为了保证高可用，分区都会有一些副本，每个分区都会有一个Leader主副本负责读写数据，Follower从副本只负责和Leader副本保持数据同步，不对外提供任何服务")]),e._v(" "),a("p",[e._v("offset：偏移量，分区中的每一条消息都会根据时间先后顺序有一个递增的序号，这个序号就是offset偏移量")]),e._v(" "),a("p",[e._v("Consumer group：消费者组，由多个消费者组成，一个组内只会由一个消费者去消费一个分区的消息")]),e._v(" "),a("p",[e._v("Coordinator：协调者，主要是为消费者组分配分区以及重平衡Rebalance操作")]),e._v(" "),a("p",[e._v("Controller：控制器，其实就是一个broker而已，用于协调和管理整个Kafka集群，他会负责分区Leader选举、主题管理等工作，在Zookeeper第一个创建临时节点/controller的就会成为控制器")]),e._v(" "),a("p",[e._v("第三层则是存储层，用来保存kafka的核心数据，他们都会以日志的形式最终写入磁盘中。")])])}),[],!1,null,null,null);a.default=v.exports}}]);