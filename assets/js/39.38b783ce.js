(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{321:function(v,_,e){"use strict";e.r(_);var i=e(14),t=Object(i.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("blockquote",[_("p",[v._v("请你说说ArrayList和LinkedList的区别？")])]),v._v(" "),_("p",[v._v("得分点")]),v._v(" "),_("ul",[_("li",[v._v("数据结构")]),v._v(" "),_("li",[v._v("访问效率")])]),v._v(" "),_("p",[_("strong",[v._v("标准回答")]),v._v("：")]),v._v(" "),_("p",[_("code",[v._v("ArrayList")]),v._v("的实现是基于数组")]),v._v(" "),_("p",[_("code",[v._v("LinkedList")]),v._v("的实现是基于双向链表")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("随机访问效率：")]),v._v(" "),_("p",[v._v("对于随机访问"),_("code",[v._v("ArrayList")]),v._v("要优于"),_("code",[v._v("LinkedList")]),v._v("，"),_("code",[v._v("ArrayList")]),v._v("可以根据下标以"),_("code",[v._v("O(1)")]),v._v("时间复杂度对元素进行随机访问，而"),_("code",[v._v("LinkedList")]),v._v("的每一个元素都依靠地址指针和它后一个元素连接在一起，查找某个元素的时间复杂度是"),_("code",[v._v("O(N)")]),v._v("。")])]),v._v(" "),_("li",[_("p",[v._v("增加和删除效率：在非首尾的增加和删除操作，"),_("code",[v._v("LinkedList")]),v._v("要比 "),_("code",[v._v("ArrayList")]),v._v("效率 要高，因为 "),_("code",[v._v("ArrayList")]),v._v("增删操作要影响数组内的其他数据的下标。")])]),v._v(" "),_("li",[_("p",[v._v("内存空间占用："),_("code",[v._v("LinkedList")]),v._v("比 "),_("code",[v._v("ArrayList")]),v._v("更占内存，因为 "),_("code",[v._v("LinkedList")]),v._v("的节点除 了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。")])]),v._v(" "),_("li",[_("p",[v._v("线程安全："),_("code",[v._v("ArrayList")]),v._v("和 "),_("code",[v._v("LinkedList")]),v._v("都是不同步的，也就是不保证线程安全；")])])]),v._v(" "),_("p",[v._v("综合来说，在需要频繁读取集合中的元素时，更推荐使用 "),_("code",[v._v("ArrayList")]),v._v("，而在插入和 删除操作较多时，更推荐使用 "),_("code",[v._v("LinkedList")]),v._v("。")]),v._v(" "),_("blockquote",[_("p",[_("code",[v._v("LinkedList")]),v._v("的双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个 指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都 可以很方便地访问它的前驱结点和后继结点。")])])])}),[],!1,null,null,null);_.default=t.exports}}]);