(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{329:function(v,_,e){"use strict";e.r(_);var t=e(14),o=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("blockquote",[_("p",[v._v("说说你对线程池的理解")])]),v._v(" "),_("p",[v._v("得分点 核心参数、处理流程、拒绝策略")]),v._v(" "),_("p",[v._v("加分回答 线程池的生命周期")]),v._v(" "),_("p",[v._v("标准回答：")]),v._v(" "),_("p",[_("strong",[v._v("核心参数")])]),v._v(" "),_("p",[v._v("线程池可以管理线程的数量，可以避免无节制的创建线程，导致超出系统负荷直至崩溃。它还可以让线程复用，可以大大地减少创建和销毁线程所带来的开销。 线程池需要依赖一些参数来控制任务的执行流程，其中最重要的参数有：")]),v._v(" "),_("ol",[_("li",[_("code",[v._v("corePoolSize")]),v._v("（核心线程数）")]),v._v(" "),_("li",[_("code",[v._v("maximumPoolSize")]),v._v("：线程池能创建线程的最大个数")]),v._v(" "),_("li",[_("code",[v._v("keepAliveTime")]),v._v("：空闲线程存活时间")]),v._v(" "),_("li",[_("code",[v._v("unit")]),v._v("：时间单位，为 "),_("code",[v._v("keepAliveTime")]),v._v("指定的时间单位")]),v._v(" "),_("li",[v._v("指定时间单位 "),_("code",[v._v("workQueue")]),v._v("：阻塞队列，用于保存任务的阻塞队列")]),v._v(" "),_("li",[_("code",[v._v("threadFactory")]),v._v("：创建线程的工程类")]),v._v(" "),_("li",[_("code",[v._v("handler")]),v._v("：饱和策略（拒绝策略）")])]),v._v(" "),_("p",[_("strong",[v._v("处理流程")])]),v._v(" "),_("p",[v._v("当我们向线程池提交一个任务之后，线程池按照如下步骤处理这个任务：")]),v._v(" "),_("ol",[_("li",[v._v("判断线程数是否达到"),_("code",[v._v("corePoolSize")]),v._v("，若没有则新建线程执行该任务，否则进入下一步。")]),v._v(" "),_("li",[v._v("判断等待队列是否已满，若没有则将任务放入等待队列，否则进入下一步。")]),v._v(" "),_("li",[v._v("判断线程数是否达到"),_("code",[v._v("maxinumPoolSize")]),v._v("，如果没有则新建线程执行任务，否则进入下一步。")]),v._v(" "),_("li",[v._v("采用初始化线程池时指定的拒绝策略，拒绝执行该任务。")]),v._v(" "),_("li",[v._v("新建的线程处理完当前任务后，不会立刻关闭，而是继续处理等待队列中的任务。如果线程的空闲时间达到了"),_("code",[v._v("keepAliveTime")]),v._v("，则线程池会销毁一部分线程，将线程数量收缩至"),_("code",[v._v("corePoolSize")]),v._v("。")])]),v._v(" "),_("blockquote",[_("p",[v._v("第"),_("code",[v._v("2")]),v._v("步中的队列可以有界也可以无界。若指定了无界的队列(不限制等等待队列中任务个数)，则线程池永远无法进入第"),_("code",[v._v("3")]),v._v("步，相当于废弃了"),_("code",[v._v("maxinumPoolSize")]),v._v("参数。这种用法是十分危险的，如果任务在队列中产生大量的堆积，就很容易造成内存溢出。"),_("code",[v._v("JDK")]),v._v("为我们提供了一个名为"),_("code",[v._v("Executors")]),v._v("的线程池的创建工具，该工具创建出来的就是带有无界队列的线程池，所以一般在工作中我们是不建议使用这个类来创建线程池的。")])]),v._v(" "),_("blockquote",[_("p",[v._v("根据阿里巴巴开法手册规定")]),v._v(" "),_("p",[v._v("线程池不允许使用 "),_("code",[v._v("Executors")]),v._v(" 去创建，而是通过 "),_("code",[v._v("ThreadPoolExecutor")]),v._v(" 的方式，这 样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。")]),v._v(" "),_("p",[v._v("说明："),_("code",[v._v("Executors")]),v._v(" 返回的线程池对象的弊端如下：")]),v._v(" "),_("ol",[_("li",[_("code",[v._v("FixedThreadPool")]),v._v(" 和 "),_("code",[v._v("SingleThreadPool")]),v._v("： 允许的请求队列长度为 "),_("code",[v._v("Integer.MAX_VALUE")]),v._v("，可能会堆积大量的请求，从而导致 "),_("code",[v._v("OOM")]),v._v("。")]),v._v(" "),_("li",[_("code",[v._v("CachedThreadPool")]),v._v("： 允许的创建线程数量为 "),_("code",[v._v("Integer.MAX_VALUE")]),v._v("，可能会创建大量的线程，从而导致 "),_("code",[v._v("OOM(OutOfMemoryError)")]),v._v("(也就是内存不足)。")])])]),v._v(" "),_("p",[_("strong",[v._v("拒绝策略")])]),v._v(" "),_("blockquote",[_("p",[_("strong",[v._v("什么时候执行拒绝策略？")])]),v._v(" "),_("p",[v._v("核心线程和临时线程都在忙，任务队列也满了，还有新的任务过来时会拒绝任务。")])]),v._v(" "),_("p",[v._v("第4步中的拒绝策略主要有4个：")]),v._v(" "),_("p",[v._v("让调用者自己执行任务、直接抛出异常、丢弃任务不做任何处理、删除队列中最老的任务并把当前任务加入队列。这4个拒绝策略分别对应着"),_("code",[v._v("RejectedExecutionHandler")]),v._v("接口的4个实现类，我们也可以基于这个接口实现自己的拒绝策略。")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"left"}},[v._v("参数")]),v._v(" "),_("th",{staticStyle:{"text-align":"left"}},[v._v("描述")])])]),v._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"left"}},[_("strong",[_("code",[v._v("AbortPolicy")]),v._v("(默认拒绝策略)")])]),v._v(" "),_("td",{staticStyle:{"text-align":"left"}},[_("strong",[v._v("拒绝任务并抛出异常")])])]),v._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[_("code",[v._v("CallerRunsPolicy")])]),v._v(" "),_("td",{staticStyle:{"text-align":"left"}},[v._v("重试提交当前的任务，即再次调用运行该任务的execute()方法。")])]),v._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[_("code",[v._v("DiscardOldestPolicy")])]),v._v(" "),_("td",{staticStyle:{"text-align":"left"}},[v._v("抛弃队列头部（最旧）的一个任务，并执行当前任务。")])]),v._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[_("code",[v._v("DiscardPolicy")])]),v._v(" "),_("td",{staticStyle:{"text-align":"left"}},[v._v("丢弃新来的任务，但是不抛出异常")])])])]),v._v(" "),_("p",[_("strong",[v._v("加分回答")])]),v._v(" "),_("p",[v._v("线程池的生命周期包含5个状态："),_("code",[v._v("RUNNING")]),v._v("、"),_("code",[v._v("SHUTDOWN")]),v._v("、"),_("code",[v._v("STOP")]),v._v("、"),_("code",[v._v("TIDING")]),v._v("、"),_("code",[v._v("TERMINATED")]),v._v("。")]),v._v(" "),_("p",[v._v("这5种状态的状态值分别是："),_("code",[v._v("-1")]),v._v("、"),_("code",[v._v("0")]),v._v("、"),_("code",[v._v("1")]),v._v("、"),_("code",[v._v("2")]),v._v("、"),_("code",[v._v("3")]),v._v("。")]),v._v(" "),_("p",[v._v("在线程池的生命周期中，它的状态只能由小到大迁移，是不可逆的。")]),v._v(" "),_("ol",[_("li",[_("code",[v._v("RUNNING")]),v._v("：表示线程池正在运行。")]),v._v(" "),_("li",[_("code",[v._v("SHUTDOWN")]),v._v("：执行"),_("code",[v._v("shutdown")]),v._v("()时进入该状态，此时队列不会清空，线程池会等待任务执行完毕。")]),v._v(" "),_("li",[_("code",[v._v("STOP")]),v._v("：执行"),_("code",[v._v("shutdownNow")]),v._v("()时进入该状态，此时现线程池会清空队列，不再等待任务的执行。")]),v._v(" "),_("li",[_("code",[v._v("TIDING")]),v._v("：当线程池及队列为空时进入该状态，此时线程池会执行钩子函数，目前该函数是一个空的实现。")]),v._v(" "),_("li",[_("code",[v._v("TERMINATED")]),v._v("：钩子函数执行完毕后，线程进入该状态，表示线程池已经死亡。")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/1671805308084-4bd58235-e37b-4dfa-827a-2016cf77c5e6.png",alt:"线程池原理图"}})])])}),[],!1,null,null,null);_.default=o.exports}}]);