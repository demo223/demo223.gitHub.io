(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{331:function(v,_,e){"use strict";e.r(_);var o=e(14),t=Object(o.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("blockquote",[_("p",[v._v("说说线程的状态")])]),v._v(" "),_("p",[v._v("得分点 new(创建)、runnable(运行)、blocked()阻塞、waiting(等待) 、timed_waiting(超时)、terminated(销毁)")]),v._v(" "),_("p",[_("strong",[v._v("标准回答")]),v._v("：")]),v._v(" "),_("p",[v._v("Java线程在运行的生命周期中，在任意给定的时刻，只能处于下列6种状态之一：")]),v._v(" "),_("ol",[_("li",[_("code",[v._v("new")]),v._v(" ：初始状态，线程被创建，但是还没有调用"),_("code",[v._v("start")]),v._v("方法。")]),v._v(" "),_("li",[_("code",[v._v("runnable")]),v._v(" ：可运行状态，线程正在"),_("code",[v._v("JVM")]),v._v("中执行，但是有可能在等待操作系统的调度。")]),v._v(" "),_("li",[_("code",[v._v("blocked")]),v._v("  ：阻塞状态，线程正在等待获取监视器锁。")]),v._v(" "),_("li",[_("code",[v._v("waiting")]),v._v(" ：等待状态，线程正在等待其他线程的通知或中断。")]),v._v(" "),_("li",[_("code",[v._v("timed_waiting")]),v._v(" ：超时等待状态，在"),_("code",[v._v("waiting")]),v._v(" 的基础上增加了超时时间，即超出时间自动返回。")]),v._v(" "),_("li",[_("code",[v._v("terminated")]),v._v("：终止状态，线程已经执行完毕。")])]),v._v(" "),_("p",[v._v("线程在创建之后默认为初始状态，在调用"),_("code",[v._v("start")]),v._v("方法之后进入可运行状态，可运行状态不代表线程正在运行，它有可能正在等待操作系统的调度。进入等待状态的线程需要其他线程的通知才能返回到可运行状态，而超时等待状态相当于在等待状态的基础上增加了超时限制，除了他线程的唤醒，在超时时间到达时也会返回运行状态。此外，线程在执行同步方法时，在没有获取到锁的情况下，会进入到阻塞状态。线程在执行完"),_("code",[v._v("run")]),v._v("方法之后，会进入到终止状态。")]),v._v(" "),_("p",[_("strong",[v._v("加分回答")]),v._v("：")]),v._v(" "),_("p",[v._v("Java将操作系统中的就绪和运行两个状态合并为可运行状态（"),_("code",[v._v("runnable")]),v._v(" ）。线程阻塞于"),_("code",[v._v("synchronized")]),v._v("的监视器锁时会进入阻塞状态，而线程阻塞于"),_("code",[v._v("Lock")]),v._v("锁时进入的却是等待状态，这是因为"),_("code",[v._v("Lock")]),v._v("接口实现类对于阻塞的实现均使用了"),_("code",[v._v("LockSupport")]),v._v("类中的相关方法。")])])}),[],!1,null,null,null);_.default=t.exports}}]);