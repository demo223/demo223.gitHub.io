(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{336:function(v,_,e){"use strict";e.r(_);var t=e(14),o=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"mysql为什么使用b-树-而不是使用b树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql为什么使用b-树-而不是使用b树"}},[v._v("#")]),v._v(" Mysql为什么使用B+树，而不是使用B树？")]),v._v(" "),_("p",[v._v("MySQL默认使用的索引底层数据结构是B+树。再聊B+树之前，我们先聊聊二叉树和B树")]),v._v(" "),_("blockquote",[_("p",[v._v("假如说MySQL的索引结构采用二叉树的数据结构，比较理想的结构如下：")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20230326225938743.png",alt:"image-20230326225938743"}})]),v._v(" "),_("p",[v._v("如果主键是顺序插入的，则会形成一个单向链表，结构如下：")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20230326225950078.png",alt:"image-20230326225950078"}})]),v._v(" "),_("p",[v._v("所以，如果选择二叉树作为索引结构，会存在以下缺点：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("顺序插入时，会形成一个链表，查询性能大大降低。")])]),v._v(" "),_("li",[_("p",[v._v("大数据量情况下，层级较深，检索速度慢。")])])]),v._v(" "),_("p",[v._v("此时大家可能会想到，我们可以选择红黑树，红黑树是一颗自平衡二叉树，那这样即使是顺序插入数据，最终形成的数据结构也是一颗平衡的二叉树,结构如下:")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20230326225959851.png",alt:"image-20230326225959851"}})]),v._v(" "),_("p",[v._v("但是，即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点：")]),v._v(" "),_("ul",[_("li",[v._v("大数据量情况下，层级较深，检索速度慢。")])]),v._v(" "),_("p",[v._v("所以，在MySQL的索引结构中，并没有选择二叉树或者红黑树，而选择的是B+Tree，那么什么是B+Tree呢？在详解B+Tree之前，先来介绍一个B-Tree。")])]),v._v(" "),_("p",[v._v("首先，常规的数据库存储引擎，一般都是采用 "),_("code",[v._v("B")]),v._v("树或者 "),_("code",[v._v("B+")]),v._v("树来实现索引的存储。 因为 "),_("code",[v._v("B")]),v._v("树是一种多路平衡树，用这种存储结构来存储大量数据，它的整个高度 会相比二叉树来说，会矮很多。 而对于数据库来说，所有的数据必然都是存储在磁盘上的，而磁盘 "),_("code",[v._v("IO")]),v._v("的效率实 际上是很低的，特别是在随机磁盘 "),_("code",[v._v("IO")]),v._v("的情况下效率更低。 所以树的高度能够决定磁盘 "),_("code",[v._v("IO")]),v._v("的次数，磁盘 "),_("code",[v._v("IO")]),v._v("次数越少，对于性能的提升就 越大，这也是为什么采用 "),_("code",[v._v("B")]),v._v("树作为索引存储结构的原因。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20230326232731023.png",alt:"image-20230326232731023"}})]),v._v(" "),_("p",[v._v("但是在 Mysql 的 "),_("code",[v._v("InnoDB")]),v._v("存储引擎里面，它用了一种增强的 "),_("code",[v._v("B")]),v._v("树结构，也就是 "),_("code",[v._v("B+")]),v._v("树来作为索引和数据的存储结构。 相比较于 "),_("code",[v._v("B")]),v._v("树结构，"),_("code",[v._v("B+")]),v._v("树做了几个方面的优化。 "),_("code",[v._v("B+")]),v._v("树的所有数据都存储在叶子节点，非叶子节点只存储索引。 叶子节点中的数据使用双向链表的方式进行关联。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20230326232753712.png",alt:"image-20230326232753712"}})]),v._v(" "),_("p",[v._v("使用 "),_("code",[v._v("B+")]),v._v("树来实现索引的原因，我认为有几个方面。 "),_("code",[v._v("B+")]),v._v("树非叶子节点不存储数据，所以每一层能够存储的索引数量会增加，意味着 "),_("code",[v._v("B+")]),v._v("树在层高相同的情况下存储的数据量要比 "),_("code",[v._v("B")]),v._v("树要多，使得磁盘 "),_("code",[v._v("IO")]),v._v("次数更少。 在 Mysql 里面，范围查询是一个比较常用的操作，而 "),_("code",[v._v("B+")]),v._v("树的所有存储在叶子节 点的数据使用了双向链表来关联，所以在查询的时候只需查两个节点进行遍历就 行，而 "),_("code",[v._v("B")]),v._v("树需要获取所有节点，所以 B+树在范围查询上效率更高。 在数据检索方面，由于所有的数据都存储在叶子节点，所以 "),_("code",[v._v("B+")]),v._v("树的 "),_("code",[v._v("IO")]),v._v("次数会更 加稳定一些。 因为叶子节点存储所有数据，所以 "),_("code",[v._v("B+")]),v._v("树的全局扫描能力更强一些，因为它只需 要扫描叶子节点。但是 "),_("code",[v._v("B")]),v._v("树需要遍历整个树。 另外，基于"),_("code",[v._v("B+")]),v._v("树这样一种结构，如果采用自增的整型数据作为主键，还能更好 的避免增加数据的时候，带来叶子节点分裂导致的大量运算的问题。 总的来说，我认为技术方案的选型，更多的是去解决当前场景下的特定问题，并不一定是说 "),_("code",[v._v("B+")]),v._v("树就是最好的选择，就像 "),_("code",[v._v("MongoDB")]),v._v("里面采用 "),_("code",[v._v("B")]),v._v("树结构，本质上来说，其实是关系型数据库和非关系型数据库的差异。")])])}),[],!1,null,null,null);_.default=o.exports}}]);