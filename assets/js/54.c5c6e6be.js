(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{334:function(v,_,a){"use strict";a.r(_);var e=a(14),s=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"hashmap的原理与实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hashmap的原理与实现"}},[v._v("#")]),v._v(" HashMap的原理与实现")]),v._v(" "),_("h2",{attrs:{id:"hashmap的结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hashmap的结构"}},[v._v("#")]),v._v(" HashMap的结构")]),v._v(" "),_("p",[v._v("JDK1.8 之前的 "),_("code",[v._v("HashMap")]),v._v("由数组+链表组成的，数组是 "),_("code",[v._v("HashMap")]),v._v("的主体，链表则是主要为了节解决"),_("strong",[v._v("哈希碰撞")]),v._v("(两个对象调用的 "),_("code",[v._v("hashCode")]),v._v("方法计算的哈希码值一致导致计算的数组索引值相同)而存在的（“=="),_("strong",[v._v("拉链法")]),v._v("==”解决冲突）。")]),v._v(" "),_("p",[v._v("JDK1.8 之后在解决哈希冲突时有了较大的变化，当"),_("strong",[v._v("链表长度大于阈值")]),v._v("（或者红黑树的边界值，默认为 "),_("code",[v._v("8")]),v._v("）并且当前"),_("strong",[v._v("数组的长度大于 64")]),v._v(" 时，此时此索引位置上的所有数据改为使用红黑树存储。（=="),_("strong",[v._v("链式寻址法")]),v._v("==解决哈希冲突）。")]),v._v(" "),_("p",[v._v("数组里面都是 "),_("code",[v._v("key-value")]),v._v(" 的实例，在 JDK1.8 之前叫做 "),_("code",[v._v("Entry")]),v._v("，在 JDK1.8 之后叫做 "),_("code",[v._v("Node")]),v._v("。")]),v._v(" "),_("h2",{attrs:{id:"如何解决hash冲突"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何解决hash冲突"}},[v._v("#")]),v._v(" 如何解决hash冲突？")]),v._v(" "),_("p",[v._v("首先，"),_("code",[v._v("HashMap")]),v._v("底层采用了数组的结构来存储数据元素，数组的默认长度是 "),_("code",[v._v("16")]),v._v("， 当我们通过 "),_("code",[v._v("put")]),v._v("方法添加数据的时候，"),_("code",[v._v("HashMap")]),v._v("根据 "),_("code",[v._v("key")]),v._v("的 "),_("code",[v._v("hash")]),v._v("值进行==取模==运算，最终保存到数组的指定位置。")]),v._v(" "),_("p",[v._v("但是这种设计会存在 "),_("code",[v._v("hash")]),v._v("冲突问题，也就是两个不同 "),_("code",[v._v("hash")]),v._v("值的 "),_("code",[v._v("key")]),v._v("，最终取模后会落到同一个数组下标，所以 "),_("code",[v._v("HashMap")]),v._v("引入了=="),_("strong",[v._v("链式寻址法")]),v._v("==来解决 "),_("code",[v._v("hash")]),v._v("冲突问题，对于存在冲突的 "),_("code",[v._v("key")]),v._v("， "),_("code",[v._v("HashMap")]),v._v("把这些 "),_("code",[v._v("key")]),v._v("组成一个单向链表，然后采用"),_("strong",[v._v("尾插法")]),v._v("把这个 "),_("code",[v._v("key")]),v._v("保存到链表的尾部。另外，为了避免链表过长的问题，当链表长度大于 "),_("code",[v._v("8")]),v._v("并且数组长度大于等于 "),_("code",[v._v("64")]),v._v("的时候(当数组长度小于"),_("code",[v._v("64")]),v._v("时，不会进行树化操作，即使链表长度超过了"),_("code",[v._v("8")]),v._v("。)，"),_("code",[v._v("HashMap")]),v._v("会把链表转化为红黑树，从而减少链表数据查询的时间复杂度问题，提升查询性能。")]),v._v(" "),_("blockquote",[_("p",[v._v("解决 "),_("code",[v._v("hash")]),v._v("冲突问题的方法有很多，比如")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("再 hash 法")]),v._v("，就是如果某个 "),_("code",[v._v("hash")]),v._v("函数产生了冲突，再用另外一个 "),_("code",[v._v("hash")]),v._v("进行计算， 比如"),_("strong",[v._v("布隆过滤器")]),v._v("就采用了这种方法。")]),v._v(" "),_("li",[_("strong",[v._v("开放寻址法")]),v._v("（也称为闭散列），就是直接从冲突的数组位置往下寻找一个空的数组下标进行数据存储，这个在 "),_("code",[v._v("ThreadLocal")]),v._v("里面有使用到")]),v._v(" "),_("li",[_("strong",[v._v("建立公共溢出区")]),v._v("，也就是把存在冲突的 "),_("code",[v._v("key")]),v._v("统一放在一个公共溢出区")])])]),v._v(" "),_("blockquote",[_("p",[_("code",[v._v("JDK 1.8")]),v._v(" 之前的版本中使用的是"),_("strong",[v._v("拉链法")]),v._v("来解决哈希冲突。此外，从 "),_("code",[v._v("JDK 1.7")]),v._v(" 开始，为了减少哈希碰撞和提高性能，引入了一种称为“"),_("strong",[v._v("扰动函数")]),v._v("”的机制，使得对于相似的键值，其哈希值更加随机化，从而减少了哈希冲突的概率。")]),v._v(" "),_("p",[v._v("在 "),_("code",[v._v("JDK 1.8")]),v._v(" 中，"),_("code",[v._v("HashMap")]),v._v("使用的是"),_("strong",[v._v("链式寻址法")]),v._v("来解决哈希冲突。具体地说，如果一个桶中的元素个数小于等于某个阈值（默认为 "),_("code",[v._v("8")]),v._v("），那么所有元素都会存储在这个桶对应的链表中；而当元素个数超过了这个阈值时，就会将链表转换为红黑树，以提高查询效率。")]),v._v(" "),_("hr"),v._v(" "),_("p",[_("strong",[v._v("链式寻址法")]),v._v("和"),_("strong",[v._v("拉链法")]),v._v("是哈希表中解决哈希冲突的两种方法，它们并不完全相同。")]),v._v(" "),_("p",[_("strong",[v._v("链式寻址法")]),v._v("是将所有哈希值相同的元素放在一个链表中，每个节点指向下一个节点。当需要查找一个元素时，首先计算出该元素的哈希值，然后在链表中搜索。这种方法的优点是不需要为哈希表预留额外的空间，而且插入和删除操作比较容易实现。")]),v._v(" "),_("p",[v._v("而"),_("strong",[v._v("拉链法")]),v._v("（也称为开散列）则是在哈希表中对每个桶都维护一个链表，所有哈希值相同的元素都放在同一个桶的链表中。当需要查找或插入一个元素时，首先计算出该元素的哈希值，然后访问对应的桶的链表即可。这种方法的优点是可以避免链表过长的问题，而且用于桶之间的元素分布比较均匀的情况下，查询时间复杂度可以达到 "),_("code",[v._v("O(1)")]),v._v("。")]),v._v(" "),_("p",[_("strong",[v._v("开放寻址法")]),v._v("（也称为闭散列）是一种解决哈希冲突的方法。当使用哈希表进行查找时，如果两个或多个键映射到同一个位置，就会发生冲突。在开放寻址法中，当发生冲突时，程序会在哈希表中寻找下一个可用的空位置，并将数据插入到该位置中。具体的步骤如下：")]),v._v(" "),_("ol",[_("li",[v._v("计算元素的哈希值。")]),v._v(" "),_("li",[v._v("如果对应的位置为空，则将元素插入该位置。")]),v._v(" "),_("li",[v._v("如果对应的位置已经被占用，则继续向后查找，直到找到一个空位置为止。")]),v._v(" "),_("li",[v._v("如果已经遍历了整个哈希表，但仍然没有找到空位置，则说明哈希表已满，无法再插入元素。")])]),v._v(" "),_("p",[v._v("在开放寻址法中，每个位置都可以存储一个元素，因此它的空间利用率比链式哈希表高。但是，随着哈希表的填充程度越来越高，开放寻址法的效率会逐渐降低，因为需要遍历更多的位置才能找到空位置。")])]),v._v(" "),_("p",[_("strong",[v._v("当两个对象的 "),_("code",[v._v("hashCode")]),v._v("相等时会怎么样？")])]),v._v(" "),_("blockquote",[_("p",[v._v("当两个对象的 "),_("code",[v._v("hashCode")]),v._v(" 相等时，HashMap 会使用 "),_("code",[v._v("equals()")]),v._v(" 方法来比较这两个对象是否相等。")]),v._v(" "),_("p",[v._v("如果两个对象相等（即 "),_("code",[v._v("equals()")]),v._v(" 方法返回 "),_("code",[v._v("true")]),v._v("），那么只会将该对象作为一个 "),_("code",[v._v("key")]),v._v("添加到 "),_("code",[v._v("HashMap")]),v._v("中，并覆盖原有的 "),_("code",[v._v("value")]),v._v("。这样做是因为在 "),_("code",[v._v("HashMap")]),v._v("中，只允许同一个 "),_("code",[v._v("key")]),v._v("对应一个 "),_("code",[v._v("value")]),v._v("，如果已经存在一个 "),_("code",[v._v("key")]),v._v("，再次添加相同的 "),_("code",[v._v("key")]),v._v("，它们都会指向同一个 "),_("code",[v._v("value")]),v._v("。")]),v._v(" "),_("p",[v._v("如果两个对象不相等（即 "),_("code",[v._v("equals()")]),v._v(" 方法返回 "),_("code",[v._v("false")]),v._v("），则在 "),_("code",[v._v("HashMap")]),v._v("中会将它们视为不同的 "),_("code",[v._v("key")]),v._v("，并将它们分别存储在不同的位置上。由于哈希函数并不是完美的，所以仍然存在一定的哈希冲突的可能性，但是这种情况下，"),_("code",[v._v("HashMap")]),v._v("会使用链表或红黑树等数据结构来解决冲突。")]),v._v(" "),_("p",[v._v("需要注意的是，虽然 "),_("code",[v._v("hashCode()")]),v._v(" 方法相等的对象不一定相等，但是 "),_("code",[v._v("equals()")]),v._v(" 方法相等的对象一定要求 "),_("code",[v._v("hashCode()")]),v._v(" 方法返回值相等，否则会导致它们无法被正确地添加到 "),_("code",[v._v("HashMap")]),v._v("中。因此，当我们重写了一个类的 "),_("code",[v._v("equals()")]),v._v(" 方法时，也需要同时重写 "),_("code",[v._v("hashCode()")]),v._v(" 方法，以保证它们的语义一致。")])]),v._v(" "),_("p",[_("strong",[v._v("如果两个键的 "),_("code",[v._v("hashcode")]),v._v("相同，如何存储键值对？")])]),v._v(" "),_("blockquote",[_("p",[v._v("因此"),_("code",[v._v("HashMap")]),v._v("在执行 "),_("code",[v._v("put()")]),v._v(" 操作时，会先根据键的 "),_("code",[v._v("hashCode()")]),v._v(" 方法计算出该键在 "),_("code",[v._v("HashMap")]),v._v("中对应的位置，然后判断该位置是否已经存在键值对：")]),v._v(" "),_("ul",[_("li",[v._v("如果该位置没有键值对，则直接将新键值对插入到该位置。")]),v._v(" "),_("li",[v._v("如果该位置已经存在键值对，那么需要进行以下判断：\n"),_("ul",[_("li",[v._v("如果新键和原有键的 "),_("code",[v._v("equals()")]),v._v(" 方法返回 "),_("code",[v._v("true")]),v._v("，则将原有键的值替换为新值；")]),v._v(" "),_("li",[v._v("如果新键和原有键的 "),_("code",[v._v("equals()")]),v._v(" 方法返回 "),_("code",[v._v("false")]),v._v("，则将新键值对插入到链表或红黑树中。")])])])]),v._v(" "),_("p",[v._v("需要注意的是，在进行键值对的插入和替换操作时，如果哈希冲突了（即两个键的哈希码相等），则会使用链表或红黑树来处理。在 "),_("code",[v._v("JDK1.8")]),v._v(" 之前，"),_("code",[v._v("HashMap")]),v._v("采用的是拉链法；而在 "),_("code",[v._v("JDK1.8")]),v._v(" 及以后的版本中，当链表长度达到一定阈值时，会自动转化为红黑树以提高性能。")])]),v._v(" "),_("h2",{attrs:{id:"hashmap-啥时候扩容-为什么扩容"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-啥时候扩容-为什么扩容"}},[v._v("#")]),v._v(" HashMap 啥时候扩容，为什么扩容？")]),v._v(" "),_("h3",{attrs:{id:"hashmap-的扩容机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-的扩容机制"}},[v._v("#")]),v._v(" HashMap 的扩容机制")]),v._v(" "),_("p",[_("code",[v._v("HashMap")]),v._v("的"),_("code",[v._v("put")]),v._v("方法流程")]),v._v(" "),_("ol",[_("li",[v._v("计算"),_("code",[v._v("key")]),v._v("的哈希值")]),v._v(" "),_("li",[v._v("判断数组是否为空，如果为空，就执行扩容，初始化数据大小。")]),v._v(" "),_("li",[v._v("如果数组不为空，根据哈希值找到数组所在下标")]),v._v(" "),_("li",[v._v("判断下标元素是否为"),_("code",[v._v("null")]),v._v("，如果为"),_("code",[v._v("null")]),v._v("就创建新元素")]),v._v(" "),_("li",[v._v("如果下标元素不为"),_("code",[v._v("null")]),v._v("，就判断是否是红黑树类型，如果是，则执行红黑树的新增逻辑")]),v._v(" "),_("li",[v._v("如果不是红黑树，说明是链表，就追加到链表末尾")]),v._v(" "),_("li",[v._v("如果判断链表长度是否大于等于"),_("code",[v._v("8")]),v._v("，数组长度是否大于等于"),_("code",[v._v("64")]),v._v("，如果不是就执行扩容逻辑")]),v._v(" "),_("li",[v._v("如果是，则需要把链表转换成红黑树")]),v._v(" "),_("li",[v._v("最后判断新增元素后，判断元素个数是否大于阈值（"),_("code",[v._v("16*0.75=12")]),v._v("），如果是则执行扩容逻辑，结束。")])]),v._v(" "),_("blockquote",[_("p",[v._v("向"),_("code",[v._v("HashMap")]),v._v("中添加数据时，有==三个条件==会触发它的扩容行为：")]),v._v(" "),_("ol",[_("li",[v._v("如果数组为空，则进行首次==扩容==。")]),v._v(" "),_("li",[v._v("将元素接入链表后，如果链表长度达到8，并且数组长度小于64，则==扩容==。")]),v._v(" "),_("li",[v._v("添加后，如果数组中元素超过阈值，即比例超出限制（默认为0.75），则==扩容==。")])])]),v._v(" "),_("p",[_("code",[v._v("JDK1.7")]),v._v(" 的时候初始容量确实是"),_("code",[v._v("16")]),v._v("，但是"),_("code",[v._v("JDK1.8")]),v._v(" 的时候初始化"),_("code",[v._v("HashMap")]),v._v("的时候并没有指定容量大小，而是在第一次执行"),_("code",[v._v("put")]),v._v("数据，才初始化容量。")]),v._v(" "),_("p",[v._v("在"),_("code",[v._v("JDK1.7")]),v._v(" 扩容的时候，会遍历原数组，重新哈希，对新数组长度逻辑与，计算出数据下标，然后放到新数组中，比较麻烦耗时。")]),v._v(" "),_("p",[v._v("在"),_("code",[v._v("JDK1.8")]),v._v(" 扩容的时候，会遍历原数组，然后统计出两组数据，一组是新数组的下标位置不变，另一组是新数组的下标位置等于原数组的下标位置加上原数组的长度。")]),v._v(" "),_("p",[v._v("比如：数组长度由"),_("code",[v._v("16")]),v._v("扩容到"),_("code",[v._v("32")]),v._v("，哈希值是"),_("code",[v._v("0")]),v._v("和"),_("code",[v._v("32")]),v._v("的元素，在新旧数组中下标位置不变，都是下标为"),_("code",[v._v("0")]),v._v("的位置。而哈希值是"),_("code",[v._v("16")]),v._v("和"),_("code",[v._v("48")]),v._v("的元素，在新数组的位置"),_("code",[v._v("=")]),v._v("原数组的下标"),_("code",[v._v("+")]),v._v("原数组的长度，也就是下标为"),_("code",[v._v("16")]),v._v("的位置。")]),v._v(" "),_("div",{staticClass:"language-java line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 负载因子大小")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("final")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("float")]),v._v(" loadFactor"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 默认负载因子大小")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("static")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("final")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("float")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token constant"}},[v._v("DEFAULT_LOAD_FACTOR")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("0.75f")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 初始化方法")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("public")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("HashMap")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("this")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("loadFactor "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token constant"}},[v._v("DEFAULT_LOAD_FACTOR")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v(" \n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br"),_("span",{staticClass:"line-number"},[v._v("5")]),_("br"),_("span",{staticClass:"line-number"},[v._v("6")]),_("br"),_("span",{staticClass:"line-number"},[v._v("7")]),_("br"),_("span",{staticClass:"line-number"},[v._v("8")]),_("br"),_("span",{staticClass:"line-number"},[v._v("9")]),_("br"),_("span",{staticClass:"line-number"},[v._v("10")]),_("br")])]),_("p",[v._v("当我们创建一个集合对象的时候，实际上就是在内存中一次性申请一块内存空间，而这个内存空间大小是在创建集合对象的时候指定的。 比如 "),_("code",[v._v("List")]),v._v("的默认大小是 "),_("code",[v._v("10")]),v._v("、"),_("code",[v._v("HashMap")]),v._v("的默认大小是 "),_("code",[v._v("16")]),v._v("。在实际开发中，我们需要存储的数据量往往大于存储容器的大小。 针对这种情况，通常的做法就是"),_("strong",[v._v("扩容")]),v._v("。 当集合的存储容量达到某个阈值的时候，集合就会进行动态扩容，从而更好的满足更多数据的存储。"),_("code",[v._v("List")]),v._v("和 "),_("code",[v._v("HashMap")]),v._v("，本质上都是一个数组结构，所以基本上只需要新建一个更长 的数组然后把原来数组中的数据拷贝到新数组就行了。")]),v._v(" "),_("p",[v._v("以 "),_("code",[v._v("HashMap")]),v._v("为例，它是什么时候触发扩容以及扩容的原理是什么呢？ 当 HashMap 中元素个数超过临界值时会自动触发扩容，这个临界值有一个计算 公式。")]),v._v(" "),_("div",{staticClass:"language-properties line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-properties"}},[_("code",[_("span",{pre:!0,attrs:{class:"token key attr-name"}},[v._v("threashold")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("=")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token value attr-value"}},[v._v("loadFactor * capacity")]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br")])]),_("p",[_("code",[v._v("loadFactor")]),v._v("的默认值是 "),_("code",[v._v("0.75")]),v._v("，"),_("code",[v._v("capacity")]),v._v("的默认值是 "),_("code",[v._v("16")]),v._v("，也就是元素个数达到 "),_("code",[v._v("12")]),v._v("的时候触发扩容。扩容后的大小是原来的 "),_("code",[v._v("2")]),v._v("倍。")]),v._v(" "),_("p",[v._v("由于动态扩容机制的存在，所以我们在实际应用中，需要注意在集合初始化的时候明确指定集合的大小。 避免频繁扩容带来性能上的影响。 假设我们要向 "),_("code",[v._v("HashMap")]),v._v("中存储 "),_("code",[v._v("1024")]),v._v("个元素，如果按照默认值 "),_("code",[v._v("16")]),v._v("，随着元素的不断增加，会造成 "),_("code",[v._v("7")]),v._v("次扩容。而这 "),_("code",[v._v("7")]),v._v("次扩容需要重新创建 "),_("code",[v._v("Hash")]),v._v("表，并且进行数据迁移，对性能影响非常大。")]),v._v(" "),_("h3",{attrs:{id:"hashmap的数组长度为什么初始化长度默认为16-为什么扩容因子是-0-75"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hashmap的数组长度为什么初始化长度默认为16-为什么扩容因子是-0-75"}},[v._v("#")]),v._v(" HashMap的数组长度为什么初始化长度默认为16？为什么扩容因子是 0.75？")]),v._v(" "),_("p",[_("code",[v._v("JDK1.7")]),v._v(" 的时候初始容量确实是"),_("code",[v._v("16")]),v._v("，但是"),_("code",[v._v("JDK1.8")]),v._v(" 的时候初始化"),_("code",[v._v("HashMap")]),v._v("的时候并没有指定容量大小，而是在第一次执行"),_("code",[v._v("put")]),v._v("数据，才初始化容量。")]),v._v(" "),_("p",[_("code",[v._v("HashMap")]),v._v("的数组长度初始化为"),_("code",[v._v("16")]),v._v("是因为这个长度既能保证散列的效果又能控制空间开销。将数组长度设为"),_("code",[v._v("2")]),v._v("的整数次幂可以使得通过位运算计算索引更高效，而"),_("code",[v._v("16")]),v._v("这个数是在保证足够小的同时，对于大多数应用场景都能提供比较好的性能表现。")]),v._v(" "),_("hr"),v._v(" "),_("p",[v._v("扩容因子为"),_("code",[v._v("0.75")]),v._v("是一种折中方案，它可以在时间和空间上取得一个平衡点。在"),_("code",[v._v("HashMap")]),v._v("中，扩容时需要重新计算所有元素的位置，并将它们放入新的桶中。如果扩容因子过小，则会导致"),_("code",[v._v("HashMap")]),v._v("频繁地进行扩容，增加时间成本；而如果扩容因子过大，则会导致"),_("code",[v._v("Hash")]),v._v("表填满程度很高，也就是“装载因子”很高，从而增加空间成本。经过试验和实践，"),_("code",[v._v("0.75")]),v._v("的扩容因子在大多数情况下能够达到很好的效果。")]),v._v(" "),_("h3",{attrs:{id:"hashmap从链表转化为红黑树的阈值为什么是8"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hashmap从链表转化为红黑树的阈值为什么是8"}},[v._v("#")]),v._v(" HashMap从链表转化为红黑树的阈值为什么是8？")]),v._v(" "),_("p",[v._v("通过查看源码可以发现，默认是链表长度达到 "),_("code",[v._v("8")]),v._v("就转成红黑树，而当长度降到 "),_("code",[v._v("6")]),v._v("就转换回去，这体现了时间和空间平衡的思想，最开始使用链表的时候，空间占用是比较少的，而且由于链表短，所以查询时间也没有太大的问题。可是当链表越来越长，需要用红黑树的形式来保证查询的效率。对于何时应该从链表转化为红黑树，需要确定一个阈值，这个阈值默认为 "),_("code",[v._v("8")]),v._v("，并且在源码中也对选择 "),_("code",[v._v("8")]),v._v("这个数字做了说明，原文如下：")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20230325222118406.png",alt:"image-20230325222118406"}})]),v._v(" "),_("p",[v._v("上面这段话的意思是，如果 "),_("code",[v._v("hashCode")]),v._v("分布良好，也就是 "),_("code",[v._v("hash")]),v._v("计算的结果离散好的话，那么红黑树这种形式是很少会被用到的，因为各个值都均匀分布，很少出现链表很长的情况。在理想情况下，桶(bins)中的节点数概率(链表长度)符合"),_("strong",[v._v("泊松分布")]),v._v("，当桶中节点数(链表长度)为 "),_("code",[v._v("8")]),v._v("的时候，概率仅为 "),_("code",[v._v("0.00000006")]),v._v("。这是一个小于千万分之一的概率，通常我们的 "),_("code",[v._v("Map")]),v._v("里面是不会存储这么多的数据的，所以通常情况下，并不会发生从链表向红黑树的转换。")]),v._v(" "),_("h3",{attrs:{id:"hashmap容量大小为什么要设置成2的倍数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hashmap容量大小为什么要设置成2的倍数"}},[v._v("#")]),v._v(" HashMap容量大小为什么要设置成2的倍数？")]),v._v(" "),_("div",{staticClass:"language-java line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("int")]),v._v(" index "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token function"}},[v._v("hash")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("key"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("&")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("n"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("-")]),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("1")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br")])]),_("p",[v._v("为了更快的计算key所在的数组下标位置。")]),v._v(" "),_("p",[v._v("当数组长度（"),_("code",[v._v("n")]),v._v("）是2的倍数的时候，就可以直接通过与运算（"),_("code",[v._v("&")]),v._v("）计算下标位置，比取模速度更快。")]),v._v(" "),_("p",[v._v("每次扩容时都是将容量翻倍，即创建一个2倍大的新数组，然后再将旧数组中的数组迁移到新数组里。由于HashMap中数组的容量为2^N，所以可以用位移运算计算新容量，效率很高。")]),v._v(" "),_("h2",{attrs:{id:"hashmap中的-hash-方法为什么要右移-16-位异或"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hashmap中的-hash-方法为什么要右移-16-位异或"}},[v._v("#")]),v._v(" HashMap中的 hash 方法为什么要右移 16 位异或？")]),v._v(" "),_("p",[v._v("为了让键的哈希码均匀地分布在"),_("code",[v._v("HashMap")]),v._v("的桶中。在"),_("code",[v._v("HashMap")]),v._v("中，桶的数量总是"),_("code",[v._v("2")]),v._v("的幂次方，因此只有哈希码的低几位才会影响桶的索引位置。而右移"),_("code",[v._v("16")]),v._v("位相当于将哈希码的高"),_("code",[v._v("16")]),v._v("位与低"),_("code",[v._v("16")]),v._v("位进行混合，使得哈希码的高位也能够参与到桶的索引计算中去。同时，通过异或操作，还能够更好地保证哈希码的随机性和均匀性。")]),v._v(" "),_("p",[v._v("总之，"),_("code",[v._v("HashMap")]),v._v("中的哈希函数设计是为了最大化散列效果，从而提高"),_("code",[v._v("HashMap")]),v._v("的性能和可靠性。")]),v._v(" "),_("p",[_("strong",[v._v("最终目的还是为了让哈希后的结果更均匀的分布，减少哈希碰撞，提升HashMap的运行效率")])]),v._v(" "),_("blockquote",[_("p",[v._v("为了提升 "),_("code",[v._v("key")]),v._v("的 "),_("code",[v._v("hash")]),v._v("值的散列度，在 "),_("code",[v._v("hash")]),v._v("方法里面，做了位移运算。 首先使用 "),_("code",[v._v("key")]),v._v("的 "),_("code",[v._v("hashCode")]),v._v("无符号右移 "),_("code",[v._v("16")]),v._v("位，意味着把 "),_("code",[v._v("hashCode")]),v._v("的高位移动到了低位。 然后再用 "),_("code",[v._v("hashCode")]),v._v("与右移之后的值进行异或运算，就相当于把高位和低位的特征进行和组合。从而降低了 "),_("code",[v._v("hash")]),v._v("冲突的概率")])]),v._v(" "),_("h2",{attrs:{id:"hashmap为什么使用红黑树而不是avl树或者b-树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hashmap为什么使用红黑树而不是avl树或者b-树"}},[v._v("#")]),v._v(" HashMap为什么使用红黑树而不是AVL树或者B+树？")]),v._v(" "),_("p",[_("code",[v._v("HashMap")]),v._v("使用红黑树而不是"),_("code",[v._v("AVL")]),v._v("树的主要原因是，"),_("strong",[v._v("红黑树的平衡性要求相对较低")]),v._v("，因此在高并发场景下具有更高的效率。而"),_("code",[v._v("AVL")]),v._v("树的平衡性要求较高，在高并发场景下需要更多的时间来维护树的平衡。因此"),_("code",[v._v("HashMap")]),v._v("使用红黑树可以更好地提高效率。")]),v._v(" "),_("p",[_("code",[v._v("HashMap")]),v._v("使用红黑树而不是"),_("code",[v._v("AVL")]),v._v("树或"),_("code",[v._v("B+")]),v._v("树主要是因为红黑树在插入、删除和查找操作上的平均时间复杂度都是"),_("code",[v._v("O(log n)")]),v._v("，并且在极端情况下也具有较好的性能表现，而且实现比"),_("code",[v._v("AVL")]),v._v("树简单许多。相比之下AVL树虽然在某些场景下可能比红黑树更快，但是实现比红黑树复杂，并且需要额外的空间来存储每个节点的平衡因子，因此在Java中的"),_("code",[v._v("HashMap")]),v._v("中并没有使用"),_("code",[v._v("AVL")]),v._v("树。")]),v._v(" "),_("p",[v._v("至于"),_("code",[v._v("B+")]),v._v("树，它在磁盘等"),_("code",[v._v("IO")]),v._v("密集型应用场景下表现非常出色，因为它可以最小化磁盘"),_("code",[v._v("I/O")]),v._v("次数，但对于内存中的数据结构来说，由于其不同于链表和数组的操作方式，因此实现难度较大，同时在数据量比较小的情况下，"),_("code",[v._v("B+")]),v._v("树的优势并不明显，因此在Java中的"),_("code",[v._v("HashMap")]),v._v("中也没有使用"),_("code",[v._v("B+")]),v._v("树。")]),v._v(" "),_("h2",{attrs:{id:"arraylist-hashmap-linkedlist-hashtable初始化大小"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#arraylist-hashmap-linkedlist-hashtable初始化大小"}},[v._v("#")]),v._v(" ArrayList,HashMap,LinkedList,HashTable初始化大小")]),v._v(" "),_("ol",[_("li",[_("p",[_("code",[v._v("ArrayList")]),v._v(" "),_("code",[v._v("ArrayList")]),v._v("初始化大小是 "),_("code",[v._v("10")]),v._v("（如果你知道你的"),_("code",[v._v("ArrayList")]),v._v("会达到多少容量，可以在初始化的时候就指定，能节省扩容的性能开支）\n扩容点规则是，新增的时候发现容量不够用了，就去扩容\n扩容大小规则是，扩容后的大小= 原始大小*"),_("code",[v._v("1.5")]),v._v("。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("LinkedList")]),v._v(" "),_("code",[v._v("LinkedList")]),v._v("是一个双向链表，没有初始化大小，也没有扩容的机制，就是一直在前面或者后面新增就好。\n对于双向链表的理解")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("HashMap")]),v._v("\nHashMap 初始化大小是 "),_("code",[v._v("16")]),v._v("，扩容因子默认"),_("code",[v._v("0.75")]),v._v("（可以指定初始化大小，和扩容因子）\n扩容机制.(当前大小和当前容量的比例超过了扩容因子，就会扩容，扩容后大小为一倍。例如：初始大小为 "),_("code",[v._v("16")]),v._v("，扩容因子 "),_("code",[v._v("0.75")]),v._v("，当容量为"),_("code",[v._v("12")]),v._v("的时候，比例已经是"),_("code",[v._v("0.75")]),v._v("。触发扩容，扩容后的大小为 "),_("code",[v._v("32")]),v._v(")")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("HashTable")]),v._v("\n默认初始容量为"),_("code",[v._v("11")]),v._v("，线程安全，但是速度慢，不允许"),_("code",[v._v("key/value")]),v._v("为"),_("code",[v._v("null")]),v._v("。\n加载因子为"),_("code",[v._v("0.75")]),v._v("：即当 元素个数 超过 容量长度的"),_("code",[v._v("0.75")]),v._v("倍时，进行扩容。\n扩容增量："),_("code",[v._v("2")]),v._v("*原数组长度"),_("code",[v._v("+1")]),v._v("，如 "),_("code",[v._v("HashTable")]),v._v("的容量为"),_("code",[v._v("11")]),v._v("，一次扩容后是容量为"),_("code",[v._v("23")]),v._v("。")])])])])}),[],!1,null,null,null);_.default=s.exports}}]);