(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{337:function(e,_,v){"use strict";v.r(_);var s=v(14),t=Object(s.a)({},(function(){var e=this,_=e._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h2",{attrs:{id:"_1-redistemplate中定义了对5种数据结构操作"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-redistemplate中定义了对5种数据结构操作"}},[e._v("#")]),e._v(" 1 RedisTemplate中定义了对5种数据结构操作：")]),e._v(" "),_("p",[_("code",[e._v("redisTemplate.opsForValue()")]),e._v(" ：操作"),_("code",[e._v("String")]),e._v(" "),_("code",[e._v("redisTemplate.opsForHash()")]),e._v(" ：操作"),_("code",[e._v("hash")]),e._v(" "),_("code",[e._v("redisTemplate.opsForList()")]),e._v("：操作"),_("code",[e._v("list")]),e._v(" "),_("code",[e._v("redisTemplate.opsForSet()")]),e._v(" ：操作"),_("code",[e._v("set")]),e._v(" "),_("code",[e._v("redisTemplate.opsForZSet()")]),e._v("：操作"),_("code",[e._v("Zset")])]),e._v(" "),_("h2",{attrs:{id:"_2-redis集群的三种方式的优缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-redis集群的三种方式的优缺点"}},[e._v("#")]),e._v(" 2 Redis集群的三种方式的优缺点")]),e._v(" "),_("ol",[_("li",[_("p",[_("strong",[e._v("Redis主从复制")])]),e._v(" "),_("p",[e._v("主从模式是三种模式中最简单的，主从模式指的是使用一个Redis实例作为主机，其余的实例作为备份机，主机和从机的数据完全一致。")]),e._v(" "),_("p",[e._v("主数据可以读和写，从数据库一般是只读，主从库之间采用读写分离，主数据库数据更新后同步复制给绑定的从数据库，主从数据库的数据保持一致：")]),e._v(" "),_("p",[e._v("主机支持数据的写入和读取等各项操作，而从机则只支持与主机数据的同步和读取，也就是说客户端可以将数据写入到主机，由主机自动将数据的写入操作同步到从机。")]),e._v(" "),_("p",[_("strong",[e._v("主从复制的优缺点")])]),e._v(" "),_("p",[_("strong",[e._v("Redis主从复制优点：")]),e._v(" 做到读写分离，提高服务器性能；")]),e._v(" "),_("p",[_("strong",[e._v("Redis主从复制缺点：")]),e._v(" 在主从模式中，一旦Master节点由于故障不能提供服务，需要人工将Slave节点晋升为Master节点。")])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("Redis哨兵模式")])]),e._v(" "),_("p",[e._v("主从模式当主服务器宕机后，需要手动把一台从服务器切换为主服务器，需要人工干预费事费力，为了解决这个问题出现了哨兵模式。")]),e._v(" "),_("hr"),e._v(" "),_("p",[e._v("哨兵模式由一个或多个Sentinel实例组成的Sentinel系统，它可以监视所有的Master节点和Slave节点，并在被监视的Master节点进入下线状态时，自动将下线Master服务器。")]),e._v(" "),_("p",[_("strong",[e._v("哨兵模式工作原理")])]),e._v(" "),_("p",[e._v("当主节点出现故障时，由Redis Sentinel自动完成故障发现和转移，并通知应用方，实现高可用性。")]),e._v(" "),_("ol",[_("li",[e._v("哨兵机制建立了多个哨兵节点(进程)，共同监控数据节点的运行状况。")]),e._v(" "),_("li",[e._v("同时哨兵节点之间也互相通信，交换对主从节点的监控状况。")]),e._v(" "),_("li",[e._v("每隔1秒每个哨兵会向整个集群：Master主服务器+Slave从服务器+其他Sentinel（哨兵）进程，发送一次ping命令做一次心跳检测。")])]),e._v(" "),_("p",[_("strong",[e._v("哨兵模式的优缺点")])]),e._v(" "),_("p",[_("strong",[e._v("哨兵模式")]),e._v("优点：最大的优点就是主从可以自动切换，系统更健壮，可用性更高；")]),e._v(" "),_("p",[_("strong",[e._v("哨兵模式")]),e._v("缺点：最大的缺点就是还要多维护一套哨兵模式，实现起来也变的更加复杂增加维护成本；")])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("Redis集群模式")])]),e._v(" "),_("p",[e._v("哨兵模式基于主从模式，实现读写分离，它还可以自动切换，系统可用性更高。但是它每个节点存储的数据是一样的，浪费内存，因此在Redis3.0后Cluster集群应运而生。")]),e._v(" "),_("p",[e._v("Redis Cluster是一种服务器Sharding技术(分片和路由都是在服务端实现)，采用多主多从，每一个分区都是由一个Redis主机和多个从机组成，片区和片区之间是相互平行的。")]),e._v(" "),_("p",[_("strong",[e._v("Redis集群模式应用")])]),e._v(" "),_("p",[e._v("主要是针对海量数据+高并发+高可用的海量数据场景，Redis集群模式的性能和高可用性均优于哨兵模式。")])])]),e._v(" "),_("h2",{attrs:{id:"_3-redis为什么这么快"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-redis为什么这么快"}},[e._v("#")]),e._v(" 3 Redis为什么这么快?")]),e._v(" "),_("p",[e._v("Redis之所以如此快速，主要是由于以下几个方面：")]),e._v(" "),_("ol",[_("li",[_("strong",[e._v("内存存储")]),e._v("：Redis是一种基于内存的数据存储系统，它将所有数据存储在内存中，而不是像传统的关系型数据库一样将数据存储在磁盘上。这使得Redis能够快速地读取和写入数据。")]),e._v(" "),_("li",[_("strong",[e._v("非阻塞IO")]),e._v("：Redis使用了非阻塞IO技术，使得它可以在单线程模式下处理多个客户端的请求，从而避免了线程切换的开销。这使得Redis在高并发的情况下表现出色。")]),e._v(" "),_("li",[_("strong",[e._v("单线程")]),e._v("：Redis采用单线程模型，避免了多线程之间的竞争和死锁等问题，同时减少了线程间的切换开销。这也使得Redis的性能得到了提升。")]),e._v(" "),_("li",[_("strong",[e._v("数据结构简单")]),e._v("：Redis支持多种数据结构，如字符串、哈希表、列表、集合和有序集合等。这些数据结构相对简单，实现起来较为轻量级，从而能够快速地读写数据。")]),e._v(" "),_("li",[_("strong",[e._v("多种优化技术")]),e._v("：Redis还采用了多种优化技术，如数据压缩、数据持久化、集群模式等，进一步提高了Redis的性能和可靠性。")])]),e._v(" "),_("p",[e._v("总之，Redis之所以如此快速，主要得益于内存存储、非阻塞IO、单线程、简单的数据结构和多种优化技术等因素的共同作用。这些特点使得Redis成为了一个高性能、可靠性高、易于使用和部署的数据存储系统。")])])}),[],!1,null,null,null);_.default=t.exports}}]);