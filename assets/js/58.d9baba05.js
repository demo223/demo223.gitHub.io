(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{338:function(v,_,t){"use strict";t.r(_);var p=t(14),l=Object(p.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("blockquote",[_("p",[v._v("Redis如何与数据库保持双写一致性")])]),v._v(" "),_("p",[_("strong",[v._v("得分点")])]),v._v(" "),_("ul",[_("li",[v._v("四种同步策略及其可能出现的问题")]),v._v(" "),_("li",[v._v("重试机制")])]),v._v(" "),_("p",[_("strong",[v._v("标准回答")]),v._v("：")]),v._v(" "),_("p",[v._v("保证缓存和数据库的双写一致性，共有四种同步策略")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("先更新缓存再更新数据库")])]),v._v(" "),_("li",[_("p",[v._v("先更新数据库再更新缓存")])]),v._v(" "),_("li",[_("p",[v._v("先删除缓存再更新数据库")])]),v._v(" "),_("li",[_("p",[v._v("先更新数据库再删除缓存")])])]),v._v(" "),_("p",[v._v("先更新缓存的优点是每次数据变化时都能及时地更新缓存，这样不容易出现查询未命中的情况，但这种操作的消耗很大，如果数据需要经过复杂的计算再写入缓存的话，频繁的更新缓存会影响到服务器的性能。如果是写入数据比较频繁的场景，可能会导致频繁的更新缓存却没有业务来读取该数据。")]),v._v(" "),_("p",[v._v("删除缓存的优点是操作简单，无论更新的操作复杂与否，都是直接删除缓存中的数据。这种做法的缺点则是，当删除了缓存之后，下一次查询容易出现未命中的情况，那么这时就需要再次读取数据库。 那么对比而言，删除缓存无疑是更好的选择。")]),v._v(" "),_("p",[v._v("那么我们再来看一下先操作数据库和后操作数据库的区别；")]),v._v(" "),_("p",[v._v("先删除缓存再操作数据库的话，如果第二步失败可能导致缓存和数据库得到相同的旧数据。")]),v._v(" "),_("p",[v._v("先操作数据库但删除缓存失败的话则会导致缓存和数据库得到的结果不一致。")]),v._v(" "),_("p",[v._v("出现上述问题的时候，我们一般采用"),_("strong",[v._v("重试机制")]),v._v("解决，而为了避免重试机制影响主要业务的执行，一般建议重试机制采用异步的方式执行。当我们采用重试机制之后由于存在并发，先删除缓存依然可能存在缓存中存储了旧的数据，而数据库中存储了新的数据，二者数据不一致的情况。")]),v._v(" "),_("p",[v._v("所以我们得到结论：先更新数据库、再删除缓存是影响更小的方案。如果第二步出现失败的情况，则可以采用重试机制解决问题。")])])}),[],!1,null,null,null);_.default=l.exports}}]);