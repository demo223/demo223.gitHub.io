(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{341:function(s,v,t){"use strict";t.r(v);var e=t(14),_=Object(e.a)({},(function(){var s=this,v=s._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[v("h1",{attrs:{id:"redis面试题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis面试题"}},[s._v("#")]),s._v(" Redis面试题")]),s._v(" "),v("h2",{attrs:{id:"一、redis的常用数据类型有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、redis的常用数据类型有哪些"}},[s._v("#")]),s._v(" 一、redis的常用数据类型有哪些 ?")]),s._v(" "),v("p",[s._v("Redis 有5种常用数据类型(说的是value的数据类型)")]),s._v(" "),v("p",[s._v("Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型")]),s._v(" "),v("ul",[v("li",[s._v("字符串 String：普通字符串，常用")]),s._v(" "),v("li",[s._v("哈希 Hash：适合存储对象")]),s._v(" "),v("li",[s._v("列表 List：按照插入顺序排序，可以有重复元素")]),s._v(" "),v("li",[s._v("集合 Set：无序集合，没有重复元素")]),s._v(" "),v("li",[s._v("有序集合 Sorted Set：有序集合，没有重复元素")])]),s._v(" "),v("hr"),s._v(" "),v("ol",[v("li",[s._v("字符串（String）：用于存储单个字符串值，例如存储==用户的名称、年龄、地址等信息==。也可用于缓存，例如缓存数据或结果等。")]),s._v(" "),v("li",[s._v("列表（List）：用于存储一系列字符串值，例如存储==用户的消息记录、日志记录==等")]),s._v(" "),v("li",[s._v("哈希表（Hash）：用于存储一组键值对，例如存储==用户的详细信息、商品的属性==等。")]),s._v(" "),v("li",[s._v("集合（Set）：用于存储一组唯一的字符串值，例如==存储用户的标签、兴趣==等。")]),s._v(" "),v("li",[s._v("有序集合（Sorted Set）：与集合类似，但每个元素都有一个分值，用于排序。例如==存储用户的积分排名、热门文章==等。")])]),s._v(" "),v("hr"),s._v(" "),v("p",[v("strong",[s._v("得分点")])]),s._v(" "),v("ul",[v("li",[s._v("Redis5种数据结构")])]),s._v(" "),v("p",[v("strong",[s._v("标准回答")])]),s._v(" "),v("p",[s._v("Redis主要提供了5种数据结构："),v("strong",[s._v("字符串")]),s._v("("),v("code",[s._v("string")]),s._v(")、"),v("strong",[s._v("哈希")]),s._v("("),v("code",[s._v("hash")]),s._v(")、"),v("strong",[s._v("列表")]),s._v("("),v("code",[s._v("list")]),s._v(")、"),v("strong",[s._v("集合")]),s._v("("),v("code",[s._v("set")]),s._v(")、"),v("strong",[s._v("有序集合")]),s._v("("),v("code",[s._v("zset")]),s._v(")。Redis还提供了"),v("code",[s._v("Bitmap")]),s._v("、"),v("code",[s._v("HyperLogLog")]),s._v("、"),v("code",[s._v("Geo")]),s._v("类型，但这些类型都是基于上述核心数据类型实现的。5.0版本中，Redis新增加了"),v("code",[s._v("Streams")]),s._v("数据类型，它是一个功能强大的、支持多播的、可持久化的消息队列。")]),s._v(" "),v("ul",[v("li",[v("code",[s._v("string")]),s._v("可以存储字符串、数字和二进制数据，除了值可以是String以外，所有的键也可以是String，String最大可以存储大小为"),v("code",[s._v("2M")]),s._v("的数据。")]),s._v(" "),v("li",[v("code",[s._v("list")]),s._v("保证数据线性有序且元素可重复，它支持lpush、blpush、rpop、brpop等操作，可以当作简单的消息队列使用，一个list最多可以存储"),v("code",[s._v("2^32-1")]),s._v("个元素 hash的值本身也是一个键值对结构，最多能存储2^32-1个元素 set是无序不可重复的，它支持多个set求交集、并集、差集，适合实现共同关注之类的需求，一个set最多可以存储"),v("code",[s._v("2^32-1")]),s._v("个元素 zset是有序不可重复的，它通过给每个元素设置一个分数来作为排序的依据，一个zset最多可以存储"),v("code",[s._v("2^32-1")]),s._v("个元素。")])]),s._v(" "),v("h2",{attrs:{id:"二、跳表你了解吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、跳表你了解吗"}},[s._v("#")]),s._v(" 二、跳表你了解吗？")]),s._v(" "),v("p",[s._v("跳表（Skip List）是一种有序的数据结构，用于维护有序链表。跳表允许快速地插入、删除和查找元素，其平均时间复杂度为 O(log n)，与平衡树相当。跳表由William Pugh在1989年发明，其==基本思想是通过升维来达到加速查找的目的==，这也是跳表名称的由来。")]),s._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20230226204504771.png",alt:"image-20230226204504771"}})]),s._v(" "),v("p",[s._v("Redis中的有序集合（Sorted Set）就是通过跳表来实现的，跳表的每一层都是一个有序链表，每一层的节点数目按指数级递减，同时每个节点都存储着下一层节点的指针，这样可以在多层级的链表中快速地定位到某个节点。")]),s._v(" "),v("hr"),s._v(" "),v("p",[s._v("跳表(SkipList)首先是链表，但与传统的链表相比有几点差异：")]),s._v(" "),v("ul",[v("li",[v("p",[s._v("跳表结合了链表和二分查找的思想")])]),s._v(" "),v("li",[v("p",[s._v("元素按照升序排列存储")])]),s._v(" "),v("li",[v("p",[s._v("节点可能包含多个指针，指针跨度不同")])]),s._v(" "),v("li",[v("p",[s._v("查找时从顶层向下，不断缩小搜索范围")])]),s._v(" "),v("li",[v("p",[s._v("整个查询的复杂度为 O ( log ⁡ n )")])])]),s._v(" "),v("h2",{attrs:{id:"三、redis的数据持久化策略有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三、redis的数据持久化策略有哪些"}},[s._v("#")]),s._v(" 三、Redis的数据持久化策略有哪些 ?")]),s._v(" "),v("p",[s._v("在Redis中提供了两种数据持久化的方式：1、RDB\t2、AOF")]),s._v(" "),v("p",[v("strong",[s._v("RDB：")])]),s._v(" "),v("p",[v("strong",[s._v("定期更新，定期将Redis中的数据生成的快照同步到磁盘等介质上，磁盘上保存的就是Redis的内存快照")])]),s._v(" "),v("p",[s._v("优点：数据文件的大小相比于AOF较小，使用RDB进行数据恢复速度较快")]),s._v(" "),v("p",[s._v("缺点：比较耗时，存在丢失数据的风险")]),s._v(" "),v("p",[v("strong",[s._v("AOF：")])]),s._v(" "),v("p",[v("strong",[s._v("将Redis所执行过的所有指令都记录下来，在下次Redis重启时，只需要执行指令就可以了")])]),s._v(" "),v("p",[s._v("优点：数据丢失的风险大大降低了")]),s._v(" "),v("p",[s._v("缺点：数据文件的大小相比于RDB较大，使用AOF文件进行数据恢复的时候速度较慢")]),s._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20230226210030295.png",alt:"image-20230226210030295"}})]),s._v(" "),v("p",[s._v("RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用。")]),s._v(" "),v("hr"),s._v(" "),v("p",[s._v("Redis的数据持久化策略有以下两种：")]),s._v(" "),v("ol",[v("li",[s._v("RDB持久化：将Redis在内存中的数据定期dump到硬盘上，生成一个快照文件。该策略可以通过设置触发快照的时间间隔或数据变化的数量来控制，以便在系统宕机时尽可能地恢复数据。==该策略适用于数据量较大的场景==。")]),s._v(" "),v("li",[s._v("AOF持久化：将Redis的每个写操作都记录到一个追加日志文件（append-only file）中，以便在系统宕机时恢复数据。该策略可以通过设置同步频率（每秒同步或每次写操作同步）来控制数据的持久化。==该策略适用于对数据实时性要求较高的场景==。")])]),s._v(" "),v("p",[s._v("此外，Redis还支持两种混合的持久化策略：")]),s._v(" "),v("ol",[v("li",[s._v("AOF重写：将AOF文件中的冗余数据去除，并生成一个新的AOF文件。")]),s._v(" "),v("li",[s._v("RDB和AOF混合持久化：定期进行RDB持久化，同时使用AOF记录新的写操作，以便在系统宕机时可以快速恢复数据。")])]),s._v(" "),v("hr"),s._v(" "),v("p",[s._v("RDB持久化在四种情况下会执行：")]),s._v(" "),v("ul",[v("li",[v("p",[s._v("执行save命令")]),s._v(" "),v("p",[s._v("save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。")])]),s._v(" "),v("li",[v("p",[s._v("执行bgsave命令")]),s._v(" "),v("p",[s._v("这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。")])]),s._v(" "),v("li",[v("p",[s._v("Redis停机时")]),s._v(" "),v("p",[s._v("Redis停机时会执行一次save命令，实现RDB持久化。")])]),s._v(" "),v("li",[v("p",[s._v("触发RDB条件时")]),s._v(" "),v("p",[s._v("save 60 1000\t代表60秒内至少执行1000次修改则触发RDB")])])]),s._v(" "),v("h2",{attrs:{id:"四、redis集群有哪些方案-知道嘛"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四、redis集群有哪些方案-知道嘛"}},[s._v("#")]),s._v(" 四、Redis集群有哪些方案, 知道嘛 ?")]),s._v(" "),v("p",[s._v("Redis支持三种集群方案")]),s._v(" "),v("ul",[v("li",[s._v("主从复制模式\n"),v("ul",[v("li",[s._v("保证高可用性")]),s._v(" "),v("li",[s._v("==实现故障转移需要手动实现==")]),s._v(" "),v("li",[s._v("==无法实现海量数据存储==")])])]),s._v(" "),v("li",[s._v("Sentinel（哨兵）模式\n"),v("ul",[v("li",[s._v("保证高可用性")]),s._v(" "),v("li",[s._v("==可以实现自动化的故障转移==")]),s._v(" "),v("li",[s._v("无法实现海量数据存储")])])]),s._v(" "),v("li",[s._v("Cluster(集群)模式\n"),v("ul",[v("li",[s._v("保证高可用性")]),s._v(" "),v("li",[s._v("==可以实现自动化的故障转移==")]),s._v(" "),v("li",[s._v("==可以实现海量数据存储==")])])])]),s._v(" "),v("hr"),s._v(" "),v("p",[s._v("Redis支持三种集群方案，分别是主从复制模式、Sentinel（哨兵）模式和Cluster模式。")]),s._v(" "),v("ul",[v("li",[v("p",[v("strong",[s._v("主从复制模式")]),s._v("是一种简单的集群方案，它将一台Redis服务器作为主服务器，其他服务器作为从服务器，从服务器会定期从主服务器复制数据，以保证数据的一致性。")]),s._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20230226214852819.png",alt:"image-20230226214852819"}})])]),s._v(" "),v("li",[v("p",[v("strong",[s._v("Sentinel（哨兵）模式")]),s._v("是一种高可用的集群方案，它将多台Redis服务器组成一个集群，并且每台服务器都会运行一个Sentinel（哨兵）进程，Sentinel（哨兵）进程会定期检查主服务器的状态，如果发现主服务器出现故障，就会自动将从服务器升级为主服务器，以保证集群的高可用性。")]),s._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20230226214903940.png",alt:"image-20230226214903940"}})]),s._v(" "),v("p",[s._v("哨兵的作用如下：")]),s._v(" "),v("ul",[v("li",[v("strong",[s._v("监控")]),s._v("：Sentinel 会不断检查您的master和slave是否按预期工作")]),s._v(" "),v("li",[v("strong",[s._v("自动故障恢复")]),s._v("：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主")]),s._v(" "),v("li",[v("strong",[s._v("通知")]),s._v("：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端")])]),s._v(" "),v("hr"),s._v(" "),v("p",[v("strong",[s._v("集群监控原理")])]),s._v(" "),v("p",[s._v("Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：")]),s._v(" "),v("p",[s._v("•主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例"),v("strong",[s._v("主观下线")]),s._v("。")]),s._v(" "),v("p",[s._v("•客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例"),v("strong",[s._v("客观下线")]),s._v("。quorum值最好超过Sentinel实例数量的一半。")])]),s._v(" "),v("li",[v("p",[v("strong",[s._v("Cluster模式")]),s._v("是一种高性能的集群方案，它将多台Redis服务器组成一个集群，并且每台服务器都会运行一个Cluster进程，Cluster进程会负责将数据分布到不同的服务器上，以提高集群的性能。")]),s._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20230226214925250.png",alt:"image-20230226214925250"}})])])]),s._v(" "),v("hr"),s._v(" "),v("p",[v("strong",[s._v("主从模式优缺点")])]),s._v(" "),v("ol",[v("li",[v("strong",[s._v("优点")]),s._v(": 主从结构具有读写分离，提高效率、数据备份，提供多个副本等优点。")]),s._v(" "),v("li",[v("strong",[s._v("不足")]),s._v(": ==最大的不足就是主从模式不具备自动容错和恢复功能，主节点故障，集群则无法进行工作，可用性比较低，从节点升主节点需要人工手动干预==。")])]),s._v(" "),v("p",[s._v("普通的主从模式，当主数据库崩溃时，需要手动切换从数据库成为主数据库:")]),s._v(" "),v("ol",[v("li",[s._v("在从数据库中使用"),v("code",[s._v("SLAVE NO ONE")]),s._v("命令将从数据库提升成主数据继续服务。")]),s._v(" "),v("li",[s._v("启动之前崩溃的主数据库，然后使用SLAVEOF命令将其设置成新的主数据库的从数据库，即可同步数据。")])]),s._v(" "),v("hr"),s._v(" "),v("p",[v("strong",[s._v("哨兵模式优缺点")])]),s._v(" "),v("p",[s._v("1.优点")]),s._v(" "),v("ul",[v("li",[s._v("==哨兵模式是基于主从模式的，解决可主从模式中master故障不可以自动切换故障的问题==。")])]),s._v(" "),v("p",[s._v("2.不足-问题")]),s._v(" "),v("ul",[v("li",[s._v("==是一种中心化的集群实现方案：始终只有一个Redis主机来接收和处理写请求，写操作受单机瓶颈影响==。")]),s._v(" "),v("li",[s._v("集群里所有节点保存的都是全量数据，浪费内存空间，没有真正实现分布式存储。数据量过大时，主从同步严重影响master的性能。")]),s._v(" "),v("li",[s._v("Redis主机宕机后，哨兵模式正在投票选举的情况之外，因为投票选举结束之前，谁也不知道主机和从机是谁，此时Redis也会开启保护机制，禁止写操作，直到选举出了新的Redis主机。")])]),s._v(" "),v("p",[s._v("主从模式或哨兵模式每个节点存储的数据都是全量的数据，数据量过大时，就需要对存储的数据进行分片后存储到多个redis实例上。此时就要用到Redis Sharding技术。")]),s._v(" "),v("hr"),s._v(" "),v("p",[v("strong",[s._v("Cluster 集群模式")])]),s._v(" "),v("p",[s._v("Redis 的哨兵模式虽然已经可以实现高可用，读写分离 ，但是存在几个方面的不足：")]),s._v(" "),v("ul",[v("li",[s._v("哨兵模式下每台 Redis 服务器都存储相同的数据，很浪费内存空间；数据量太大，主从同步时严重影响了master性能。")]),s._v(" "),v("li",[s._v("哨兵模式是中心化的集群实现方案，每个从机和主机的耦合度很高，master宕机到salve选举master恢复期间服务不可用。")]),s._v(" "),v("li",[s._v("哨兵模式始终只有一个Redis主机来接收和处理写请求，写操作还是受单机瓶颈影响，没有实现真正的分布式架构。")])]),s._v(" "),v("p",[s._v("redis在3.0上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，也就是说每台 Redis 节点上存储不同的数据。cluster模式为了解决单机Redis容量有限的问题，将数据按一定的规则分配到多台机器，内存/QPS不受限于单机，可受益于分布式集群高扩展性。")]),s._v(" "),v("p",[v("code",[s._v("Redis Cluster")]),s._v("是一种服务器Sharding技术(分片和路由都是在服务端实现)，采用多主多从，每一个分区都是由一个Redis主机和多个从机组成，片区和片区之间是相互平行的。"),v("code",[s._v("Redis Cluster")]),s._v("集群采用了P2P的模式，完全去中心化。")]),s._v(" "),v("h2",{attrs:{id:"什么是-redis-主从同步"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是-redis-主从同步"}},[s._v("#")]),s._v(" 什么是 Redis 主从同步？")]),s._v(" "),v("ul",[v("li",[v("p",[s._v("Redis主从同步是指将一台Redis服务器的数据复制到其他一台或多台Redis服务器的过程。在主从同步期间，主节点将数据的更改操作记录在内存中的AOF日志或RDB文件中，并向所有从节点发送同步命令，使得从节点能够获取到最新的数据。")]),s._v(" "),v("p",[s._v("Redis主从同步分为全量同步和增量同步两个阶段。")]),s._v(" "),v("p",[v("strong",[s._v("全量同步")]),s._v("： 当从节点刚刚加入主从复制架构中，或者重新连接到主节点时，需要进行一次全量同步。全量同步会将主节点上的所有数据快照一份复制到从节点上。在全量同步的过程中，主节点会将自己的数据集发送给从节点，从节点接收到数据集之后会将自己的数据集替换成主节点的数据集。")]),s._v(" "),v("p",[v("strong",[s._v("增量同步")]),s._v("： 在全量同步完成之后，从节点会与主节点进行增量同步，从节点会接收并同步主节点的AOF日志或RDB文件中的增量数据更新。在增量同步过程中，主节点会将自己执行的每个写命令发送给从节点。从节点在接收到命令之后，将命令应用到自己的数据集中。")]),s._v(" "),v("p",[s._v("总体流程：")]),s._v(" "),v("ol",[v("li",[s._v("从节点连接到主节点，并发送SYNC命令请求主节点进行同步")]),s._v(" "),v("li",[s._v("主节点接收到SYNC命令后，开始进行全量同步。主节点向从节点发送RDB文件并将自己的写命令缓存到内存缓冲区中，防止丢失")]),s._v(" "),v("li",[s._v("从节点接收到主节点的RDB文件并将自己的数据集替换成主节点的数据集")]),s._v(" "),v("li",[s._v("主节点将自己内存缓冲区中的写命令发送给从节点，从节点将命令应用到自己的数据集中")]),s._v(" "),v("li",[s._v("主从同步完成，从节点成为了主节点的一份子节点，可以进行读取和写入操作")])]),s._v(" "),v("p",[s._v("在Redis主从同步中，如果主节点出现宕机或者其他故障，可以使用哨兵或者Redis集群进行自动故障转移。")])])]),s._v(" "),v("h2",{attrs:{id:"五、项目中哪块使用了缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#五、项目中哪块使用了缓存"}},[s._v("#")]),s._v(" 五、项目中哪块使用了缓存？")]),s._v(" "),v("p",[s._v("结合自己简历上写的项目模块说明这个问题，要陈述出当时的场景")]),s._v(" "),v("p",[s._v("黑马头条：")]),s._v(" "),v("ul",[v("li",[s._v("用户行为数据")]),s._v(" "),v("li",[s._v("热点文章")])]),s._v(" "),v("p",[s._v("其他：")]),s._v(" "),v("ul",[v("li",[s._v("热点数据")])]),s._v(" "),v("h2",{attrs:{id:"六、什么是缓存穿透-怎么解决"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#六、什么是缓存穿透-怎么解决"}},[s._v("#")]),s._v(" 六、什么是缓存穿透 ? 怎么解决 ?")]),s._v(" "),v("p",[s._v("缓存穿透是指一个查询==不存在于缓存中，也不存在于后端数据库中的数据==，因此每次请求都会穿透缓存访问后端数据库，导致数据库压力过大，影响系统的性能。攻击者可以通过构造恶意数据来大量请求缓存，造成缓存穿透攻击。")]),s._v(" "),v("p",[s._v("缓存穿透的解决方案有以下几种：")]),s._v(" "),v("ol",[v("li",[v("p",[v("strong",[s._v("布隆过滤器")]),s._v("：将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。")])]),s._v(" "),v("li",[v("p",[v("strong",[s._v("缓存空对象")]),s._v("：如果一个查询返回的数据为空（不管是数据不存在还是系统故障），仍然将其缓存起来，并设置一个较短的过期时间，这样可以防止缓存穿透攻击。")]),s._v(" "),v("blockquote",[v("p",[s._v("1、"),v("strong",[s._v("把无效的Key存进Redis中")]),s._v('。如果Redis查不到数据，数据库也查不到，我们把这个Key值保存进Redis，设置value="null"，当下次再通过这个Key查询时就不需要再查询数据库。这种处理方式肯定是有问题的，假如传进来的这个不存在的Key值每次都是随机的，那存进Redis也没有意义。')])])]),s._v(" "),v("li",[v("p",[v("strong",[s._v("限流")]),s._v("：在接口层增加限流措施，比如单 IP 限流、接口限流等手段，可以有效减少对缓存和数据库的冲击。")])]),s._v(" "),v("li",[v("p",[v("strong",[s._v("接口层校验")]),s._v("：在系统接口层增加校验，比如用户鉴权、参数校验等，可以有效防止恶意攻击。")])])]),s._v(" "),v("blockquote",[v("p",[s._v("缓存穿透指的是数据库本就没有这个数据，请求直奔数据库，缓存系统形同虚设。")]),s._v(" "),v("p",[s._v("缓存击穿(失效)指的是数据库有数据，缓存本应该也有数据，但是缓存过期了，Redis 这层流量防护屏障被击穿了，请求直奔数据库。")])]),s._v(" "),v("h2",{attrs:{id:"七、什么是缓存击穿-怎么解决"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#七、什么是缓存击穿-怎么解决"}},[s._v("#")]),s._v(" 七、什么是缓存击穿 ? 怎么解决 ?")]),s._v(" "),v("p",[s._v("缓存击穿是指在高并发情况下，一个热点"),v("code",[s._v("key")]),s._v("在失效的同时，大量==并发请求==同时查询数据库或者其他缓存中获取数据，导致大量请求直接绕过缓存，直接请求后端数据库或其他缓存，从而导致数据库或其他缓存的负载压力过大，甚至宕机的情况。")]),s._v(" "),v("p",[s._v("Redis中一个热点key在失效的同时，大量的请求过来，从而会全部到达数据库，压垮数据库。")]),s._v(" "),v("p",[s._v("解决缓存击穿问题的方法可以有以下几种：")]),s._v(" "),v("ol",[v("li",[v("strong",[s._v("设置热点数据永不过期")]),s._v("：将热点数据设置为永久有效，这样即使缓存被清空，热点数据也可以通过缓存自动加载。这种方式比较适用于热点数据量较小的场景。")]),s._v(" "),v("li",[v("strong",[s._v("数据预热")]),s._v("：系统启动时将可能访问的数据预先加载到缓存中，这样可以避免在系统运行过程中因为查询不存在的数据而产生的缓存击穿问题。")]),s._v(" "),v("li",[v("strong",[s._v("加互斥锁")]),s._v("：当某个请求发现缓存中没有数据时，可以加互斥锁，防止其他并发请求同时访问数据库，只允许一个请求进行数据库查询操作，其他请求等待锁的释放。这种方式可以解决缓存击穿问题，但是会影响系统的并发性能。")]),s._v(" "),v("li",[v("strong",[s._v("熔断降级")]),s._v("：在缓存击穿时，通过熔断降级的方式，直接返回默认值或错误提示信息，而不是继续请求后端数据库或其他缓存。这种方式可以保护后端的系统免于崩溃，但是对业务会造成一定影响，需要根据实际情况进行权衡。")])]),s._v(" "),v("blockquote",[v("p",[s._v("缓存穿透和缓存击穿都是缓存问题，但是它们发生的原因和解决方法不同。")]),s._v(" "),v("p",[s._v("缓存穿透指的是查询一个一定不存在的数据，由于缓存不命中，请求会穿过缓存到达数据库，这样可能导致数据库压力过大。解决缓存穿透问题可以采用布隆过滤器等技术，对查询的 key 进行过滤，过滤掉不合法的 key，从而减少对底层存储的访问压力。")]),s._v(" "),v("p",[s._v("缓存击穿指的是一个 key 非常热点，在不停的承受大并发访问，当这个 key 在失效的瞬间，持续的大并发请求直接打到数据库，导致数据库压力过大。解决缓存击穿问题可以采用加锁等技术，在缓存失效的时候，通过加锁等方式，保证只有一个请求访问数据库，其他请求等待访问结果。此外，可以采用永不过期的方式，即在缓存失效的时候，不立刻删除缓存，而是将缓存设置为永不过期，等待缓存更新后再删除旧缓存，从而避免缓存击穿问题的发生。")])]),s._v(" "),v("h2",{attrs:{id:"八、什么是缓存雪崩-怎么解决"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#八、什么是缓存雪崩-怎么解决"}},[s._v("#")]),s._v(" 八、什么是缓存雪崩 ? 怎么解决 ?")]),s._v(" "),v("p",[s._v("缓存雪崩指的是在同一时间大量缓存数据过期失效，导致大量请求直接打到后端数据库上，从而导致数据库短时间内承受过大的压力，甚至瘫痪。这是因为缓存过期时间设置过于集中，导致缓存失效时间一到，大量请求瞬间打到数据库上。")]),s._v(" "),v("p",[s._v("为了解决缓存雪崩问题，可以采取以下措施：")]),s._v(" "),v("ol",[v("li",[s._v("缓存数据的过期时间设置随机，避免同一时间大量缓存数据失效。比如可以在原有的过期时间基础上加上一个随机值，避免同一时间过多的缓存数据失效。")]),s._v(" "),v("li",[s._v("设置热点数据永不过期。针对一些比较热门的数据，可以设置其永不过期，确保缓存数据不会因为过期而失效。")]),s._v(" "),v("li",[s._v("分布式部署。将缓存数据部署在多台机器上，避免单点故障，提高缓存系统的可用性。")])]),s._v(" "),v("h2",{attrs:{id:"九、什么是布隆过滤器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#九、什么是布隆过滤器"}},[s._v("#")]),s._v(" 九、什么是布隆过滤器？")]),s._v(" "),v("p",[s._v("布隆过滤器（Bloom Filter）是 1970 年由布隆提出的。它实际上是一个很长的==二进制向量==和一系列==随机映射函数==。布隆过滤器可以用于检索一个元素是否在一个集合中。"),v("strong",[s._v("它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难")]),s._v("。")]),s._v(" "),v("p",[s._v("具体实现方式如下：")]),s._v(" "),v("ol",[v("li",[s._v("初始化一个长度为m的比特位数组，所有的比特位都初始化为0。")]),s._v(" "),v("li",[s._v("定义k个不同的哈希函数，每个哈希函数可以将任何一个元素映射到m个比特位的某些位置上。")]),s._v(" "),v("li",[s._v("当有新元素加入时，将其通过k个哈希函数映射到比特位数组上，并将相应的比特位置为1。")]),s._v(" "),v("li",[s._v("当查询某个元素是否存在于集合中时，将该元素通过k个哈希函数映射到比特位数组上，并判断相应的比特位是否都为1。==如果有任何一个比特位为0，则该元素一定不存在于集合中；如果所有比特位都为1，则该元素可能存在于集合中==。")])]),s._v(" "),v("p",[s._v("需要注意的是，布隆过滤器是一个概率型数据结构，存在一定的误判率。在元素个数和比特位数固定的情况下，误判率随哈希函数个数k的增加而降低，但同时也会增加运行时间和空间占用。")]),s._v(" "),v("h2",{attrs:{id:"十、redis双写问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#十、redis双写问题"}},[s._v("#")]),s._v(" 十、Redis双写问题")]),s._v(" "),v("p",[s._v("Redis双写问题是指在使用Redis作为缓存的情况下，当数据更新时，可能会发生缓存和数据库不一致的问题。这是由于在更新数据库之后，由于缓存的延迟刷新等原因，Redis中的缓存数据可能还是旧的数据。这就导致了缓存和数据库的数据不一致。")]),s._v(" "),v("p",[s._v("保证缓存和数据库的双写一致性，共有四种同步策略")]),s._v(" "),v("ul",[v("li",[v("p",[s._v("先更新缓存再更新数据库")])]),s._v(" "),v("li",[v("p",[s._v("先更新数据库再更新缓存")])]),s._v(" "),v("li",[v("p",[s._v("先删除缓存再更新数据库")])]),s._v(" "),v("li",[v("p",[s._v("先更新数据库再删除缓存 (推荐)")])])]),s._v(" "),v("hr"),s._v(" "),v("p",[v("strong",[s._v("先更新缓存")]),s._v("的优点是每次数据变化时都能及时地更新缓存，这样不容易出现查询未命中的情况，但这种操作的消耗很大，如果数据需要经过复杂的计算再写入缓存的话，频繁的更新缓存会影响到服务器的性能。如果是写入数据比较频繁的场景，可能会导致频繁的更新缓存却没有业务来读取该数据。")]),s._v(" "),v("p",[v("strong",[s._v("删除缓存")]),s._v("的优点是操作简单，无论更新的操作复杂与否，都是直接删除缓存中的数据。这种做法的缺点则是，当删除了缓存之后，下一次查询容易出现未命中的情况，那么这时就需要再次读取数据库。 那么对比而言，删除缓存无疑是更好的选择。")]),s._v(" "),v("p",[v("strong",[s._v("先删除缓存")]),s._v("再操作数据库的话，如果第二步失败可能导致缓存和数据库得到相同的旧数据。")]),s._v(" "),v("p",[s._v("先操作数据库但删除缓存失败的话则会导致缓存和数据库得到的结果不一致。")]),s._v(" "),v("p",[s._v("出现上述问题的时候，我们一般采用"),v("strong",[s._v("重试机制")]),s._v("解决，而为了避免重试机制影响主要业务的执行，一般建议重试机制采用异步的方式执行。当我们采用重试机制之后由于存在并发，先删除缓存依然可能存在缓存中存储了旧的数据，而数据库中存储了新的数据，二者数据不一致的情况。")]),s._v(" "),v("p",[s._v("所以我们得到结论：==先更新数据库、再删除缓存是影响更小的方案==。如果第二步出现失败的情况，则可以采用重试机制解决问题。")]),s._v(" "),v("hr"),s._v(" "),v("p",[s._v("同步方案：")]),s._v(" "),v("p",[s._v("普通缓存，一般采用更新时删除缓存，查询时建立缓存的延迟更新方案。")]),s._v(" "),v("p",[s._v("异步方案：")]),s._v(" "),v("p",[s._v("1、使用消息队列进行缓存同步：更改代码加入异步操作缓存的逻辑代码(数据库操作完毕以后，将要同步的数据发送到MQ中，MQ的消费者从MQ中获取数据，然后更新缓存)")]),s._v(" "),v("p",[s._v("2、使用阿里巴巴旗下的canal组件实现数据同步：不需要更改业务代码，部署一个canal服务。canal服务把自己伪装成mysql的一个从节点，当mysql数据更新以后，canal会读取binlog数据，然后在通过canal的客户端获取到数据，更新缓存即可。")]),s._v(" "),v("h2",{attrs:{id:"十一、redis分布式锁如何实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#十一、redis分布式锁如何实现"}},[s._v("#")]),s._v(" 十一、Redis分布式锁如何实现 ?")]),s._v(" "),v("p",[s._v("Redis实现分布式锁主要利用Redis的"),v("strong",[s._v("setnx")]),s._v("命令。setnx是SET if not exists(如果不存在，则 SET)的简写。")]),s._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220825225528939.png",alt:"image-20220825225528939"}})]),s._v(" "),v("p",[s._v("上面这几个命令就是最基本的用来完成分布式锁的命令。")]),s._v(" "),v("p",[v("strong",[s._v("加锁")]),s._v("：使用"),v("code",[s._v("setnx key value")]),s._v("命令，如果key不存在，设置value(加锁成功)。如果已经存在lock(也就是有客户端持有锁了)，则设置失败(加锁失败)。")]),s._v(" "),v("p",[v("strong",[s._v("解锁")]),s._v("：使用"),v("code",[s._v("del")]),s._v("命令，通过删除键值释放锁。释放锁之后，其他客户端可以通过"),v("code",[s._v("setnx")]),s._v("命令进行加锁。")]),s._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("boolean")]),s._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[s._v("tryLock")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),v("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("long")]),s._v(" timeoutSec"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),v("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 获取线程标示")]),s._v("\n    "),v("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),s._v(" threadId "),v("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),v("span",{pre:!0,attrs:{class:"token constant"}},[s._v("ID_PREFIX")]),s._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Thread")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[s._v("currentThread")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[s._v("getId")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),v("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 获取锁")]),s._v("\n    "),v("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Boolean")]),s._v(" success "),v("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" stringRedisTemplate"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[s._v("opsForValue")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n        "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[s._v("setIfAbsent")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),v("span",{pre:!0,attrs:{class:"token constant"}},[s._v("KEY_PREFIX")]),s._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" name"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" threadId"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" timeoutSec"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("TimeUnit")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),v("span",{pre:!0,attrs:{class:"token constant"}},[s._v("SECONDS")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Boolean")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),v("span",{pre:!0,attrs:{class:"token constant"}},[s._v("TRUE")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[s._v("equals")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("success"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[s._v("1")]),v("br"),v("span",{staticClass:"line-number"},[s._v("2")]),v("br"),v("span",{staticClass:"line-number"},[s._v("3")]),v("br"),v("span",{staticClass:"line-number"},[s._v("4")]),v("br"),v("span",{staticClass:"line-number"},[s._v("5")]),v("br"),v("span",{staticClass:"line-number"},[s._v("6")]),v("br"),v("span",{staticClass:"line-number"},[s._v("7")]),v("br"),v("span",{staticClass:"line-number"},[s._v("8")]),v("br")])]),v("p",[s._v("Redis 锁主要利用 Redis 的 "),v("code",[s._v("setnx")]),s._v("命令。先用"),v("code",[s._v("setnx")]),s._v("来抢锁，如果抢到之后，再用"),v("code",[s._v("expire")]),s._v("给锁设置一个过期时间，防止锁忘记了释放。")]),s._v(" "),v("ul",[v("li",[s._v("加锁(获取锁)命令："),v("code",[s._v("SETNX key value")]),s._v("，当键不存在时，对键进行设置操作并返回1表示成功获得锁，否则返回0，则表示锁已经被其他客户端获取。KEY 是锁的唯一标识，一般按业务来决定命名。")]),s._v(" "),v("li",[s._v("解锁(释放锁)命令："),v("code",[s._v("DEL key")]),s._v("，通过删除键值对释放锁，以便其他线程可以通过 "),v("code",[s._v("SETNX")]),s._v("命令来获取锁。")]),s._v(" "),v("li",[s._v("锁超时："),v("code",[s._v("EXPIRE key timeout")]),s._v(", 设置 key 的超时时间，以保证即使锁没有被显式释放，锁也可以在一定时间后自动释放，避免资源被永远锁住。")])]),s._v(" "),v("hr"),s._v(" "),v("p",[s._v("上述锁实现方式存在一些问题：")]),s._v(" "),v("p",[s._v("如果 "),v("code",[s._v("SETNX")]),s._v("成功，在设置锁超时时间后，服务器挂掉、重启或网络问题等，导致 "),v("code",[s._v("EXPIRE")]),s._v("命令没有执行，锁没有设置超时时间变成死锁。")]),s._v(" "),v("p",[v("strong",[s._v("解决方案")])]),s._v(" "),v("ol",[v("li",[v("p",[s._v("使用 SET命令代替 "),v("code",[s._v("SETNX")]),s._v("和 "),v("code",[s._v("EXPIRE")]),s._v("命令的组合，因为 SET命令可以一次性设置键的值和过期时间，这样可以减少出错的机会。")])]),s._v(" "),v("li",[v("p",[s._v("为了保证原子性，可以使用 Redis 2.6.12及以上版本提供的 SET命令的"),v("code",[s._v("NX")]),s._v("和"),v("code",[s._v("EX")]),s._v("选项，这两个选项可以保证 SET命令的原子性。使用方法如下：")]),s._v(" "),v("div",{staticClass:"language-properties line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-properties"}},[v("code",[v("span",{pre:!0,attrs:{class:"token key attr-name"}},[s._v("SET")]),s._v(" "),v("span",{pre:!0,attrs:{class:"token value attr-value"}},[s._v("key value EX seconds NX")]),s._v("\n")])]),s._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[s._v("1")]),v("br")])]),v("p",[s._v("其中，NX选项表示只有在键不存在时才进行设置，而EX选项表示为键设置过期时间。")]),s._v(" "),v("p",[s._v("或者使用 "),v("code",[s._v("Setex")]),s._v("命令为指定的 key 设置值及其过期时间。如果 key 已经存在， SETEX 命令将会替换旧的值。")]),s._v(" "),v("div",{staticClass:"language-properties line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-properties"}},[v("code",[v("span",{pre:!0,attrs:{class:"token key attr-name"}},[s._v("SETEX")]),s._v(" "),v("span",{pre:!0,attrs:{class:"token value attr-value"}},[s._v("KEY_NAME TIMEOUT VALUE")]),s._v("\n")])]),s._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[s._v("1")]),v("br")])])])]),s._v(" "),v("hr"),s._v(" "),v("p",[s._v("当然也可以提过"),v("code",[s._v("Redisson")]),s._v("来解决，Redisson是一个基于Redis的Java客户端，提供了丰富的分布式对象和服务。")]),s._v(" "),v("p",[v("code",[s._v("Redisson")]),s._v("的分布式锁实现方式与前面介绍的基于"),v("code",[s._v("SETNX")]),s._v("和"),v("code",[s._v("EXPIRE")]),s._v("的方式类似，但是"),v("code",[s._v("Redisson")]),s._v("在实现中考虑了更多的情况，例如避免死锁和防止误删锁等问题。")]),s._v(" "),v("p",[s._v("具体来说，Redisson分布式锁实现的主要流程如下：")]),s._v(" "),v("ol",[v("li",[s._v("客户端调用Redisson的"),v("code",[s._v("lock()")]),s._v("方法请求获取锁。")]),s._v(" "),v("li",[s._v("Redisson会在Redis中使用SET命令尝试获取锁，同时设置一个过期时间，防止锁忘记释放而导致死锁。")]),s._v(" "),v("li",[s._v("如果获取锁成功，则将锁标识（例如客户端ID）存储到Redis中，并返回一个代表锁的RFuture对象。")]),s._v(" "),v("li",[s._v("如果获取锁失败，则Redisson会根据设置的重试次数和等待时间，自动重试获取锁操作。")]),s._v(" "),v("li",[s._v("当客户端释放锁时，Redisson会使用Lua脚本将锁标识和当前线程ID匹配后，使用DEL命令删除锁。")]),s._v(" "),v("li",[s._v("如果客户端因为某种原因崩溃了，Redisson会使用锁的过期时间来自动释放锁，避免出现死锁情况。")])]),s._v(" "),v("h2",{attrs:{id:"十二、redis集群脑裂问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#十二、redis集群脑裂问题"}},[s._v("#")]),s._v(" 十二、Redis集群脑裂问题")]),s._v(" "),v("p",[s._v("集群脑裂指因为网络问题，导致 Redis master 节点跟 slave 节点和 sentinel 集群处于不同的网络分区，因为 sentinel 集群无法感知到 master 的存在，所以将 slave 节点提升为 master 节点，此时存在两个不同的 master 节点。Redis Cluster 集群部署方式同理。")]),s._v(" "),v("hr"),s._v(" "),v("p",[s._v("关于reids集群会由于网络等原因出现脑裂的情况，所谓的集群脑裂就是，由于redis master节点和redis salve节点和sentinel处于不同的网络分区，使得sentinel没有能够心跳感知到master，所以通过选举的方式提升了一个salve为master，这样就存在了两个master，就像大脑分裂了一样，这样会导致客户端还在old master那里写入数据，新节点无法同步数据，当网络恢复后，sentinel会将old master降为salve，这时再从新master同步数据，这会导致大量数据丢失。")]),s._v(" "),v("p",[v("img",{attrs:{src:"https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/redis-lock-08.png",alt:"img"}})]),s._v(" "),v("p",[v("strong",[s._v("解决方案：")])]),s._v(" "),v("ul",[v("li",[v("p",[s._v("设置每个 master 限制 slave 的数量")]),s._v(" "),v("p",[s._v("redis 的配置文件中，存在两个参数")]),s._v(" "),v("div",{staticClass:"language-properties line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-properties"}},[v("code",[v("span",{pre:!0,attrs:{class:"token key attr-name"}},[s._v("min-slaves-to-write")]),s._v(" "),v("span",{pre:!0,attrs:{class:"token value attr-value"}},[s._v("3\t#\t要求master必须有3个slaver")]),s._v("\n"),v("span",{pre:!0,attrs:{class:"token key attr-name"}},[s._v("min-slaves-max-lag")]),s._v(" "),v("span",{pre:!0,attrs:{class:"token value attr-value"}},[s._v("10\t#\t要求slave连接到master(数据复制和同步)的最大延迟时间不能超过10s")]),s._v("\n")])]),s._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[s._v("1")]),v("br"),v("span",{staticClass:"line-number"},[s._v("2")]),v("br")])])])]),s._v(" "),v("p",[s._v("配置了这两个参数：如果发生脑裂：原master会在客户端写入操作的时候拒绝请求。这样可以避免大量数据丢失。")]),s._v(" "),v("blockquote",[v("p",[v("strong",[s._v("注意：较新版本的 redis.conf 文件中的参数变成了")])]),s._v(" "),v("div",{staticClass:"language-properties line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-properties"}},[v("code",[v("span",{pre:!0,attrs:{class:"token key attr-name"}},[s._v("min-replicas-to-write")]),s._v(" "),v("span",{pre:!0,attrs:{class:"token value attr-value"}},[s._v("3")]),s._v("\n"),v("span",{pre:!0,attrs:{class:"token key attr-name"}},[s._v("min-replicas-max-lag")]),s._v(" "),v("span",{pre:!0,attrs:{class:"token value attr-value"}},[s._v("10")]),s._v("\n")])]),s._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[s._v("1")]),v("br"),v("span",{staticClass:"line-number"},[s._v("2")]),v("br")])])]),s._v(" "),v("h2",{attrs:{id:"十三、redisson实现的分布式锁是可重入的吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#十三、redisson实现的分布式锁是可重入的吗"}},[s._v("#")]),s._v(" 十三、redisson实现的分布式锁是可重入的吗？")]),s._v(" "),v("p",[s._v("是的，Redisson实现的分布式锁是可重入的。Redisson基于Redis的分布式锁实现了Java版本的分布式锁，支持可重入锁和公平锁等特性。在Redisson的实现中，通过对每个线程维护一个计数器，来记录该线程持有锁的次数，从而实现可重入锁。当一个线程获取到锁后，它会将计数器加1，当释放锁时，计数器减1，只有当计数器变为0时，才能真正地释放锁。这样可以确保同一个线程可以多次获取同一个锁而不会出现死锁的问题。")]),s._v(" "),v("p",[s._v("需要注意的是，在使用可重入锁时，需要注意计数器的使用，防止出现计数器误操作等问题，从而影响锁的正确性和可用性。此外，在高并发环境下，需要合理设置锁的超时时间，以防止出现死锁等问题。")]),s._v(" "),v("h2",{attrs:{id:"十四、redis的数据过期策略有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#十四、redis的数据过期策略有哪些"}},[s._v("#")]),s._v(" 十四、Redis的数据过期策略有哪些 ?")]),s._v(" "),v("p",[s._v("数据删除策略：Redis中可以对数据设置数据的有效时间，数据的有效时间到了以后，就需要将数据从内存中删除掉。而删除的时候就需要按照指定的规则进行删除，这种删除规则就被称之为数据的删除策略。")]),s._v(" "),v("p",[s._v("==Redis的过期策略就是指当Redis中缓存的key过期了以后，Redis是如何处理的==。")]),s._v(" "),v("p",[s._v("Redis提供了多种数据过期策略，包括以下几种：")]),s._v(" "),v("ol",[v("li",[v("p",[v("strong",[s._v("定时过期")]),s._v("：Redis支持对key设置过期时间，可以在写入数据时为key设置一个过期时间，当该时间到达时，Redis会自动删除该key。这种过期策略适用于数据比较固定的场景，如缓存一些不经常变化的数据。")]),s._v(" "),v("p",[v("strong",[s._v("优点")]),s._v("：保证内存被尽快释放")]),s._v(" "),v("p",[v("strong",[s._v("缺点")]),s._v("：对CPU不友好，若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key。")]),s._v(" "),v("blockquote",[v("p",[s._v("对于用户登录获取验证码的场景，验证码的有效期一般是比较短暂的，例如5分钟或10分钟等，可以使用定时过期策略，通过设置验证码的过期时间，在一定时间后自动删除该验证码，避免占用Redis的存储空间。")])])]),s._v(" "),v("li",[v("p",[v("strong",[s._v("惰性过期")]),s._v("：当获取某个key的值时，Redis会检查该key是否过期，如果已经过期，Redis会自动删除该key。这种过期策略适用于数据变化不频繁的场景，可以减少Redis的运行开销。")]),s._v(" "),v("p",[v("strong",[s._v("优点")]),s._v("：对CPU友好，我们只会在使用该键时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查。")]),s._v(" "),v("p",[v("strong",[s._v("缺点")]),s._v("：对内存不友好，如果一个键已经过期，但是一直没有使用，那么该键就会一直存在内存中，如果数据库中有很多这种使用不到的过期键，这些键便永远不会被删除，内存永远不会释放。")]),s._v(" "),v("blockquote",[v("p",[s._v("对于游客登录的临时信息，由于其数据变化不频繁且过期时间相对较长，例如1小时或1天等，可以使用惰性过期策略，通过在访问时检查key的过期时间是否已到达，如果已过期则删除key。这样可以减少Redis的运行开销，并且不会影响数据的实时性。当然，如果希望在某些情况下能够及时删除过期数据，也可以采用惰性+定期过期策略，定期检查过期数据并进行清理。")])])]),s._v(" "),v("li",[v("p",[v("strong",[s._v("定期过期")]),s._v("：每隔一段时间，扫描Redis中过期key，并清除部分过期的key。该策略是前两者的一个折中方案，还可以通过调整定时扫描的时间间隔和每次扫描的限定耗时，在不同情况下使得CPU和内存资源达到最优的平衡效果。")]),s._v(" "),v("p",[v("strong",[s._v("在Redis中，同时使用了定期删除和惰性删除。")])]),s._v(" "),v("p",[s._v("这种过期策略适用于需要及时清理过期数据的场景，但会对Redis的性能造成一定的影响。")]),s._v(" "),v("p",[v("strong",[s._v("优点")]),s._v('：通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用–处理"定时删除"的缺点，定期删除过期key–处理"惰性删除"的缺点。')]),s._v(" "),v("p",[v("strong",[s._v("缺点")]),s._v('：在内存友好方面，不如"定时删除"，在CPU时间友好方面，不如"惰性删除"。')])]),s._v(" "),v("li",[v("p",[v("strong",[s._v("惰性+定期过期")]),s._v("：==Redis同时支持惰性和定期过期策略，即在每次获取key的值时，Redis会检查该key是否过期，如果已经过期，Redis会自动删除该key；同时Redis也会定期检查所有的key是否过期，并清理已经过期的数据。这种过期策略可以在保证数据实时性的同时，减少Redis的运行开销==。")]),s._v(" "),v("p",[s._v("如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 Redis 内存块耗尽了，咋整？\n答案是：内存淘汰机制。")])])]),s._v(" "),v("h2",{attrs:{id:"十五、redis的数据淘汰策略有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#十五、redis的数据淘汰策略有哪些"}},[s._v("#")]),s._v(" 十五、Redis的数据淘汰策略有哪些 ?")]),s._v(" "),v("p",[s._v("数据的淘汰策略：==当Redis中的内存不够用时，此时再向Redis中添加新的key，那么Redis就会按照某一种规则将内存中的数据删除掉，这种数据的删除规则被称之为内存的淘汰策略==。")]),s._v(" "),v("div",{staticClass:"language-shell line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-shell"}},[v("code",[s._v("noeviction\t\t\t\t\t\t\t"),v("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 不删除任何数据，内存不足直接报错(默认策略)")]),s._v("\nvolatile-lru\t\t\t\t\t\t"),v("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 挑选最近最久使用的数据淘汰(举例：key1是在3s之前访问的, key2是在9s之前访问的，删除的就是key2)")]),s._v("\nvolatile-lfu\t\t\t\t\t\t"),v("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 挑选最近最少使用数据淘汰  (举例：key1最近5s访问了4次, key2最近5s访问了9次， 删除的就是key1)")]),s._v("\nvolatile-ttl\t\t\t\t\t\t"),v("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 挑选将要过期的数据淘汰")]),s._v("\nvolatile-random\t\t\t\t\t\t"),v("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 任意选择数据淘汰")]),s._v("\nallkeys-lru\t\t\t\t\t\t\t"),v("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 挑选最近最少使用的数据淘汰")]),s._v("\nallkeys-lfu\t\t\t\t\t\t\t"),v("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 挑选最近使用次数最少的数据淘汰")]),s._v("\nallkeys-random\t\t\t\t\t\t"),v("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 任意选择数据淘汰，相当于随机")]),s._v("\n")])]),s._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[s._v("1")]),v("br"),v("span",{staticClass:"line-number"},[s._v("2")]),v("br"),v("span",{staticClass:"line-number"},[s._v("3")]),v("br"),v("span",{staticClass:"line-number"},[s._v("4")]),v("br"),v("span",{staticClass:"line-number"},[s._v("5")]),v("br"),v("span",{staticClass:"line-number"},[s._v("6")]),v("br"),v("span",{staticClass:"line-number"},[s._v("7")]),v("br"),v("span",{staticClass:"line-number"},[s._v("8")]),v("br")])]),v("blockquote",[v("ul",[v("li",[v("strong",[s._v("LRU")]),s._v("（"),v("strong",[s._v("L")]),s._v("east "),v("strong",[s._v("R")]),s._v("ecently "),v("strong",[s._v("U")]),s._v("sed）最少最近使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。")]),s._v(" "),v("li",[v("strong",[s._v("LFU")]),s._v("（"),v("strong",[s._v("L")]),s._v("east "),v("strong",[s._v("F")]),s._v("requently "),v("strong",[s._v("U")]),s._v("sed）最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。")]),s._v(" "),v("li",[v("strong",[s._v("volatile")]),s._v("：表示设置了带过期时间的key")]),s._v(" "),v("li",[v("strong",[s._v("allkeys")]),s._v("：表示所有的key")])])]),s._v(" "),v("h4",{attrs:{id:"使用建议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用建议"}},[s._v("#")]),s._v(" 使用建议：")]),s._v(" "),v("ol",[v("li",[s._v("如果业务==有明显的冷热数据区分==，优先使用 "),v("code",[s._v("allkeys-lru")]),s._v(" 策略。充分利用 "),v("code",[s._v("LRU")]),s._v("算法的优势，把最近最常访问的数据留在缓存中。")]),s._v(" "),v("li",[s._v("如果业务中数据访问频率差别不大，没有明显冷热数据区分，建议使用 "),v("code",[s._v("allkeys-random")]),s._v("，随机选择淘汰。")]),s._v(" "),v("li",[s._v("如果业务中有==置顶的需求==，可以使用 "),v("code",[s._v("volatile-lru")]),s._v(" 策略，同时置顶数据不设置过期时间，这些数据就一直不被删除，会淘汰其他设置过期时间的数据。")]),s._v(" "),v("li",[s._v("如果业务中有==短时高频访问==的数据，可以使用 "),v("code",[s._v("allkeys-lfu")]),s._v(" 或 "),v("code",[s._v("volatile-lfu")]),s._v(" 策略。")])])])}),[],!1,null,null,null);v.default=_.exports}}]);