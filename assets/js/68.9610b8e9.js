(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{350:function(_,v,t){"use strict";t.r(v);var a=t(14),s=Object(a.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"mq相关面试题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mq相关面试题"}},[_._v("#")]),_._v(" MQ相关面试题")]),_._v(" "),v("h2",{attrs:{id:"_1-rabbitmq"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-rabbitmq"}},[_._v("#")]),_._v(" 1 RabbitMQ")]),_._v(" "),v("h3",{attrs:{id:"_1-1-你们项目中哪里用到了rabbitmq"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-你们项目中哪里用到了rabbitmq"}},[_._v("#")]),_._v(" 1.1 你们项目中哪里用到了RabbitMQ ?")]),_._v(" "),v("blockquote",[v("p",[_._v("难易程度：☆☆☆")]),_._v(" "),v("p",[_._v("出现频率：☆☆☆☆")])]),_._v(" "),v("p",[_._v("我们项目中很多地方都使用了RabbitMQ , RabbitMQ 是我们项目中服务通信的主要方式之一 , 我们项目中服务通信主要有二种方式实现 :")]),_._v(" "),v("ol",[v("li",[_._v("通过Feign实现服务调用")]),_._v(" "),v("li",[_._v("通过MQ实现服务通信")])]),_._v(" "),v("p",[_._v("基本上除了查询请求之外, 大部分的服务调用都采用的是MQ实现的异步调用 , 例如 :")]),_._v(" "),v("ol",[v("li",[_._v("发布内容的异步审核")]),_._v(" "),v("li",[_._v("验证码的异步发送")]),_._v(" "),v("li",[_._v("用户行为数据的异步采集入库")]),_._v(" "),v("li",[_._v("搜索历史记录的异步保存")]),_._v(" "),v("li",[_._v("用户信息修改的异步通知(用户修改信息之后, 同步修改其他服务中冗余/缓存的用户信息)")]),_._v(" "),v("li",[_._v("静态化页面的生成")]),_._v(" "),v("li",[_._v("MYSQL和Redis , ES之间的数据同步")]),_._v(" "),v("li",[_._v("....")])]),_._v(" "),v("h3",{attrs:{id:"_1-2-为什么会选择使用rabbitmq-有什么好处"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-为什么会选择使用rabbitmq-有什么好处"}},[_._v("#")]),_._v(" 1.2 为什么会选择使用RabbitMQ ? 有什么好处 ?")]),_._v(" "),v("blockquote",[v("p",[_._v("难易程度：☆☆")]),_._v(" "),v("p",[_._v("出现频率：☆☆☆")])]),_._v(" "),v("p",[_._v("选择使用RabbitMQ是因为RabbitMQ的功能比较丰富 , 支持各种消息收发模式(简单队列模式, 工作队列模式 , 路由模式 , 直接模式 , 主题模式等) , 支持延迟队列  , 惰性队列而且天然支持集群, 保证服务的高可用, 同时性能非常不错 , 社区也比较活跃, 文档资料非常丰富")]),_._v(" "),v("p",[v("strong",[_._v("使用MQ有很多好处：")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("吞吐量提升：无需等待订阅者处理完成，响应更快速")])]),_._v(" "),v("li",[v("p",[_._v("故障隔离：服务没有直接调用，不存在级联失败问题")])]),_._v(" "),v("li",[v("p",[_._v("调用间没有阻塞，不会造成无效的资源占用")])]),_._v(" "),v("li",[v("p",[_._v("耦合度极低，每个服务都可以灵活插拔，可替换")])]),_._v(" "),v("li",[v("p",[_._v("流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件")])])]),_._v(" "),v("p",[v("strong",[_._v("使用MQ也有很多缺点：")])]),_._v(" "),v("ul",[v("li",[_._v("架构复杂了，业务没有明显的流程线，不好管理")]),_._v(" "),v("li",[_._v("需要依赖于Broker的可靠、安全、性能")])]),_._v(" "),v("h3",{attrs:{id:"_1-3-使用rabbitmq如何保证消息不丢失"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-使用rabbitmq如何保证消息不丢失"}},[_._v("#")]),_._v(" 1.3 使用RabbitMQ如何保证消息不丢失 ?")]),_._v(" "),v("blockquote",[v("p",[_._v("难易程度：☆☆☆")]),_._v(" "),v("p",[_._v("出现频率：☆☆☆☆☆")])]),_._v(" "),v("p",[_._v("消息从发送，到消费者接收，会经历多个过程 , 其中的每一步都可能导致消息丢失")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220828220047206.png",alt:"image-20220828220047206"}})]),_._v(" "),v("p",[v("strong",[_._v("针对这些问题，RabbitMQ分别给出了解决方案：")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("消息发送到交换机丢失 : "),v("strong",[_._v("发布者确认机制"),v("code",[_._v("publisher-confirm")])])]),_._v(" "),v("blockquote",[v("p",[_._v("消息发送到交换机失败会向生产者返回ACK , 生产者通过回调接收发送结果 , 如果发送失败, 重新发送, 或者记录日志人工介入")])])]),_._v(" "),v("li",[v("p",[_._v("消息从交换机路由到队列丢失 : "),v("strong",[_._v("发布者回执机制"),v("code",[_._v("publisher-return")])])]),_._v(" "),v("blockquote",[v("p",[_._v("消息从交换机路由到队列失败会向生产者返回失败原因 , 生产者通过回调接收回调结果 , 如果发送失败, 重新发送, 或者记录日志人工介入")])])]),_._v(" "),v("li",[v("p",[_._v("消息保存到队列中丢失 : MQ持久化(交换机持久化, 队列持久化 , 消息持久化)")])]),_._v(" "),v("li",[v("p",[_._v("消费者消费消息丢失 : 消费者确认机制 , 消费者失败重试机制")])])]),_._v(" "),v("p",[_._v("通过RabbitMQ本身所提供的机制基本上已经可以保证消息不丢失  , 但是因为一些特殊的原因还是会发送消息丢失问题 , 例如 : 回调丢失 , 系统宕机, 磁盘损坏等 , 这种概率很小 , 但是如果想规避这些问题 , 进一步提高消息发送的成功率, 也可以通过程序自己进行控制")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220828234538133.png",alt:"image-20220828234538133"}})]),_._v(" "),v("p",[_._v("设计一个消息状态表 , 主要包含 : 消息id , 消息内容 , 交换机 , 消息路由key , 发送时间, 签收状态等字段 , 发送方业务执行完毕之后 , 向消息状态表保存一条消息记录, 消息状态为未签收 , 之后再向MQ发送消息 , 消费方接收消息消费完毕之后 , 向发送方发送一条签收消息 , 发送方接收到签收消息之后 , 修改消息状态表中的消息状态为已签收 ! 之后通过定时任务扫描消息状态表中这些未签收的消息 , 重新发送消息, 直到成功为止 , 对于已经完成消费的消息定时清理即可 !")]),_._v(" "),v("h3",{attrs:{id:"_1-4-消息的重复消费问题如何解决的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-消息的重复消费问题如何解决的"}},[_._v("#")]),_._v(" 1.4 消息的重复消费问题如何解决的 ?")]),_._v(" "),v("blockquote",[v("p",[_._v("难易程度：☆☆☆")]),_._v(" "),v("p",[_._v("出现频率：☆☆☆☆☆")])]),_._v(" "),v("p",[_._v("在使用RabbitMQ进行消息收发的时候, 如果发送失败或者消费失败会自动进行"),v("strong",[_._v("重试")]),_._v(", 那么就有可能会导致消息的重复消费")]),_._v(" "),v("p",[_._v("解决方案：")]),_._v(" "),v("ul",[v("li",[_._v("每条消息设置一个唯一的标识id")]),_._v(" "),v("li",[_._v("幂等方案\n"),v("ul",[v("li",[_._v("token+redis")]),_._v(" "),v("li",[_._v("分布式锁")]),_._v(" "),v("li",[_._v("数据库锁（悲观锁、乐观锁）")])])])]),_._v(" "),v("h3",{attrs:{id:"_1-5-如果有100万消息堆积在mq-如何解决"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-如果有100万消息堆积在mq-如何解决"}},[_._v("#")]),_._v(" 1.5 如果有100万消息堆积在MQ , 如何解决 ?")]),_._v(" "),v("blockquote",[v("p",[_._v("难易程度：☆☆☆")]),_._v(" "),v("p",[_._v("出现频率：☆☆☆☆☆")])]),_._v(" "),v("p",[_._v("解决消息堆积有三种思路：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("提高消费者的消费能力")]),_._v(" "),v("blockquote",[v("p",[_._v("使用多线程消费")])])]),_._v(" "),v("li",[v("p",[_._v("增加更多消费者，提高消费速度")]),_._v(" "),v("blockquote",[v("p",[_._v("使用工作队列模式, 设置多个消费者消费消费同一个队列中的消息")])])]),_._v(" "),v("li",[v("p",[_._v("扩大队列容积，提高堆积上限")]),_._v(" "),v("blockquote",[v("p",[_._v("使用RabbitMQ惰性队列")]),_._v(" "),v("p",[_._v("惰性队列：")]),_._v(" "),v("ul",[v("li",[_._v("接收到消息后直接存入磁盘而非内存")]),_._v(" "),v("li",[_._v("消费者要消费消息时才会从磁盘中读取并加载到内存")]),_._v(" "),v("li",[_._v("支持数百万条的消息存储")])])])])]),_._v(" "),v("h3",{attrs:{id:"_1-6-rabbitmq如何保证消费的顺序性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-rabbitmq如何保证消费的顺序性"}},[_._v("#")]),_._v(" 1.6 RabbitMQ如何保证消费的顺序性 ?")]),_._v(" "),v("blockquote",[v("p",[_._v("难易程度：☆☆")]),_._v(" "),v("p",[_._v("出现频率：☆☆☆")])]),_._v(" "),v("p",[_._v("一个队列只设置一个消费者消费即可 , 多个消费者之间是无法保证消息消费顺序性的")]),_._v(" "),v("h3",{attrs:{id:"_1-7-rabbitmq的延迟队列有了解过嘛"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-rabbitmq的延迟队列有了解过嘛"}},[_._v("#")]),_._v(" 1.7 RabbitMQ的延迟队列有了解过嘛 ?")]),_._v(" "),v("blockquote",[v("p",[_._v("难易程度：☆☆☆")]),_._v(" "),v("p",[_._v("出现频率：☆☆☆☆")])]),_._v(" "),v("p",[_._v("RabbitMQ的延迟队列有二种实现方案 :")]),_._v(" "),v("ol",[v("li",[_._v("使用消息过期TTL + 死信交换机")]),_._v(" "),v("li",[_._v("使用延迟交换机插件")])]),_._v(" "),v("h3",{attrs:{id:"_1-8-rabbitmq如何设置消息过期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-8-rabbitmq如何设置消息过期"}},[_._v("#")]),_._v(" 1.8 RabbitMQ如何设置消息过期 ?")]),_._v(" "),v("blockquote",[v("p",[_._v("难易程度：☆☆☆")]),_._v(" "),v("p",[_._v("出现频率：☆☆☆")])]),_._v(" "),v("p",[_._v("RabbitMQ置消息过期的方式有二种 :")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("为队列设置过期时间, 所有进到这个队列的消息就会具有统一的过期时间")]),_._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[_._v("@Bean")]),_._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("public")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[_._v("Queue")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("ttlQueue")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("{")]),_._v("\n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("return")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[_._v("QueueBuilder")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("durable")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),v("span",{pre:!0,attrs:{class:"token string"}},[_._v('"ttl.queue"')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token comment"}},[_._v("// 指定队列名称，并持久化")]),_._v("\n        "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("ttl")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("10000")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token comment"}},[_._v("// 设置队列的超时时间，10秒")]),_._v("\n        "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("deadLetterExchange")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),v("span",{pre:!0,attrs:{class:"token string"}},[_._v('"dl.ttl.direct"')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token comment"}},[_._v("// 指定死信交换机")]),_._v("\n        "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("build")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("}")]),_._v("\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br"),v("span",{staticClass:"line-number"},[_._v("2")]),v("br"),v("span",{staticClass:"line-number"},[_._v("3")]),v("br"),v("span",{staticClass:"line-number"},[_._v("4")]),v("br"),v("span",{staticClass:"line-number"},[_._v("5")]),v("br"),v("span",{staticClass:"line-number"},[_._v("6")]),v("br"),v("span",{staticClass:"line-number"},[_._v("7")]),v("br")])])]),_._v(" "),v("li",[v("p",[_._v("为消息单独设置过期时间")]),_._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[_._v("@Test")]),_._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("public")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("void")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("testTTLQueue")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("{")]),_._v("\n    "),v("span",{pre:!0,attrs:{class:"token comment"}},[_._v("// 创建消息")]),_._v("\n    "),v("span",{pre:!0,attrs:{class:"token class-name"}},[_._v("String")]),_._v(" message "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[_._v('"hello, ttl queue"')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n    "),v("span",{pre:!0,attrs:{class:"token comment"}},[_._v("// 消息ID，需要封装到CorrelationData中")]),_._v("\n    "),v("span",{pre:!0,attrs:{class:"token class-name"}},[_._v("CorrelationData")]),_._v(" correlationData "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("new")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[_._v("CorrelationData")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),v("span",{pre:!0,attrs:{class:"token constant"}},[_._v("UUID")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("randomUUID")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("toString")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n    "),v("span",{pre:!0,attrs:{class:"token comment"}},[_._v("// 发送消息")]),_._v("\n    rabbitTemplate"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("convertAndSend")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),v("span",{pre:!0,attrs:{class:"token string"}},[_._v('"ttl.direct"')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[_._v('"ttl"')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" message"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" correlationData"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n    "),v("span",{pre:!0,attrs:{class:"token comment"}},[_._v("// 记录日志")]),_._v("\n    log"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("debug")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),v("span",{pre:!0,attrs:{class:"token string"}},[_._v('"发送消息成功"')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("}")]),_._v("\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br"),v("span",{staticClass:"line-number"},[_._v("2")]),v("br"),v("span",{staticClass:"line-number"},[_._v("3")]),v("br"),v("span",{staticClass:"line-number"},[_._v("4")]),v("br"),v("span",{staticClass:"line-number"},[_._v("5")]),v("br"),v("span",{staticClass:"line-number"},[_._v("6")]),v("br"),v("span",{staticClass:"line-number"},[_._v("7")]),v("br"),v("span",{staticClass:"line-number"},[_._v("8")]),v("br"),v("span",{staticClass:"line-number"},[_._v("9")]),v("br"),v("span",{staticClass:"line-number"},[_._v("10")]),v("br"),v("span",{staticClass:"line-number"},[_._v("11")]),v("br")])])])]),_._v(" "),v("p",[v("strong",[_._v("注意 :")])]),_._v(" "),v("ol",[v("li",[_._v("队列过期和消息过期同时存在 , 会以时间短的时间为准")]),_._v(" "),v("li",[_._v("RabbitMQ队列消息过期的机制是判断队列头部元素是否过期 , 如果队里头部消息没有到过期时间 , 中间消息到了过期时间, 这个消息也不会被自动剔除")])]),_._v(" "),v("h3",{attrs:{id:"_1-9-什么情况下消息会成为死信"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-9-什么情况下消息会成为死信"}},[_._v("#")]),_._v(" 1.9 什么情况下消息会成为死信 ?")]),_._v(" "),v("blockquote",[v("p",[_._v("难易程度：☆☆☆")]),_._v(" "),v("p",[_._v("出现频率：☆☆☆")])]),_._v(" "),v("p",[_._v("当一个队列中的消息满足下列情况之一时，就会成为死信（dead letter）：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("消费者使用basic.reject或 basic.nack声明消费失败，并且消息的requeue参数设置为false")])]),_._v(" "),v("li",[v("p",[_._v("消息是一个过期消息，超时无人消费")])]),_._v(" "),v("li",[v("p",[_._v("要投递的队列消息满了，无法投递")])])]),_._v(" "),v("h3",{attrs:{id:"_1-10-什么是死信交换机-如何为队列绑定死信交换机"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-10-什么是死信交换机-如何为队列绑定死信交换机"}},[_._v("#")]),_._v(" 1.10 什么是死信交换机 ? 如何为队列绑定死信交换机 ?")]),_._v(" "),v("blockquote",[v("p",[_._v("难易程度：☆☆☆")]),_._v(" "),v("p",[_._v("出现频率：☆☆☆")])]),_._v(" "),v("p",[_._v("死 信交换机和正常的交换机没有什么不同 , 如果一个包含死信的队列配置了"),v("code",[_._v("dead-letter-exchange")]),_._v("属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为"),v("strong",[_._v("死信交换机")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220828215958105.png",alt:"image-20220828215958105"}})]),_._v(" "),v("p",[_._v("为队列绑定死信交换机 , 只需要设置队列属性 "),v("code",[_._v("dead-letter-exchange")]),_._v("即可")]),_._v(" "),v("h3",{attrs:{id:"_1-11-rabbitmq的高可用机制有了解过嘛"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-11-rabbitmq的高可用机制有了解过嘛"}},[_._v("#")]),_._v(" 1.11 RabbitMQ的高可用机制有了解过嘛 ?")]),_._v(" "),v("blockquote",[v("p",[_._v("难易程度：☆☆☆☆")]),_._v(" "),v("p",[_._v("出现频率：☆☆☆")])]),_._v(" "),v("p",[_._v("RabbitMQ的是基于Erlang语言编写，而Erlang又是一个面向并发的语言，天然支持集群模式。RabbitMQ的集群有两种模式：")]),_._v(" "),v("p",[_._v("•"),v("strong",[_._v("普通集群")]),_._v("：是一种分布式集群，将队列分散到集群的各个节点，从而提高整个集群的并发能力。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220828215537037.png",alt:"image-20220828215537037"}})]),_._v(" "),v("blockquote",[v("ul",[v("li",[_._v("会在集群的各个节点间共享部分数据，包括：交换机、队列元信息。不包含队列中的消息。")]),_._v(" "),v("li",[_._v("当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回")]),_._v(" "),v("li",[_._v("队列所在节点宕机，队列中的消息就会丢失")])])]),_._v(" "),v("p",[_._v("•"),v("strong",[_._v("镜像集群")]),_._v("：是一种主从集群，普通集群的基础上，添加了主从备份功能，提高集群的数据可用性。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220828215621852.png",alt:"image-20220828215621852"}})]),_._v(" "),v("blockquote",[v("p",[_._v("•交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份。")]),_._v(" "),v("p",[_._v("•创建队列的节点被称为该队列的"),v("strong",[_._v("主节点，"),v("strong",[_._v("备份到的其它节点叫做该队列的")]),_._v("镜像")]),_._v("节点。")]),_._v(" "),v("p",[_._v("•一个队列的主节点可能是另一个队列的镜像节点")]),_._v(" "),v("p",[_._v("•所有操作都是主节点完成，然后同步给镜像节点")]),_._v(" "),v("p",[_._v("•主宕机后，镜像节点会替代成新的主")])]),_._v(" "),v("h2",{attrs:{id:"_2-kafka"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-kafka"}},[_._v("#")]),_._v(" 2 Kafka")]),_._v(" "),v("h3",{attrs:{id:"_2-1-你们项目中哪里用到了kafka"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-你们项目中哪里用到了kafka"}},[_._v("#")]),_._v(" 2.1 你们项目中哪里用到了Kafka?")]),_._v(" "),v("blockquote",[v("p",[_._v("难易程度：☆☆☆")]),_._v(" "),v("p",[_._v("出现频率：☆☆☆☆")])]),_._v(" "),v("p",[_._v("我们项目中很多地方都使用了Kafka, Kafka是我们项目中服务通信的主要方式之一 , 我们项目中服务通信主要有二种方式实现 :")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("通过Feign实现服务调用")])]),_._v(" "),v("li",[v("p",[_._v("通过Kafka实现服务通信")])])]),_._v(" "),v("p",[_._v("基本上除了查询请求之外, 大部分的服务调用都采用的是Kafka实现的异步调用 , 例如 :")]),_._v(" "),v("ol",[v("li",[_._v("发布内容的异步审核")]),_._v(" "),v("li",[_._v("验证码的异步发送")]),_._v(" "),v("li",[_._v("用户行为数据的异步采集入库")]),_._v(" "),v("li",[_._v("搜索历史记录的异步保存")]),_._v(" "),v("li",[_._v("用户信息修改的异步通知(用户修改信息之后, 同步修改其他服务中冗余/缓存的用户信息)")]),_._v(" "),v("li",[_._v("静态化页面的生成")]),_._v(" "),v("li",[_._v("MYSQL和Redis , ES之间的数据同步")]),_._v(" "),v("li",[_._v("推荐数据实时计算")]),_._v(" "),v("li",[_._v(".....")])]),_._v(" "),v("h3",{attrs:{id:"_2-2-为什么会选择使用kafka-有什么好处"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-为什么会选择使用kafka-有什么好处"}},[_._v("#")]),_._v(" 2.2 为什么会选择使用Kafka? 有什么好处 ?")]),_._v(" "),v("blockquote",[v("p",[_._v("难易程度：☆☆☆")]),_._v(" "),v("p",[_._v("出现频率：☆☆☆")])]),_._v(" "),v("p",[_._v("选择使用Kafka是因为Kafka作为中间件他的吞吐量比较高 , 我们的系统中主要使用Kafka来处理一些用户的行为数据 , 用户行为数据用户操作成本低 , 数据量比较大 , 需要有更高的吞吐量支持 , 并且我们在项目中需要实现根据用户行为的实时推荐 , 运营端后台管理系统首页看板数据的实体展示 !")]),_._v(" "),v("p",[v("strong",[_._v("使用Kafka有很多好处：")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("吞吐量提升：无需等待订阅者处理完成，响应更快速")])]),_._v(" "),v("li",[v("p",[_._v("故障隔离：服务没有直接调用，不存在级联失败问题")])]),_._v(" "),v("li",[v("p",[_._v("调用间没有阻塞，不会造成无效的资源占用")])]),_._v(" "),v("li",[v("p",[_._v("耦合度极低，每个服务都可以灵活插拔，可替换")])]),_._v(" "),v("li",[v("p",[_._v("流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件")])])]),_._v(" "),v("p",[v("strong",[_._v("使用Kafka也有很多缺点：")])]),_._v(" "),v("ul",[v("li",[_._v("架构复杂了，业务没有明显的流程线，不好管理")]),_._v(" "),v("li",[_._v("需要依赖于Broker的可靠、安全、性能")])]),_._v(" "),v("h3",{attrs:{id:"_2-3-使用kafka如何保证消息不丢失"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-使用kafka如何保证消息不丢失"}},[_._v("#")]),_._v(" 2.3 使用Kafka如何保证消息不丢失 ?")]),_._v(" "),v("blockquote",[v("p",[_._v("难易程度：☆☆☆☆")]),_._v(" "),v("p",[_._v("出现频率：☆☆☆☆")])]),_._v(" "),v("p",[_._v("使用Kafka在消息的收发过程都会出现消息丢失  , Kafka分别给出了解决方案")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("生产者发送消息到Brocker丢失")]),_._v(" "),v("blockquote",[v("p",[_._v("设置同步发送和异步发送")]),_._v(" "),v("ul",[v("li",[_._v("同步发送可以通过get()获取到消息的发送结果 , 阻塞方案, 效率比较低")]),_._v(" "),v("li",[_._v("异步发送可以通过回调获取到消息的发送接口 , 非阻塞方案, 效率较高 , 可能会出现回调丢失")]),_._v(" "),v("li",[_._v("设置消息发送失败的重试次数, 设置为一个很大的值, 发送失败不断重试")])])])]),_._v(" "),v("li",[v("p",[_._v("消息在Brocker中存储丢失")]),_._v(" "),v("blockquote",[v("p",[_._v("Kafka提供了分区的备份机制 , 可以为每个分区设置多个副本 , 主分区服务器宕机, 副本分区还有完整数据")]),_._v(" "),v("p",[_._v("主分区数据同步到副本分区之前, 主分区宕机也有可能会出现消息丢失问题 , 解决方案就是设置消息确认的ACKS")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[v("strong",[_._v("确认机制")])]),_._v(" "),v("th",[v("strong",[_._v("说明")])])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("acks=0")]),_._v(" "),v("td",[_._v("生产者在成功写入消息之前不会等待任何来自服务器的响应,消息有丢失的风险，但是速度最快")])]),_._v(" "),v("tr",[v("td",[_._v("acks=1（默认值）")]),_._v(" "),v("td",[_._v("只要集群首领节点收到消息，生产者就会收到一个来自服务器的成功响应")])]),_._v(" "),v("tr",[v("td",[_._v("acks=all")]),_._v(" "),v("td",[_._v("只有当所有参与赋值的节点全部收到消息时，生产者才会收到一个来自服务器的成功响应")])])])])])]),_._v(" "),v("li",[v("p",[_._v("消费者从Brocker接收消息丢失")]),_._v(" "),v("blockquote",[v("p",[_._v("消费者是通过offset来定位消费数据的 , 当消费者出现故障之后会触发重平衡, 会为消费者组中的消费者重新分配消费分区, 正常情况下是没有问题的 , 这也是Kafka提供的消费保障机制")]),_._v(" "),v("p",[_._v("但是在重平衡的过程中 , 因为Kafka默认子每隔5S自动提交偏移量 , 那么就有可能会出现消息丢失和重复消费问题")]),_._v(" "),v("ul",[v("li",[_._v("如果提交偏移量小于客户端处理的最后一个消息的偏移量，那么处于两个偏移量之间的消息就会被重复处理。")]),_._v(" "),v("li",[_._v("如果提交的偏移量大于客户端的最后一个消息的偏移量，那么处于两个偏移量之间的消息将会丢失。")])]),_._v(" "),v("p",[_._v("解决方案有二种 :")]),_._v(" "),v("ol",[v("li",[_._v("设置更小的自动提交偏移量的周期 , 周期越小出现问题的概率也就越小, 对消费者性能和服务器压力的影响就越大(缓解方案,不能从根本上解决问题)")]),_._v(" "),v("li",[_._v("消费完毕手动提交偏移量\n"),v("ol",[v("li",[_._v("同步提交  : 会阻塞, 效率低 , 但是会重试 , 直到成功为止")]),_._v(" "),v("li",[_._v("异步提交 : 不会阻塞 , 效率高 , 但是不会重试 , 可能会出现提交失败问题")]),_._v(" "),v("li",[_._v("同步异步结合")])])])])])])]),_._v(" "),v("p",[_._v("通过Kafka本身所提供的机制基本上已经可以保证消息不丢失  , 但是因为一些特殊的原因还是会发送消息丢失问题 , 例如 : 回调丢失 , 系统宕机, 磁盘损坏等 , 这种概率很小 , 但是如果想规避这些问题 , 进一步提高消息发送的成功率, 也可以通过程序自己进行控制")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220828234551427.png",alt:"image-20220828234551427"}})]),_._v(" "),v("p",[_._v("设计一个消息状态表 , 主要包含 : 消息id , 消息内容 , 交换机 , 消息路由key , 发送时间, 签收状态等字段 , 发送方业务执行完毕之后 , 向消息状态表保存一条消息记录, 消息状态为未签收 , 之后再向Kafka发送消息 , 消费方接收消息消费完毕之后 , 向发送方发送一条签收消息 , 发送方接收到签收消息之后 , 修改消息状态表中的消息状态为已签收 ! 之后通过定时任务扫描消息状态表中这些未签收的消息 , 重新发送消息, 直到成功为止 , 对于已经完成消费的消息定时清理即可 !")]),_._v(" "),v("h3",{attrs:{id:"_2-4-消息的重复消费问题如何解决的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-消息的重复消费问题如何解决的"}},[_._v("#")]),_._v(" 2.4 消息的重复消费问题如何解决的 ?")]),_._v(" "),v("blockquote",[v("p",[_._v("难易程度：☆☆☆")]),_._v(" "),v("p",[_._v("出现频率：☆☆☆☆")])]),_._v(" "),v("p",[_._v("消费者是通过offset来定位消费数据的 , 当消费者出现故障之后会触发重平衡, 会为消费者组中的消费者重新分配消费分区, 正常情况下是没有问题的 , 这也是Kafka提供的消费保障机制")]),_._v(" "),v("p",[_._v("但是在重平衡的过程中 , 因为Kafka默认子每隔5S自动提交偏移量 , 那么就有可能会出现消息丢失和重复消费问题")]),_._v(" "),v("p",[_._v("如果提交偏移量小于客户端处理的最后一个消息的偏移量，那么处于两个偏移量之间的消息就会被重复处理。")]),_._v(" "),v("blockquote",[v("p",[_._v("解决方案有二种 :")]),_._v(" "),v("ol",[v("li",[_._v("设置更小的自动提交偏移量的周期 , 周期越小出现问题的概率也就越小, 对消费者性能和服务器压力的影响就越大(缓解方案,不能从根本上解决问题)")]),_._v(" "),v("li",[_._v("消费完毕手动提交偏移量\n"),v("ol",[v("li",[_._v("同步提交  : 会阻塞, 效率低 , 但是会重试 , 直到成功为止")]),_._v(" "),v("li",[_._v("异步提交 : 不会阻塞 , 效率高 , 但是不会重试 , 可能会出现提交失败问题")]),_._v(" "),v("li",[_._v("同步异步结合")])])])])]),_._v(" "),v("p",[_._v("基于上面的操作如果因为网络原因, 服务器原因出现偏移量提交失败的情况 , 还是会出现重复消费 , 具体的解决方案如下：")]),_._v(" "),v("ul",[v("li",[_._v("每条消息设置一个唯一的标识id")]),_._v(" "),v("li",[_._v("幂等方案\n"),v("ul",[v("li",[_._v("token+redis")]),_._v(" "),v("li",[_._v("分布式锁")]),_._v(" "),v("li",[_._v("数据库锁（悲观锁、乐观锁）")])])])]),_._v(" "),v("h3",{attrs:{id:"_2-5-kafka如何保证消费的顺序性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-kafka如何保证消费的顺序性"}},[_._v("#")]),_._v(" 2.5 Kafka如何保证消费的顺序性 ?")]),_._v(" "),v("blockquote",[v("p",[_._v("难易程度：☆☆☆")]),_._v(" "),v("p",[_._v("出现频率：☆☆☆")])]),_._v(" "),v("p",[_._v("topic分区中消息只能由消费者组中的唯一一个消费者处理，所以消息肯定是按照先后顺序进行处理的。")]),_._v(" "),v("p",[_._v("但是它也仅仅是保证Topic的一个分区顺序处理，不能保证跨分区的消息先后处理顺序。")]),_._v(" "),v("p",[_._v("所以，如果你想要顺序的处理Topic的所有消息，那就只提供一个分区。")]),_._v(" "),v("p",[_._v("设置分区有两种方式：")]),_._v(" "),v("p",[_._v("第一是：在发送消息的时候可以指定分区")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220911113636055.png",alt:"image-20220911113636055"}})]),_._v(" "),v("p",[_._v("第二是：在发送消息的时候可以指定消息的key，同一个业务指定相同的key，因为分区也是通过key进行hash运算后计算的分区，如果是相同的key，那肯定是在同一个分区下")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220911113717829.png",alt:"image-20220911113717829"}})]),_._v(" "),v("h3",{attrs:{id:"_2-6-kafka的高可用机制有了解过嘛"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-kafka的高可用机制有了解过嘛"}},[_._v("#")]),_._v(" 2.6 Kafka的高可用机制有了解过嘛 ?")]),_._v(" "),v("blockquote",[v("p",[_._v("难易程度：☆☆☆")]),_._v(" "),v("p",[_._v("出现频率：☆☆☆")])]),_._v(" "),v("p",[_._v("Kafka作为一款使用比较广泛的消息中间件产品, 本身也提供了一些机制去实现高可用 , 主要包括 :")]),_._v(" "),v("ol",[v("li",[_._v("Kafka 集群  : 通过集群模式, 保证Brocker的高可用")]),_._v(" "),v("li",[_._v("分区备份机制  : Kafka会为每一个分区设置副本 , 可以手动指定副本数量 , 这些副本会分配到Kafka的不同的Brocker上存储 , 这样可以保证Kafka数据高可用")]),_._v(" "),v("li",[_._v("重平衡 : 当消费者组中重新加入消费者 , 或者消费者组中有消费者宕机 , 这个时候Kafka会为消费者组中的消费者从新分配消费分区的过程就是再均衡 , 通过重平衡消实现了消费者的高可用")])]),_._v(" "),v("h3",{attrs:{id:"_2-7-kafka实现高性能的设计有了解过嘛"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-7-kafka实现高性能的设计有了解过嘛"}},[_._v("#")]),_._v(" 2.7 Kafka实现高性能的设计有了解过嘛 ?")]),_._v(" "),v("blockquote",[v("p",[_._v("难易程度：☆☆☆")]),_._v(" "),v("p",[_._v("出现频率：☆☆☆☆")])]),_._v(" "),v("p",[_._v("Kafka 高性能，是多方面协同的结果，包括宏观架构、分布式存储、ISR 数据同步、以及高效的利用磁盘、操作系统特性等。总结一下就是以下几个要点")]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("顺序读写")])])]),_._v(" "),v("li",[v("p",[_._v("消息分区")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("页缓存")])]),_._v(" "),v("ul",[v("li",[_._v("把磁盘中的数据缓存到"),v("strong",[_._v("内存")]),_._v("中，把对磁盘的访问变为对内存的访问")])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("零拷贝")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("非零拷贝")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220828232951641.png",alt:"image-20220828232951641"}})]),_._v(" "),v("blockquote",[v("p",[v("strong",[_._v("生产者")])]),_._v(" "),v("p",[_._v("1.发送消息给kafka")]),_._v(" "),v("p",[_._v("2.kafka把消息给系统（linux）的的页缓存")]),_._v(" "),v("p",[_._v("3.由系统决定什么时间把消息同步到磁盘中（通常情况下缓存内容数据较多的时候同步）")]),_._v(" "),v("p",[_._v("消费者：")]),_._v(" "),v("p",[_._v("1.消费者监听到kafka")]),_._v(" "),v("p",[_._v("2.kafka从页缓存读取数据")]),_._v(" "),v("p",[_._v("3.如果页缓存中没有则需要从磁盘读取数据到页缓存中")]),_._v(" "),v("p",[_._v("4.页缓存中的数据拷贝到kakfa服务")]),_._v(" "),v("p",[_._v("5.kafka把数据拷贝socket通过网卡把数据同步给消费者")])])]),_._v(" "),v("li",[v("p",[_._v("零拷贝")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/demo223/pictures/master/img/image-20220828233631899.png",alt:"image-20220828233631899"}})]),_._v(" "),v("blockquote",[v("p",[v("strong",[_._v("生产者")])]),_._v(" "),v("p",[_._v("1.发送消息给kafka")]),_._v(" "),v("p",[_._v("2.kafka把消息给系统（linux）的的页缓存")]),_._v(" "),v("p",[_._v("3.由系统决定什么时间把消息同步到磁盘中（通常情况下缓存内容数据较多的时候同步）")]),_._v(" "),v("p",[_._v("消费者：")]),_._v(" "),v("p",[_._v("1.消费者监听到kafka")]),_._v(" "),v("p",[_._v("2.kafka告知系统要把数据给消费者发送过去")]),_._v(" "),v("p",[_._v("3.如果页缓存中没有则需要从磁盘读取数据到页缓存中")]),_._v(" "),v("p",[_._v("4."),v("strong",[_._v("系统")]),_._v("调用网卡把页缓存中的数据同步给消费者")])])])])]),_._v(" "),v("li",[v("p",[_._v("消息压缩")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("分批发送")])])])]),_._v(" "),v("h3",{attrs:{id:"_2-8-kafka数据清理机制了解过嘛"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-8-kafka数据清理机制了解过嘛"}},[_._v("#")]),_._v(" 2.8 Kafka数据清理机制了解过嘛 ?")]),_._v(" "),v("blockquote",[v("p",[_._v("难易程度：☆☆☆")]),_._v(" "),v("p",[_._v("出现频率：☆☆☆")])]),_._v(" "),v("p",[_._v("Kafka中的数据保存在磁盘上以索引(xxxx.index)和日志文件(xxxx.log)的形式存储")]),_._v(" "),v("p",[_._v("日志是分段存储的，一方面能够减少单个文件内容的大小，另一方面，方便kafka 进行日志清理。")]),_._v(" "),v("p",[_._v("日志的清理策略有两个：")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("根据消息的保留时间，当消息在kafka中保存的时间超过了指定的时间，就会触发清理过程 "),v("code",[_._v("log.retention.hours=168")]),_._v(" 默认7天")])]),_._v(" "),v("li",[v("p",[_._v("根据topic存储的数据大小，当topic所占的日志文件大小大于一定的阈值，则开始删除最久的消息。")]),_._v(" "),v("blockquote",[v("p",[_._v("kafka会启动一个后台线程，定期检查是否存在可以删除的消息。"),v("code",[_._v("log.retention.bytes=1073741824")]),_._v(" 默认1G")])])])]),_._v(" "),v("p",[_._v("通过上面这两个参数来设置，当其中任意一个达到要求，都会执行删除。")]),_._v(" "),v("h3",{attrs:{id:"_2-9-使用kafka如何实现点对点消息和发布订阅消息"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-9-使用kafka如何实现点对点消息和发布订阅消息"}},[_._v("#")]),_._v(" 2.9 使用Kafka如何实现点对点消息和发布订阅消息")]),_._v(" "),v("blockquote",[v("p",[_._v("难易程度：☆☆☆")]),_._v(" "),v("p",[_._v("出现频率：☆☆☆☆")])]),_._v(" "),v("p",[_._v("Kafka的点对点消息和发布订阅消息是通过消费者组实现的 , "),v("code",[_._v("消费者组（Consumer Group）")]),_._v("是由一个或多个消费者实例（Consumer Instance）组成的群组，具有可扩展性和可容错性的一种机制。")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("点对点模式 : 让多个消费者在同一个组中, 这样同一个组中只能有有个消费者消费同一个分区的数据就是点对点模式")])]),_._v(" "),v("li",[v("p",[_._v("发布-订阅模式 :  让多个消费者处于不同的组 , 这样不同组中的消费者都能消费同一个分区的数据就是发布-订阅模式")])])]),_._v(" "),v("h2",{attrs:{id:"_3-emq"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-emq"}},[_._v("#")]),_._v(" 3 EMQ")]),_._v(" "),v("h3",{attrs:{id:"_3-1-emq是什么-你们项目中哪里用到了emq"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-emq是什么-你们项目中哪里用到了emq"}},[_._v("#")]),_._v(" 3.1 EMQ是什么 ? 你们项目中哪里用到了EMQ?")]),_._v(" "),v("blockquote",[v("p",[_._v("难易程度：☆☆☆")]),_._v(" "),v("p",[_._v("出现频率：☆☆☆☆")])]),_._v(" "),v("p",[_._v("EMQ X 是开源社区中最流行的 MQTT 消息服务器。")]),_._v(" "),v("blockquote",[v("p",[_._v("MQTT协议广泛应用于物联网、移动互联网、智能硬件、车联网、电力能源等领域。")]),_._v(" "),v("ul",[v("li",[_._v("物联网M2M通信，物联网大数据采集")]),_._v(" "),v("li",[_._v("Android消息推送，WEB消息推送")]),_._v(" "),v("li",[_._v("移动即时消息，例如Facebook Messenger")]),_._v(" "),v("li",[_._v("智能硬件、智能家居、智能电器")]),_._v(" "),v("li",[_._v("车联网通信，电动车站桩采集")]),_._v(" "),v("li",[_._v("智慧城市、远程医疗、远程教育")]),_._v(" "),v("li",[_._v("电力、石油与能源等行业市场")])])]),_._v(" "),v("p",[_._v("所以EMQ的主要运用领域也就是物联网领域, 主要使用EMQ实现物联网设备之间的相互通信, 以及服务器和物联网设备之间的相互通信")]),_._v(" "),v("p",[_._v("EMQ X 是开源百万级分布式 MQTT 消息服务器（MQTT Messaging Broker），用于支持各种接入标准 MQTT 协议的设备，实现从设备端到服务器端的消息传递，以及从服务器端到设备端的设备控制消息转发。从而实现物联网设备的数据采集，和对设备的操作和控制")]),_._v(" "),v("p",[_._v("在我们的项目中主要使用EMQ实现了服务器和物联网设备之间的信息传输 , 而且使用EMQ作为消息队列产品实现了各个微服务之间的数据传输 , 例如 :")]),_._v(" "),v("ul",[v("li",[_._v("设置状态实时监控")]),_._v(" "),v("li",[_._v("自动维修工单创建和自动补货工单创建")]),_._v(" "),v("li",[_._v("订单创建以及支付结果确认")]),_._v(" "),v("li",[_._v("设备出货控制")]),_._v(" "),v("li",[_._v("设置出货结果通知处理等")]),_._v(" "),v("li",[_._v(".....")])]),_._v(" "),v("h3",{attrs:{id:"_3-2-使用emq如何保证消息不丢失"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-使用emq如何保证消息不丢失"}},[_._v("#")]),_._v(" 3.2 使用EMQ如何保证消息不丢失 ?")]),_._v(" "),v("blockquote",[v("p",[_._v("难易程度：☆☆☆")]),_._v(" "),v("p",[_._v("出现频率：☆☆☆☆")])]),_._v(" "),v("p",[_._v("在MQTT 协议中规定了消息服务质量（Quality of Service），它保证了在不同的网络环境下消息传递的可靠性 !")]),_._v(" "),v("p",[_._v("MQTT消息"),v("strong",[_._v("服务质量")]),_._v("QoS等级有三个级别 :")]),_._v(" "),v("ul",[v("li",[_._v("0 : 消息最多传递一次, 可能会存在消息丢失")]),_._v(" "),v("li",[v("strong",[_._v("1 : 消息至少传递一次 , 不会出现消息丢失, 但是可能会出现消息重复")])]),_._v(" "),v("li",[v("strong",[_._v("2 : 消息仅传递一次 , 不会出现消息丢失, 也不会出现消息重复")])])]),_._v(" "),v("h3",{attrs:{id:"_3-3-使用emq如何保证消息不重复消费"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-使用emq如何保证消息不重复消费"}},[_._v("#")]),_._v(" 3.3 使用EMQ如何保证消息不重复消费 ?")]),_._v(" "),v("blockquote",[v("p",[_._v("难易程度：☆☆☆")]),_._v(" "),v("p",[_._v("出现频率：☆☆☆☆")])]),_._v(" "),v("p",[_._v("在MQTT 协议中规定了消息服务质量（Quality of Service），它保证了在不同的网络环境下消息传递的可靠性 !")]),_._v(" "),v("p",[_._v("MQTT消息服务质量QoS等级有三个级别 :")]),_._v(" "),v("ul",[v("li",[_._v("0 : 消息最多传递一次, 可能会存在消息丢失")]),_._v(" "),v("li",[_._v("1 : 消息至少传递一次 , 不会出现消息丢失, 但是可能会出现消息重复")]),_._v(" "),v("li",[v("strong",[_._v("2 : 消息仅传递一次 , 不会出现消息丢失, 也不会出现消息重复")])])]),_._v(" "),v("h3",{attrs:{id:"_3-4-emq支不支持延迟消息-如何实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-emq支不支持延迟消息-如何实现"}},[_._v("#")]),_._v(" 3.4 EMQ支不支持延迟消息, 如何实现 ?")]),_._v(" "),v("blockquote",[v("p",[_._v("难易程度：☆☆☆")]),_._v(" "),v("p",[_._v("出现频率：☆☆")])]),_._v(" "),v("p",[_._v("EMQ X 的延迟发布功能可以实现按照用户配置的时间间隔延迟发布 PUBLISH 报文的功能。当客户端使用特殊主题前缀 "),v("code",[_._v("$delayed/{DelayInteval}")]),_._v(" 发布消息到 EMQ X 时，将触发延迟发布功能。延迟发布的功能是针对消息发布者而言的，订阅方只需要按照正常的主题订阅即可")]),_._v(" "),v("h3",{attrs:{id:"_3-5-使用emq如何实现点对点消息和发布订阅消息"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-使用emq如何实现点对点消息和发布订阅消息"}},[_._v("#")]),_._v(" 3.5 使用EMQ如何实现点对点消息和发布订阅消息 ?")]),_._v(" "),v("blockquote",[v("p",[_._v("难易程度：☆☆☆")]),_._v(" "),v("p",[_._v("出现频率：☆☆☆")])]),_._v(" "),v("p",[_._v("默认情况下EMQ中的消息会发送给所有订阅了主题的订阅者 , 就是一种发布订阅机制")]),_._v(" "),v("p",[_._v("EMQ X 支持两种格式的共享订阅前缀：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("模式")]),_._v(" "),v("th",[_._v("示例")]),_._v(" "),v("th",[_._v("前缀")]),_._v(" "),v("th",[_._v("真实主题名")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("不带群组共享订阅")]),_._v(" "),v("td",[_._v("$queue/t/1")]),_._v(" "),v("td",[_._v("$queue/")]),_._v(" "),v("td",[_._v("t/1")])]),_._v(" "),v("tr",[v("td",[_._v("带群组共享订阅")]),_._v(" "),v("td",[_._v("$share/组名称/t/1")]),_._v(" "),v("td",[_._v("$share/abc")]),_._v(" "),v("td",[_._v("t/1")])])])]),_._v(" "),v("p",[_._v("如果想实现点对点消息, 可以采用EMQ中的"),v("code",[_._v("不带群组的共享订阅")]),_._v(" , 这样消息就只会被订阅者列表中的某一个订阅者接收, 可以在配置文件中配置负载均衡的策略"),v("code",[_._v("broker.shared_subscription_strategy = random")])]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"left"}},[_._v("均衡策略")]),_._v(" "),v("th",{staticStyle:{"text-align":"left"}},[_._v("描述")])])]),_._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"left"}},[_._v("random")]),_._v(" "),v("td",{staticStyle:{"text-align":"left"}},[_._v("在所有订阅者中随机选择")])]),_._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[_._v("round_robin")]),_._v(" "),v("td",{staticStyle:{"text-align":"left"}},[_._v("按照订阅顺序轮询")])]),_._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[_._v("sticky")]),_._v(" "),v("td",{staticStyle:{"text-align":"left"}},[_._v("一直发往上次选取的订阅者")])]),_._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[_._v("hash")]),_._v(" "),v("td",{staticStyle:{"text-align":"left"}},[_._v("按照发布者 ClientID 的哈希值")])])])]),_._v(" "),v("p",[_._v("如果想不通的群组都只能有一个订阅者接收到消息, 可以使用带群组的共享订阅   , 这样每个群组中都会有一个订阅者接收到消息")]),_._v(" "),v("h2",{attrs:{id:"_4-面试现场"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-面试现场"}},[_._v("#")]),_._v(" 4 面试现场")]),_._v(" "),v("h3",{attrs:{id:"_4-1-rabbitmq"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-rabbitmq"}},[_._v("#")]),_._v(" 4.1 RabbitMQ")]),_._v(" "),v("blockquote",[v("p",[v("strong",[_._v("面试官")]),_._v("：你们项目中哪里用到了RabbitMQ ?")]),_._v(" "),v("p",[v("strong",[_._v("候选人")]),_._v("：")]),_._v(" "),v("p",[_._v("我们项目中很多地方都使用了RabbitMQ , RabbitMQ 是我们项目中服务通信的主要方式之一 , 我们项目中服务通信主要有二种方式实现 :")]),_._v(" "),v("ol",[v("li",[_._v("通过Feign实现服务调用")]),_._v(" "),v("li",[_._v("通过MQ实现服务通信")])]),_._v(" "),v("p",[_._v("基本上除了查询请求之外, 大部分的服务调用都采用的是MQ实现的异步调用 , 例如 :")]),_._v(" "),v("ol",[v("li",[_._v("发布内容的异步审核")]),_._v(" "),v("li",[_._v("验证码的异步发送")]),_._v(" "),v("li",[_._v("用户行为数据的异步采集入库")]),_._v(" "),v("li",[_._v("搜索历史记录的异步保存")]),_._v(" "),v("li",[_._v("用户信息修改的异步通知(用户修改信息之后, 同步修改其他服务中冗余/缓存的用户信息)")]),_._v(" "),v("li",[_._v("静态化页面的生成")]),_._v(" "),v("li",[_._v("MYSQL和Redis , ES之间的数据同步")])]),_._v(" "),v("p",[v("strong",[_._v("面试官")]),_._v("：为什么会选择使用RabbitMQ ? 有什么好处 ?")]),_._v(" "),v("p",[v("strong",[_._v("候选人")]),_._v("：")]),_._v(" "),v("p",[_._v("嗯~是这样的")]),_._v(" "),v("p",[_._v("选择使用RabbitMQ是因为RabbitMQ的功能比较丰富 , 支持各种消息收发模式(简单队列模式, 工作队列模式 , 路由模式 , 直接模式 , 主题模式等) , 支持延迟队列  , 惰性队列而且天然支持集群, 保证服务的高可用, 同时性能非常不错 , 社区也比较活跃, 文档资料非常丰富")]),_._v(" "),v("p",[v("strong",[_._v("面试官")]),_._v("：好的，使用RabbitMQ  有什么好处 ?")]),_._v(" "),v("p",[v("strong",[_._v("候选人")]),_._v("：")]),_._v(" "),v("p",[_._v("嗯，这个好处很多了~~  主要体现在")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("吞吐量提升：无需等待订阅者处理完成，响应更快速")])]),_._v(" "),v("li",[v("p",[_._v("故障隔离：服务没有直接调用，不存在级联失败问题")])]),_._v(" "),v("li",[v("p",[_._v("调用间没有阻塞，不会造成无效的资源占用")])]),_._v(" "),v("li",[v("p",[_._v("耦合度极低，每个服务都可以灵活插拔，可替换")])]),_._v(" "),v("li",[v("p",[_._v("流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件")])])]),_._v(" "),v("p",[_._v("当然，使用MQ也有很多缺点，比如：")]),_._v(" "),v("ul",[v("li",[_._v("架构复杂了，业务没有明显的流程线，不好管理")]),_._v(" "),v("li",[_._v("需要依赖于Broker的可靠、安全、性能")])]),_._v(" "),v("p",[v("strong",[_._v("面试官")]),_._v("：使用RabbitMQ如何保证消息不丢失 ?")]),_._v(" "),v("p",[v("strong",[_._v("候选人")]),_._v("：")]),_._v(" "),v("p",[_._v("嗯~~我想一下")]),_._v(" "),v("p",[_._v("在使用RabbitMQ发送消息的时候，从消息发送，到消费者接收，会经历多个过程 , 其中的每一步都可能导致消息丢失")]),_._v(" "),v("p",[_._v("针对这些问题，RabbitMQ分别给出了解决方案")]),_._v(" "),v("p",[_._v("第一是：消息发送到交换机丢失 : "),v("strong",[_._v("发布者确认机制"),v("code",[_._v("publisher-confirm")])])]),_._v(" "),v("p",[_._v("消息发送到交换机失败会向生产者返回ACK , 生产者通过回调接收发送结果 , 如果发送失败, 重新发送, 或者记录日志人工介入")]),_._v(" "),v("p",[_._v("第二是：消息从交换机路由到队列丢失 : "),v("strong",[_._v("发布者回执机制"),v("code",[_._v("publisher-return")])])]),_._v(" "),v("p",[_._v("消息从交换机路由到队列失败会向生产者返回失败原因 , 生产者通过回调接收回调结果 , 如果发送失败, 重新发送, 或者记录日志人工介入")]),_._v(" "),v("p",[_._v("第三是：消息保存到队列中丢失 : MQ持久化(交换机持久化, 队列持久化 , 消息持久化)")]),_._v(" "),v("p",[_._v("第四是：消费者消费消息丢失 : 消费者确认机制 , 消费者失败重试机制")]),_._v(" "),v("p",[_._v("----------------------增强回答-----------------------")]),_._v(" "),v("p",[_._v("当然")]),_._v(" "),v("p",[_._v("通过RabbitMQ本身所提供的机制基本上已经可以保证消息不丢失  , 但是因为一些特殊的原因还是会发送消息丢失问题 , 例如 : 回调丢失 , 系统宕机, 磁盘损坏等 , 这种概率很小 , 但是如果想规避这些问题 , 进一步提高消息发送的成功率, 也可以通过程序自己进行控制")]),_._v(" "),v("p",[_._v("我们可以设计一个消息状态表 , 主要包含 : 消息id , 消息内容 , 交换机 , 消息路由key , 发送时间, 签收状态等字段 , 发送方业务执行完毕之后 , 向消息状态表保存一条消息记录, 消息状态为未签收 , 之后再向MQ发送消息 , 消费方接收消息消费完毕之后 , 向发送方发送一条签收消息 , 发送方接收到签收消息之后 , 修改消息状态表中的消息状态为已签收 ! 之后通过定时任务扫描消息状态表中这些未签收的消息 , 重新发送消息, 直到成功为止 , 对于已经完成消费的消息定时清理即可 !")]),_._v(" "),v("p",[v("strong",[_._v("面试官")]),_._v("：消息的重复消费问题如何解决的 ?")]),_._v(" "),v("p",[v("strong",[_._v("候选人")]),_._v("：")]),_._v(" "),v("p",[_._v("嗯~~")]),_._v(" "),v("p",[_._v("在使用RabbitMQ进行消息收发的时候, 如果发送失败或者消费失败会自动进行"),v("strong",[_._v("重试")]),_._v(", 那么就有可能会导致消息的重复消费")]),_._v(" "),v("p",[_._v("解决方案主要有两种方式")]),_._v(" "),v("p",[_._v("第一个是：每条消息设置一个唯一的标识id")]),_._v(" "),v("p",[_._v("第二个是：幂等方案")]),_._v(" "),v("ul",[v("li",[_._v("token+redis")]),_._v(" "),v("li",[_._v("分布式锁")]),_._v(" "),v("li",[_._v("数据库锁（悲观锁、乐观锁）")])]),_._v(" "),v("p",[v("strong",[_._v("面试官")]),_._v("：如果有100万消息堆积在MQ , 如何解决 ?")]),_._v(" "),v("p",[v("strong",[_._v("候选人")]),_._v("：")]),_._v(" "),v("p",[_._v("嗯，这个解决消息堆积有三种思路：")]),_._v(" "),v("p",[_._v("第一:提高消费者的消费能力 ,可以使用多线程消费任务")]),_._v(" "),v("p",[_._v("第二：增加更多消费者，提高消费速度")]),_._v(" "),v("p",[_._v("​\t\t\t 使用工作队列模式, 设置多个消费者消费消费同一个队列中的消息")]),_._v(" "),v("p",[_._v("第三：扩大队列容积，提高堆积上限")]),_._v(" "),v("p",[_._v("可以使用RabbitMQ惰性队列，惰性队列的好处主要是")]),_._v(" "),v("p",[_._v("①接收到消息后直接存入磁盘而非内存")]),_._v(" "),v("p",[_._v("②消费者要消费消息时才会从磁盘中读取并加载到内存")]),_._v(" "),v("p",[_._v("③支持数百万条的消息存储")]),_._v(" "),v("p",[v("strong",[_._v("面试官")]),_._v("：RabbitMQ如何保证消费的顺序性 ?")]),_._v(" "),v("p",[v("strong",[_._v("候选人")]),_._v("：")]),_._v(" "),v("p",[_._v("嗯，这个是比较简单的，可以让一个队列只设置一个消费者消费即可 , 多个消费者之间是无法保证消息消费顺序性的")]),_._v(" "),v("p",[v("strong",[_._v("面试官")]),_._v("：RabbitMQ的延迟队列有了解过嘛 ?")]),_._v(" "),v("p",[v("strong",[_._v("候选人")]),_._v("：")]),_._v(" "),v("p",[_._v("嗯，RabbitMQ的延迟队列有二种实现方案 :")]),_._v(" "),v("ol",[v("li",[_._v("使用消息过期TTL + 死信交换机")]),_._v(" "),v("li",[_._v("使用延迟交换机插件")])]),_._v(" "),v("p",[v("strong",[_._v("面试官")]),_._v("：RabbitMQ如何设置消息过期 ?")]),_._v(" "),v("p",[v("strong",[_._v("候选人")]),_._v("：")]),_._v(" "),v("p",[_._v("RabbitMQ置消息过期的方式有二种 :")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("为队列设置过期时间, 所有进到这个队列的消息就会具有统一的过期时间")])]),_._v(" "),v("li",[v("p",[_._v("为消息单独设置过期时间")])])]),_._v(" "),v("p",[_._v("不过，这两种方式也有不同")]),_._v(" "),v("ol",[v("li",[_._v("队列过期和消息过期同时存在 , 会以时间短的时间为准")]),_._v(" "),v("li",[_._v("RabbitMQ队列消息过期的机制是判断队列头部元素是否过期 , 如果队里头部消息没有到过期时间 , 中间消息到了过期时间, 这个消息也不会被自动剔除")])]),_._v(" "),v("p",[v("strong",[_._v("面试官")]),_._v("：什么情况下消息会成为死信 ?")]),_._v(" "),v("p",[v("strong",[_._v("候选人")]),_._v("：")]),_._v(" "),v("p",[_._v("嗯~，是这样，有这么几种情况吧。")]),_._v(" "),v("p",[_._v("第一，当消费者使用basic.reject或 basic.nack声明消费失败，并且消息的requeue参数设置为false")]),_._v(" "),v("p",[_._v("第二，消息是一个过期消息，超时无人消费")]),_._v(" "),v("p",[_._v("第三，要投递的队列消息满了，无法投递")]),_._v(" "),v("p",[_._v("当一个队列中出现这些情况之一时，就会成为死信（dead letter）：")]),_._v(" "),v("p",[v("strong",[_._v("面试官")]),_._v("：什么是死信交换机 ? 如何为队列绑定死信交换机 ?")]),_._v(" "),v("p",[v("strong",[_._v("候选人")]),_._v("：")]),_._v(" "),v("p",[_._v("嗯~，知道的")]),_._v(" "),v("p",[_._v("死信交换机和正常的交换机没有什么不同 , 如果一个包含死信的队列配置了"),v("code",[_._v("dead-letter-exchange")]),_._v("属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为"),v("strong",[_._v("死信交换机")])]),_._v(" "),v("p",[_._v("为队列绑定死信交换机 , 只需要设置队列属性 "),v("code",[_._v("dead-letter-exchange")]),_._v("即可")]),_._v(" "),v("p",[v("strong",[_._v("面试官")]),_._v("：RabbitMQ的高可用机制有了解过嘛 ?")]),_._v(" "),v("p",[v("strong",[_._v("候选人")]),_._v("：")]),_._v(" "),v("p",[_._v("嗯，这个知道一些~~")]),_._v(" "),v("p",[_._v("RabbitMQ的是基于Erlang语言编写，而Erlang又是一个面向并发的语言，天然支持集群模式。RabbitMQ的集群有两种模式：")]),_._v(" "),v("p",[_._v("第一是：普通集群，是一种分布式集群，将队列分散到集群的各个节点，从而提高整个集群的并发能力。")]),_._v(" "),v("ul",[v("li",[_._v("会在集群的各个节点间共享部分数据，包括：交换机、队列元信息。不包含队列中的消息。")]),_._v(" "),v("li",[_._v("当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回")]),_._v(" "),v("li",[_._v("队列所在节点宕机，队列中的消息就会丢失")])]),_._v(" "),v("p",[v("strong",[_._v("镜像集群")]),_._v("：是一种主从集群，普通集群的基础上，添加了主从备份功能，提高集群的数据可用性。")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份。")])]),_._v(" "),v("li",[v("p",[_._v("创建队列的节点被称为该队列的"),v("strong",[_._v("主节点，"),v("strong",[_._v("备份到的其它节点叫做该队列的")]),_._v("镜像")]),_._v("节点。")])]),_._v(" "),v("li",[v("p",[_._v("一个队列的主节点可能是另一个队列的镜像节点")])]),_._v(" "),v("li",[v("p",[_._v("所有操作都是主节点完成，然后同步给镜像节点")])]),_._v(" "),v("li",[v("p",[_._v("主宕机后，镜像节点会替代成新的主")])])]),_._v(" "),v("p",[_._v("通常在生产环境下，我们采用的都是镜像集群。")])]),_._v(" "),v("h3",{attrs:{id:"_4-2-kafka"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-kafka"}},[_._v("#")]),_._v(" 4.2 Kafka")]),_._v(" "),v("blockquote",[v("p",[v("strong",[_._v("面试官")]),_._v("：你们项目中哪里用到了Kafka?")]),_._v(" "),v("p",[v("strong",[_._v("候选人")]),_._v("：")]),_._v(" "),v("p",[_._v("我们项目中很多地方都使用了Kafka, Kafka是我们项目中服务通信的主要方式之一 , 我们项目中服务通信主要有二种方式实现 :")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("通过Feign实现服务调用")])]),_._v(" "),v("li",[v("p",[_._v("通过Kafka实现服务通信")])])]),_._v(" "),v("p",[_._v("基本上除了查询请求之外, 大部分的服务调用都采用的是Kafka实现的异步调用 , 例如 :")]),_._v(" "),v("ol",[v("li",[_._v("发布内容的异步审核")]),_._v(" "),v("li",[_._v("验证码的异步发送")]),_._v(" "),v("li",[_._v("用户行为数据的异步采集入库")]),_._v(" "),v("li",[_._v("搜索历史记录的异步保存")]),_._v(" "),v("li",[_._v("用户信息修改的异步通知(用户修改信息之后, 同步修改其他服务中冗余/缓存的用户信息)")]),_._v(" "),v("li",[_._v("静态化页面的生成")]),_._v(" "),v("li",[_._v("MYSQL和Redis , ES之间的数据同步")]),_._v(" "),v("li",[_._v("推荐数据实时计算")])]),_._v(" "),v("p",[v("strong",[_._v("面试官")]),_._v("：为什么会选择使用Kafka? 有什么好处 ?")]),_._v(" "),v("p",[v("strong",[_._v("候选人")]),_._v("：")]),_._v(" "),v("p",[_._v("嗯~~~")]),_._v(" "),v("p",[_._v("选择使用Kafka是因为Kafka作为中间件他的吞吐量比较高 , 我们的系统中主要使用Kafka来处理一些用户的行为数据 , 用户行为数据用户操作成本低 , 数据量比较大 , 需要有更高的吞吐量支持 , 并且我们在项目中需要实现根据用户行为的实时推荐 , 运营端后台管理系统首页看板数据的实体展示 !")]),_._v(" "),v("p",[v("strong",[_._v("使用Kafka有很多好处：")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("吞吐量提升：无需等待订阅者处理完成，响应更快速")])]),_._v(" "),v("li",[v("p",[_._v("故障隔离：服务没有直接调用，不存在级联失败问题")])]),_._v(" "),v("li",[v("p",[_._v("调用间没有阻塞，不会造成无效的资源占用")])]),_._v(" "),v("li",[v("p",[_._v("耦合度极低，每个服务都可以灵活插拔，可替换")])]),_._v(" "),v("li",[v("p",[_._v("流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件")])])]),_._v(" "),v("p",[v("strong",[_._v("面试官")]),_._v("：使用Kafka如何保证消息不丢失 ?")]),_._v(" "),v("p",[v("strong",[_._v("候选人")]),_._v("：")]),_._v(" "),v("p",[_._v("嗯，这个保证机制很多，在发送消息到消费者接收消息，都有可能丢失，所以在每个阶段都可以有方案解决，比如：")]),_._v(" "),v("p",[_._v("第一：生产者发送消息到Brocker丢失")]),_._v(" "),v("p",[_._v("设置同步发送和异步发送")]),_._v(" "),v("ul",[v("li",[_._v("同步发送可以通过get()获取到消息的发送结果 , 阻塞方案, 效率比较低")]),_._v(" "),v("li",[_._v("异步发送可以通过回调获取到消息的发送接口 , 非阻塞方案, 效率较高 , 可能会出现回调丢失")]),_._v(" "),v("li",[_._v("设置消息发送失败的重试次数, 设置为一个很大的值, 发送失败不断重试")])]),_._v(" "),v("p",[_._v("第二：消息在Brocker中存储丢失")]),_._v(" "),v("p",[_._v("Kafka提供了分区的备份机制 , 可以为每个分区设置多个副本 , 主分区服务器宕机, 副本分区还有完整数据")]),_._v(" "),v("p",[_._v("主分区数据同步到副本分区之前, 主分区宕机也有可能会出现消息丢失问题 , 解决方案就是设置消息确认的ACKS ,关于acks有三种确认机制：")]),_._v(" "),v("ul",[v("li",[_._v("acks=0的时候，生产者发送消息不需要服务器确认，风险较大，但效率最高")]),_._v(" "),v("li",[_._v("acks=1的时候，这个是默认值，只要集群主节点收到消息并确认就行了")]),_._v(" "),v("li",[_._v("acks=all的时候，需要集群中的所有节点都收到消息并确认才行，消息比较安全，但效率较低")])]),_._v(" "),v("p",[_._v("第三：消费者从Brocker接收消息丢失")]),_._v(" "),v("p",[_._v("消费者是通过offset来定位消费数据的 , 当消费者出现故障之后会触发重平衡, 会为消费者组中的消费者重新分配消费分区, 正常情况下是没有问题的 , 这也是Kafka提供的消费保障机制")]),_._v(" "),v("p",[_._v("但是在重平衡的过程中 , 因为Kafka默认子每隔5S自动提交偏移量 , 那么就有可能会出现消息丢失和重复消费问题")]),_._v(" "),v("ul",[v("li",[_._v("如果提交偏移量小于客户端处理的最后一个消息的偏移量，那么处于两个偏移量之间的消息就会被重复处理。")]),_._v(" "),v("li",[_._v("如果提交的偏移量大于客户端的最后一个消息的偏移量，那么处于两个偏移量之间的消息将会丢失。")])]),_._v(" "),v("p",[_._v("解决方案有二种 :")]),_._v(" "),v("ol",[v("li",[_._v("设置更小的自动提交偏移量的周期 , 周期越小出现问题的概率也就越小, 对消费者性能和服务器压力的影响就越大(缓解方案,不能从根本上解决问题)")]),_._v(" "),v("li",[_._v("消费完毕手动提交偏移量")]),_._v(" "),v("li",[_._v("同步提交  : 会阻塞, 效率低 , 但是会重试 , 直到成功为止")]),_._v(" "),v("li",[_._v("异步提交 : 不会阻塞 , 效率高 , 但是不会重试 , 可能会出现提交失败问题")]),_._v(" "),v("li",[_._v("同步异步结合")])]),_._v(" "),v("p",[_._v("------------------增强回答-----------------------")]),_._v(" "),v("p",[_._v("通过Kafka本身所提供的机制基本上已经可以保证消息不丢失  , 但是因为一些特殊的原因还是会发送消息丢失问题 , 例如 : 回调丢失 , 系统宕机, 磁盘损坏等 , 这种概率很小 , 但是如果想规避这些问题 , 进一步提高消息发送的成功率, 也可以通过程序自己进行控制")]),_._v(" "),v("p",[_._v("设计一个消息状态表 , 主要包含 : 消息id , 消息内容 , 交换机 , 消息路由key , 发送时间, 签收状态等字段 , 发送方业务执行完毕之后 , 向消息状态表保存一条消息记录, 消息状态为未签收 , 之后再向Kafka发送消息 , 消费方接收消息消费完毕之后 , 向发送方发送一条签收消息 , 发送方接收到签收消息之后 , 修改消息状态表中的消息状态为已签收 ! 之后通过定时任务扫描消息状态表中这些未签收的消息 , 重新发送消息, 直到成功为止 , 对于已经完成消费的消息定时清理即可 !")]),_._v(" "),v("p",[v("strong",[_._v("面试官")]),_._v("：消息的重复消费问题如何解决的 ?")]),_._v(" "),v("p",[v("strong",[_._v("候选人")]),_._v("：")]),_._v(" "),v("p",[_._v("嗯，这个也有两种思路可以解决")]),_._v(" "),v("p",[_._v("第一是kafka本身可以解决")]),_._v(" "),v("p",[_._v("消费者是通过offset来定位消费数据的 , 当消费者出现故障之后会触发重平衡, 会为消费者组中的消费者重新分配消费分区, 正常情况下是没有问题的 , 这也是Kafka提供的消费保障机制")]),_._v(" "),v("p",[_._v("但是在重平衡的过程中 , 因为Kafka默认子每隔5S自动提交偏移量 , 那么就有可能会出现消息丢失和重复消费问题")]),_._v(" "),v("p",[_._v("如果提交偏移量小于客户端处理的最后一个消息的偏移量，那么处于两个偏移量之间的消息就会被重复处理。")]),_._v(" "),v("p",[_._v("解决方案有二种 :")]),_._v(" "),v("ol",[v("li",[_._v("设置更小的自动提交偏移量的周期 , 周期越小出现问题的概率也就越小, 对消费者性能和服务器压力的影响就越大(缓解方案,不能从根本上解决问题)")]),_._v(" "),v("li",[_._v("消费完毕手动提交偏移量")]),_._v(" "),v("li",[_._v("同步提交  : 会阻塞, 效率低 , 但是会重试 , 直到成功为止")]),_._v(" "),v("li",[_._v("异步提交 : 不会阻塞 , 效率高 , 但是不会重试 , 可能会出现提交失败问题")]),_._v(" "),v("li",[_._v("同步异步结合")])]),_._v(" "),v("p",[_._v("第二是，我们从业务层面直接解决")]),_._v(" "),v("p",[_._v("基于上面的操作如果因为网络原因, 服务器原因出现偏移量提交失败的情况 , 还是会出现重复消费 , 具体的解决方案如下：")]),_._v(" "),v("ul",[v("li",[_._v("每条消息设置一个唯一的标识id")]),_._v(" "),v("li",[_._v("幂等方案")]),_._v(" "),v("li",[_._v("token+redis")]),_._v(" "),v("li",[_._v("分布式锁")]),_._v(" "),v("li",[_._v("数据库锁（悲观锁、乐观锁）")])]),_._v(" "),v("p",[v("strong",[_._v("面试官")]),_._v("：Kafka如何保证消费的顺序性 ?")]),_._v(" "),v("p",[v("strong",[_._v("候选人")]),_._v("：")]),_._v(" "),v("p",[_._v("kafka中的topic分区中消息只能由消费者组中的唯一一个消费者处理，所以消息肯定是按照先后顺序进行处理的。")]),_._v(" "),v("p",[_._v("但是它也仅仅是保证Topic的一个分区顺序处理，不能保证跨分区的消息先后处理顺序。")]),_._v(" "),v("p",[_._v("所以，如果你想要顺序的处理Topic的所有消息，那就只提供一个分区。")]),_._v(" "),v("p",[_._v("设置分区有两种方式：")]),_._v(" "),v("p",[_._v("第一是：在发送消息的时候可以指定分区")]),_._v(" "),v("p",[_._v("第二是：在发送消息的时候可以指定消息的key，同一个业务指定相同的key，因为分区也是通过key进行hash运算后计算的分区，如果是相同的key，那肯定是在同一个分区下")]),_._v(" "),v("p",[v("strong",[_._v("面试官")]),_._v("：Kafka的高可用机制有了解过嘛 ?")]),_._v(" "),v("p",[v("strong",[_._v("候选人")]),_._v("：")]),_._v(" "),v("p",[_._v("Kafka作为一款使用比较广泛的消息中间件产品, 本身也提供了一些机制去实现高可用 , 主要包括 :")]),_._v(" "),v("ol",[v("li",[_._v("Kafka 集群  : 通过集群模式, 保证Brocker的高可用")]),_._v(" "),v("li",[_._v("分区备份机制  : Kafka会为每一个分区设置副本 , 可以手动指定副本数量 , 这些副本会分配到Kafka的不同的Brocker上存储 , 这样可以保证Kafka数据高可用")]),_._v(" "),v("li",[_._v("重平衡 : 当消费者组中重新加入消费者 , 或者消费者组中有消费者宕机 , 这个时候Kafka会为消费者组中的消费者从新分配消费分区的过程就是再均衡 , 通过重平衡消实现了消费者的高可用")])]),_._v(" "),v("p",[v("strong",[_._v("面试官")]),_._v("：Kafka实现高性能的设计有了解过嘛 ?")]),_._v(" "),v("p",[v("strong",[_._v("候选人")]),_._v("：")]),_._v(" "),v("p",[_._v("Kafka 高性能，是多方面协同的结果，包括宏观架构、分布式存储、ISR 数据同步、以及高效的利用磁盘、操作系统特性等。主要体现有这么几点：")]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("顺序读写")])])]),_._v(" "),v("li",[v("p",[_._v("消息分区")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("页缓存")])])]),_._v(" "),v("li",[v("p",[_._v("把磁盘中的数据缓存到"),v("strong",[_._v("内存")]),_._v("中，把对磁盘的访问变为对内存的访问")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("零拷贝")])])]),_._v(" "),v("li",[v("p",[_._v("消息压缩")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("分批发送")])])])]),_._v(" "),v("p",[v("strong",[_._v("面试官")]),_._v("：好的，你能详细介绍一下零拷贝吗？")]),_._v(" "),v("p",[v("strong",[_._v("候选人")]),_._v("：")]),_._v(" "),v("p",[_._v("嗯，好的")]),_._v(" "),v("p",[_._v("在聊零拷贝之前，我先说一下不是零拷贝的过程。")]),_._v(" "),v("p",[_._v("比如现在一个生产者发送消息，消费者接收消息。这个时候的一个过程大概这样子")]),_._v(" "),v("p",[_._v("①生产者发送消息给kafka")]),_._v(" "),v("p",[_._v("②kafka把消息给系统（linux）的的页缓存")]),_._v(" "),v("p",[_._v("③由系统决定什么时间把消息同步到磁盘中（通常情况下缓存内容数据较多的时候同步）")]),_._v(" "),v("p",[_._v("④消费者监听到kafka有消息可以消费")]),_._v(" "),v("p",[_._v("⑤kafka从页缓存读取数据")]),_._v(" "),v("p",[_._v("⑥如果页缓存中没有则需要从磁盘读取数据到页缓存中")]),_._v(" "),v("p",[_._v("⑦页缓存中的数据拷贝到kakfa服务")]),_._v(" "),v("p",[_._v("⑧kafka把数据拷贝socket通过网卡把数据同步给消费者")]),_._v(" "),v("p",[_._v("这样就结束了，这个里面存在了多次的数据拷贝的工作，其实是比较浪费性能的，如果是零拷贝就能提升很多，零拷贝的过程是这样的：")]),_._v(" "),v("p",[_._v("①生产者发送消息给kafka")]),_._v(" "),v("p",[_._v("②kafka把消息给系统（linux）的的页缓存")]),_._v(" "),v("p",[_._v("③由系统决定什么时间把消息同步到磁盘中（通常情况下缓存内容数据较多的时候同步）")]),_._v(" "),v("p",[_._v("④消费者监听到kafka")]),_._v(" "),v("p",[_._v("⑤kafka告知系统要把数据给消费者发送过去")]),_._v(" "),v("p",[_._v("⑥如果页缓存中没有则需要从磁盘读取数据到页缓存中")]),_._v(" "),v("p",[_._v("⑦系统调用网卡把页缓存中的数据同步给消费者")]),_._v(" "),v("p",[_._v("零拷贝操作就是说kafka不用把数据再拷贝一次，直接通知系统去通过网络发消息就可以了，所以说性能上比较高。")]),_._v(" "),v("p",[v("strong",[_._v("面试官")]),_._v("：Kafka数据清理机制了解过嘛 ?")]),_._v(" "),v("p",[v("strong",[_._v("候选人")]),_._v("：")]),_._v(" "),v("p",[_._v("嗯，了解过~~")]),_._v(" "),v("p",[_._v("Kafka中的数据保存在磁盘上以索引(xxxx.index)和日志文件(xxxx.log)的形式存储")]),_._v(" "),v("p",[_._v("日志是分段存储的，一方面能够减少单个文件内容的大小，另一方面，方便kafka 进行日志清理。")]),_._v(" "),v("p",[_._v("日志的清理策略有两个：")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("根据消息的保留时间，当消息在kafka中保存的时间超过了指定的时间，就会触发清理过程 "),v("code",[_._v("log.retention.hours=168")]),_._v(" 默认7天")])]),_._v(" "),v("li",[v("p",[_._v("根据topic存储的数据大小，当topic所占的日志文件大小大于一定的阈值，则开始删除最久的消息。")])])]),_._v(" "),v("p",[_._v("kafka会启动一个后台线程，定期检查是否存在可以删除的消息。"),v("code",[_._v("log.retention.bytes=1073741824")]),_._v(" 默认1G")]),_._v(" "),v("p",[_._v("通过这两个参数来设置，当其中任意一个达到要求，都会执行删除。")]),_._v(" "),v("p",[v("strong",[_._v("面试官")]),_._v("：使用Kafka如何实现点对点消息和发布订阅消息")]),_._v(" "),v("p",[v("strong",[_._v("候选人")]),_._v("：")]),_._v(" "),v("p",[_._v("Kafka的点对点消息和发布订阅消息是通过消费者组实现的 , "),v("code",[_._v("消费者组（Consumer Group）")]),_._v("是由一个或多个消费者实例（Consumer Instance）组成的群组，具有可扩展性和可容错性的一种机制。")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("点对点模式 : 让多个消费者在同一个组中, 这样同一个组中只能有有个消费者消费同一个分区的数据就是点对点模式")])]),_._v(" "),v("li",[v("p",[_._v("发布-订阅模式 :  让多个消费者处于不同的组 , 这样不同组中的消费者都能消费同一个分区的数据就是发布-订阅模式")])])])]),_._v(" "),v("h3",{attrs:{id:"_4-3-emq"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-emq"}},[_._v("#")]),_._v(" 4.3 EMQ")]),_._v(" "),v("blockquote",[v("p",[v("strong",[_._v("面试官")]),_._v("：EMQ是什么 ? 你们项目中哪里用到了EMQ?")]),_._v(" "),v("p",[v("strong",[_._v("候选人")]),_._v("：")]),_._v(" "),v("p",[_._v("EMQ的主要运用领域也就是物联网领域, 主要使用EMQ实现物联网设备之间的相互通信, 以及服务器和物联网设备之间的相互通信")]),_._v(" "),v("p",[_._v("EMQ X 是开源百万级分布式 MQTT 消息服务器（MQTT Messaging Broker），用于支持各种接入标准 MQTT 协议的设备，实现从设备端到服务器端的消息传递，以及从服务器端到设备端的设备控制消息转发。从而实现物联网设备的数据采集，和对设备的操作和控制")]),_._v(" "),v("p",[_._v("在我们的项目中主要使用EMQ实现了服务器和物联网设备之间的信息传输 , 而且使用EMQ作为消息队列产品实现了各个微服务之间的数据传输 , 例如 :")]),_._v(" "),v("ul",[v("li",[_._v("设置状态实时监控")]),_._v(" "),v("li",[_._v("自动维修工单创建和自动补货工单创建")]),_._v(" "),v("li",[_._v("订单创建以及支付结果确认")]),_._v(" "),v("li",[_._v("设备出货控制")]),_._v(" "),v("li",[_._v("设置出货结果通知处理等")])]),_._v(" "),v("p",[v("strong",[_._v("面试官")]),_._v("：使用EMQ如何保证消息不丢失 ?")]),_._v(" "),v("p",[v("strong",[_._v("候选人")]),_._v("：")]),_._v(" "),v("p",[_._v("嗯，是这样的~~")]),_._v(" "),v("p",[_._v("在MQTT 协议中规定了消息服务质量（Quality of Service），它保证了在不同的网络环境下消息传递的可靠性 !")]),_._v(" "),v("p",[_._v("MQTT消息"),v("strong",[_._v("服务质量")]),_._v("QoS等级有三个级别 :")]),_._v(" "),v("ul",[v("li",[_._v("0 : 消息最多传递一次, 可能会存在消息丢失")]),_._v(" "),v("li",[v("strong",[_._v("1 : 消息至少传递一次 , 不会出现消息丢失, 但是可能会出现消息重复")])]),_._v(" "),v("li",[v("strong",[_._v("2 : 消息仅传递一次 , 不会出现消息丢失, 也不会出现消息重复")])])]),_._v(" "),v("p",[_._v("我们可以把服务质量Qos设置为1或2，保证消息是可以不丢失的")]),_._v(" "),v("p",[v("strong",[_._v("面试官")]),_._v("：使用EMQ如何保证消息不重复消费 ?")]),_._v(" "),v("p",[v("strong",[_._v("候选人")]),_._v("：")]),_._v(" "),v("p",[_._v("在MQTT 协议中规定了消息服务质量（Quality of Service），它保证了在不同的网络环境下消息传递的可靠性 !")]),_._v(" "),v("p",[_._v("MQTT消息服务质量QoS等级有三个级别 :")]),_._v(" "),v("ul",[v("li",[_._v("0 : 消息最多传递一次, 可能会存在消息丢失")]),_._v(" "),v("li",[_._v("1 : 消息至少传递一次 , 不会出现消息丢失, 但是可能会出现消息重复")]),_._v(" "),v("li",[v("strong",[_._v("2 : 消息仅传递一次 , 不会出现消息丢失, 也不会出现消息重复")])])]),_._v(" "),v("p",[_._v("我们可以把消息的服务质量Qos的值设置为2，这样就能避免消息的重复消费")]),_._v(" "),v("p",[v("strong",[_._v("面试官")]),_._v("：EMQ支不支持延迟消息, 如何实现 ?")]),_._v(" "),v("p",[v("strong",[_._v("候选人")]),_._v("：")]),_._v(" "),v("p",[_._v("嗯，EMQ支持延迟发布。")]),_._v(" "),v("p",[_._v("当客户端使用特殊主题前缀 "),v("code",[_._v("$delayed/{DelayInteval}")]),_._v(" 发布消息到 EMQ X 时，将触发延迟发布功能。延迟发布的功能是针对消息发布者而言的，订阅方只需要按照正常的主题订阅即可")]),_._v(" "),v("p",[v("strong",[_._v("面试官")]),_._v("：使用EMQ如何实现点对点消息和发布订阅消息 ?")]),_._v(" "),v("p",[v("strong",[_._v("候选人")]),_._v("：")]),_._v(" "),v("p",[_._v("嗯~~，是这样")]),_._v(" "),v("p",[_._v("默认情况下EMQ中的消息会发送给所有订阅了主题的订阅者 , 就是一种发布订阅机制")]),_._v(" "),v("p",[_._v("EMQ是支持两种格式的共享订阅前缀：")]),_._v(" "),v("p",[_._v("第一是：不带群组的共享订阅")]),_._v(" "),v("p",[_._v("第二是：带群组的共享订阅")]),_._v(" "),v("p",[_._v("如果想实现点对点消息, 可以采用EMQ中的"),v("code",[_._v("不带群组的共享订阅")]),_._v(" , 这样消息就只会被订阅者列表中的某一个订阅者接收")]),_._v(" "),v("p",[_._v("如果想不通的群组都只能有一个订阅者接收到消息, 可以使用带群组的共享订阅   , 这样每个群组中都会有一个订阅者接收到消息")])])])}),[],!1,null,null,null);v.default=s.exports}}]);